!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AllocationMode	concurrentqueue/concurrentqueue.h	/^	enum AllocationMode { CanAlloc, CannotAlloc };$/;"	g	class:ConcurrentQueue	access:private
Args	json/json.h	/^  typedef std::vector<PathArgument> Args;$/;"	t	class:Json::Path	access:private
ArrayIndex	json/json-forwards.h	/^typedef unsigned int ArrayIndex;$/;"	t	namespace:Json
ArrayIndex	json/json.h	/^  typedef Json::ArrayIndex ArrayIndex;$/;"	t	class:Json::Value	access:public
ArrayIndex	json/json.h	/^typedef unsigned int ArrayIndex;$/;"	t	namespace:Json
BLOCK_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t BLOCK_SIZE = 32;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
BLOCK_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t BLOCK_SIZE = static_cast<size_t>(Traits::BLOCK_SIZE);$/;"	m	class:ConcurrentQueue	access:public
Block	concurrentqueue/concurrentqueue.h	/^		Block()$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:()
Block	concurrentqueue/concurrentqueue.h	/^	struct Block$/;"	s	class:ConcurrentQueue	access:private
BlockIndexEntry	concurrentqueue/concurrentqueue.h	/^		struct BlockIndexEntry$/;"	s	struct:ConcurrentQueue::ExplicitProducer	access:private
BlockIndexHeader	concurrentqueue/concurrentqueue.h	/^		struct BlockIndexHeader$/;"	s	struct:ConcurrentQueue::ExplicitProducer	access:private
CPPTL_JSON_ASSERTIONS_H_INCLUDED	json/json.h	1974;"	d
CPPTL_JSON_FEATURES_H_INCLUDED	json/json.h	292;"	d
CPPTL_JSON_H_INCLUDED	json/json.h	363;"	d
CPPTL_JSON_READER_H_INCLUDED	json/json.h	1218;"	d
CZString	json/json.h	/^    CZString(ArrayIndex index);$/;"	p	class:Json::Value::CZString	access:public	signature:(ArrayIndex index)
CZString	json/json.h	/^    CZString(CZString const& other);$/;"	p	class:Json::Value::CZString	access:public	signature:(CZString const& other)
CZString	json/json.h	/^    CZString(char const* str, unsigned length, DuplicationPolicy allocate);$/;"	p	class:Json::Value::CZString	access:public	signature:(char const* str, unsigned length, DuplicationPolicy allocate)
CZString	json/json.h	/^  class CZString {$/;"	c	class:Json::Value	access:private
CanAlloc	concurrentqueue/concurrentqueue.h	/^	enum AllocationMode { CanAlloc, CannotAlloc };$/;"	e	enum:ConcurrentQueue::AllocationMode
CannotAlloc	concurrentqueue/concurrentqueue.h	/^	enum AllocationMode { CanAlloc, CannotAlloc };$/;"	e	enum:ConcurrentQueue::AllocationMode
Char	json/json.h	/^  typedef char Char;$/;"	t	class:Json::Reader	access:public
CharReader	json/json.h	/^class JSON_API CharReader {$/;"	c	namespace:Json
CharReaderBuilder	json/json.h	/^  CharReaderBuilder();$/;"	p	class:Json::CharReaderBuilder	access:public	signature:()
CharReaderBuilder	json/json.h	/^class JSON_API CharReaderBuilder : public CharReader::Factory {$/;"	c	namespace:Json	inherits:CharReader::Factory
ChildValues	json/json.h	/^  typedef std::vector<std::string> ChildValues;$/;"	t	class:Json::StyledStreamWriter	access:private
ChildValues	json/json.h	/^  typedef std::vector<std::string> ChildValues;$/;"	t	class:Json::StyledWriter	access:private
CommentInfo	json/json.h	/^    CommentInfo();$/;"	p	struct:Json::Value::CommentInfo	access:public	signature:()
CommentInfo	json/json.h	/^  struct CommentInfo {$/;"	s	class:Json::Value	access:private
CommentPlacement	json/json.h	/^enum CommentPlacement {$/;"	g	namespace:Json
ConcurrentQueue	concurrentqueue/concurrentqueue.h	/^	ConcurrentQueue(size_t minCapacity, size_t maxExplicitProducers, size_t maxImplicitProducers)$/;"	f	class:ConcurrentQueue	access:public	signature:(size_t minCapacity, size_t maxExplicitProducers, size_t maxImplicitProducers)
ConcurrentQueue	concurrentqueue/concurrentqueue.h	/^	explicit ConcurrentQueue(size_t capacity = 6 * BLOCK_SIZE)$/;"	f	class:ConcurrentQueue	access:public	signature:(size_t capacity = 6 * BLOCK_SIZE)
ConcurrentQueue	concurrentqueue/concurrentqueue.h	/^class ConcurrentQueue$/;"	c
ConcurrentQueue::AllocationMode	concurrentqueue/concurrentqueue.h	/^	enum AllocationMode { CanAlloc, CannotAlloc };$/;"	g	class:ConcurrentQueue	access:private
ConcurrentQueue::BLOCK_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t BLOCK_SIZE = static_cast<size_t>(Traits::BLOCK_SIZE);$/;"	m	class:ConcurrentQueue	access:public
ConcurrentQueue::Block	concurrentqueue/concurrentqueue.h	/^	struct Block$/;"	s	class:ConcurrentQueue	access:private
ConcurrentQueue::Block::Block	concurrentqueue/concurrentqueue.h	/^		Block()$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:()
ConcurrentQueue::Block::dynamicallyAllocated	concurrentqueue/concurrentqueue.h	/^		bool dynamicallyAllocated;		\/\/ Perhaps a better name for this would be 'isNotPartOfInitialBlockPool'$/;"	m	struct:ConcurrentQueue::Block	access:public
ConcurrentQueue::Block::elements	concurrentqueue/concurrentqueue.h	/^		char elements[sizeof(T) * BLOCK_SIZE];$/;"	m	struct:ConcurrentQueue::Block	access:private
ConcurrentQueue::Block::elementsCompletelyDequeued	concurrentqueue/concurrentqueue.h	/^		std::atomic<size_t> elementsCompletelyDequeued;$/;"	m	struct:ConcurrentQueue::Block	access:public
ConcurrentQueue::Block::emptyFlags	concurrentqueue/concurrentqueue.h	/^		std::atomic<bool> emptyFlags[BLOCK_SIZE <= EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD ? BLOCK_SIZE : 1];$/;"	m	struct:ConcurrentQueue::Block	access:public
ConcurrentQueue::Block::freeListNext	concurrentqueue/concurrentqueue.h	/^		std::atomic<Block*> freeListNext;$/;"	m	struct:ConcurrentQueue::Block	access:public
ConcurrentQueue::Block::freeListRefs	concurrentqueue/concurrentqueue.h	/^		std::atomic<std::uint32_t> freeListRefs;$/;"	m	struct:ConcurrentQueue::Block	access:public
ConcurrentQueue::Block::is_empty	concurrentqueue/concurrentqueue.h	/^		inline bool is_empty() const$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:() const
ConcurrentQueue::Block::next	concurrentqueue/concurrentqueue.h	/^		Block* next;$/;"	m	struct:ConcurrentQueue::Block	access:public
ConcurrentQueue::Block::owner	concurrentqueue/concurrentqueue.h	/^		void* owner;$/;"	m	struct:ConcurrentQueue::Block	access:public
ConcurrentQueue::Block::reset_empty	concurrentqueue/concurrentqueue.h	/^		inline void reset_empty()$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:()
ConcurrentQueue::Block::set_all_empty	concurrentqueue/concurrentqueue.h	/^		inline void set_all_empty()$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:()
ConcurrentQueue::Block::set_empty	concurrentqueue/concurrentqueue.h	/^		inline bool set_empty(index_t i)$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:(index_t i)
ConcurrentQueue::Block::set_many_empty	concurrentqueue/concurrentqueue.h	/^		inline bool set_many_empty(index_t i, size_t count)$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:(index_t i, size_t count)
ConcurrentQueue::Block::shouldBeOnFreeList	concurrentqueue/concurrentqueue.h	/^		std::atomic<bool> shouldBeOnFreeList;$/;"	m	struct:ConcurrentQueue::Block	access:public
ConcurrentQueue::CanAlloc	concurrentqueue/concurrentqueue.h	/^	enum AllocationMode { CanAlloc, CannotAlloc };$/;"	e	enum:ConcurrentQueue::AllocationMode
ConcurrentQueue::CannotAlloc	concurrentqueue/concurrentqueue.h	/^	enum AllocationMode { CanAlloc, CannotAlloc };$/;"	e	enum:ConcurrentQueue::AllocationMode
ConcurrentQueue::ConcurrentQueue	concurrentqueue/concurrentqueue.h	/^	ConcurrentQueue(size_t minCapacity, size_t maxExplicitProducers, size_t maxImplicitProducers)$/;"	f	class:ConcurrentQueue	access:public	signature:(size_t minCapacity, size_t maxExplicitProducers, size_t maxImplicitProducers)
ConcurrentQueue::ConcurrentQueue	concurrentqueue/concurrentqueue.h	/^	explicit ConcurrentQueue(size_t capacity = 6 * BLOCK_SIZE)$/;"	f	class:ConcurrentQueue	access:public	signature:(size_t capacity = 6 * BLOCK_SIZE)
ConcurrentQueue::EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD	concurrentqueue/concurrentqueue.h	/^	static const size_t EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD = static_cast<size_t>(Traits::EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD);$/;"	m	class:ConcurrentQueue	access:public
ConcurrentQueue::EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE	concurrentqueue/concurrentqueue.h	/^	static const std::uint32_t EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE = static_cast<std::uint32_t>(Traits::EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE);$/;"	m	class:ConcurrentQueue	access:public
ConcurrentQueue::EXPLICIT_INITIAL_INDEX_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t EXPLICIT_INITIAL_INDEX_SIZE = static_cast<size_t>(Traits::EXPLICIT_INITIAL_INDEX_SIZE);$/;"	m	class:ConcurrentQueue	access:public
ConcurrentQueue::ExplicitProducer	concurrentqueue/concurrentqueue.h	/^	struct ExplicitProducer : public ProducerBase$/;"	s	class:ConcurrentQueue	inherits:ProducerBase	access:private
ConcurrentQueue::ExplicitProducer::BlockIndexEntry	concurrentqueue/concurrentqueue.h	/^		struct BlockIndexEntry$/;"	s	struct:ConcurrentQueue::ExplicitProducer	access:private
ConcurrentQueue::ExplicitProducer::BlockIndexEntry::base	concurrentqueue/concurrentqueue.h	/^			index_t base;$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexEntry	access:public
ConcurrentQueue::ExplicitProducer::BlockIndexEntry::block	concurrentqueue/concurrentqueue.h	/^			Block* block;$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexEntry	access:public
ConcurrentQueue::ExplicitProducer::BlockIndexHeader	concurrentqueue/concurrentqueue.h	/^		struct BlockIndexHeader$/;"	s	struct:ConcurrentQueue::ExplicitProducer	access:private
ConcurrentQueue::ExplicitProducer::BlockIndexHeader::entries	concurrentqueue/concurrentqueue.h	/^			BlockIndexEntry* entries;$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexHeader	access:public
ConcurrentQueue::ExplicitProducer::BlockIndexHeader::front	concurrentqueue/concurrentqueue.h	/^			std::atomic<size_t> front;		\/\/ Current slot (not next, like pr_blockIndexFront)$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexHeader	access:public
ConcurrentQueue::ExplicitProducer::BlockIndexHeader::prev	concurrentqueue/concurrentqueue.h	/^			void* prev;$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexHeader	access:public
ConcurrentQueue::ExplicitProducer::BlockIndexHeader::size	concurrentqueue/concurrentqueue.h	/^			size_t size;$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexHeader	access:public
ConcurrentQueue::ExplicitProducer::ExplicitProducer	concurrentqueue/concurrentqueue.h	/^		explicit ExplicitProducer(ConcurrentQueue* parent) :$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:(ConcurrentQueue* parent)
ConcurrentQueue::ExplicitProducer::blockIndex	concurrentqueue/concurrentqueue.h	/^		std::atomic<BlockIndexHeader*> blockIndex;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
ConcurrentQueue::ExplicitProducer::dequeue	concurrentqueue/concurrentqueue.h	/^		bool dequeue(U& element)$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:(U& element)
ConcurrentQueue::ExplicitProducer::dequeue_bulk	concurrentqueue/concurrentqueue.h	/^		size_t dequeue_bulk(It& itemFirst, size_t max)$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:(It& itemFirst, size_t max)
ConcurrentQueue::ExplicitProducer::enqueue	concurrentqueue/concurrentqueue.h	/^		inline bool enqueue(U&& element)$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:(U&& element)
ConcurrentQueue::ExplicitProducer::enqueue_bulk	concurrentqueue/concurrentqueue.h	/^		bool enqueue_bulk(It itemFirst, size_t count)$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:(It itemFirst, size_t count)
ConcurrentQueue::ExplicitProducer::new_block_index	concurrentqueue/concurrentqueue.h	/^		bool new_block_index(size_t numberOfFilledSlotsToExpose)$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:private	signature:(size_t numberOfFilledSlotsToExpose)
ConcurrentQueue::ExplicitProducer::nextExplicitProducer	concurrentqueue/concurrentqueue.h	/^		ExplicitProducer* nextExplicitProducer;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:public
ConcurrentQueue::ExplicitProducer::pr_blockIndexEntries	concurrentqueue/concurrentqueue.h	/^		BlockIndexEntry* pr_blockIndexEntries;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
ConcurrentQueue::ExplicitProducer::pr_blockIndexFront	concurrentqueue/concurrentqueue.h	/^		size_t pr_blockIndexFront;		\/\/ Next slot (not current)$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
ConcurrentQueue::ExplicitProducer::pr_blockIndexRaw	concurrentqueue/concurrentqueue.h	/^		void* pr_blockIndexRaw;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
ConcurrentQueue::ExplicitProducer::pr_blockIndexSize	concurrentqueue/concurrentqueue.h	/^		size_t pr_blockIndexSize;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
ConcurrentQueue::ExplicitProducer::pr_blockIndexSlotsUsed	concurrentqueue/concurrentqueue.h	/^		size_t pr_blockIndexSlotsUsed;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
ConcurrentQueue::ExplicitProducer::~ExplicitProducer	concurrentqueue/concurrentqueue.h	/^		~ExplicitProducer()$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:()
ConcurrentQueue::FreeList	concurrentqueue/concurrentqueue.h	/^	struct FreeList$/;"	s	class:ConcurrentQueue	access:private
ConcurrentQueue::FreeList::FreeList	concurrentqueue/concurrentqueue.h	/^		FreeList() : freeListHead(nullptr) { }$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:()
ConcurrentQueue::FreeList::FreeList	concurrentqueue/concurrentqueue.h	/^		FreeList(FreeList&& other) : freeListHead(other.freeListHead.load(std::memory_order_relaxed)) { other.freeListHead.store(nullptr, std::memory_order_relaxed); }$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:(FreeList&& other)
ConcurrentQueue::FreeList::MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^		FreeList& operator=(FreeList const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	struct:ConcurrentQueue::FreeList	access:public
ConcurrentQueue::FreeList::MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^		FreeList(FreeList const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	struct:ConcurrentQueue::FreeList	access:public
ConcurrentQueue::FreeList::REFS_MASK	concurrentqueue/concurrentqueue.h	/^	static const std::uint32_t REFS_MASK = 0x7FFFFFFF;$/;"	m	struct:ConcurrentQueue::FreeList	access:private
ConcurrentQueue::FreeList::SHOULD_BE_ON_FREELIST	concurrentqueue/concurrentqueue.h	/^	static const std::uint32_t SHOULD_BE_ON_FREELIST = 0x80000000;$/;"	m	struct:ConcurrentQueue::FreeList	access:private
ConcurrentQueue::FreeList::add	concurrentqueue/concurrentqueue.h	/^		inline void add(N* node)$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:(N* node)
ConcurrentQueue::FreeList::add_knowing_refcount_is_zero	concurrentqueue/concurrentqueue.h	/^		inline void add_knowing_refcount_is_zero(N* node)$/;"	f	struct:ConcurrentQueue::FreeList	access:private	signature:(N* node)
ConcurrentQueue::FreeList::freeListHead	concurrentqueue/concurrentqueue.h	/^		std::atomic<N*> freeListHead;$/;"	m	struct:ConcurrentQueue::FreeList	access:private
ConcurrentQueue::FreeList::head_unsafe	concurrentqueue/concurrentqueue.h	/^		N* head_unsafe() const { return freeListHead.load(std::memory_order_relaxed); }$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:() const
ConcurrentQueue::FreeList::mutex	concurrentqueue/concurrentqueue.h	/^		debug::DebugMutex mutex;$/;"	m	struct:ConcurrentQueue::FreeList	access:private
ConcurrentQueue::FreeList::swap	concurrentqueue/concurrentqueue.h	/^		void swap(FreeList& other) { details::swap_relaxed(freeListHead, other.freeListHead); }$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:(FreeList& other)
ConcurrentQueue::FreeList::try_get	concurrentqueue/concurrentqueue.h	/^		inline N* try_get()$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:()
ConcurrentQueue::FreeListNode	concurrentqueue/concurrentqueue.h	/^	struct FreeListNode$/;"	s	class:ConcurrentQueue	access:private
ConcurrentQueue::FreeListNode::FreeListNode	concurrentqueue/concurrentqueue.h	/^		FreeListNode() : freeListRefs(0), freeListNext(nullptr) { }$/;"	f	struct:ConcurrentQueue::FreeListNode	access:public	signature:()
ConcurrentQueue::FreeListNode::freeListNext	concurrentqueue/concurrentqueue.h	/^		std::atomic<N*> freeListNext;$/;"	m	struct:ConcurrentQueue::FreeListNode	access:public
ConcurrentQueue::FreeListNode::freeListRefs	concurrentqueue/concurrentqueue.h	/^		std::atomic<std::uint32_t> freeListRefs;$/;"	m	struct:ConcurrentQueue::FreeListNode	access:public
ConcurrentQueue::IMPLICIT_INITIAL_INDEX_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t IMPLICIT_INITIAL_INDEX_SIZE = static_cast<size_t>(Traits::IMPLICIT_INITIAL_INDEX_SIZE);$/;"	m	class:ConcurrentQueue	access:public
ConcurrentQueue::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t INITIAL_IMPLICIT_PRODUCER_HASH_SIZE = static_cast<size_t>(Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE);$/;"	m	class:ConcurrentQueue	access:public
ConcurrentQueue::ImplicitProducer	concurrentqueue/concurrentqueue.h	/^	struct ImplicitProducer : public ProducerBase$/;"	s	class:ConcurrentQueue	inherits:ProducerBase	access:private
ConcurrentQueue::ImplicitProducer::ConsumerToken::ConsumerToken	concurrentqueue/concurrentqueue.h	/^ConsumerToken::ConsumerToken(BlockingConcurrentQueue<T, Traits>& queue)$/;"	f	class:ConcurrentQueue::ImplicitProducer::ConsumerToken	access:public	signature:(BlockingConcurrentQueue<T, Traits>& queue)
ConcurrentQueue::ImplicitProducer::ConsumerToken::ConsumerToken	concurrentqueue/concurrentqueue.h	/^ConsumerToken::ConsumerToken(ConcurrentQueue<T, Traits>& queue)$/;"	f	class:ConcurrentQueue::ImplicitProducer::ConsumerToken	access:public	signature:(ConcurrentQueue<T, Traits>& queue)
ConcurrentQueue::ImplicitProducer::ImplicitProducer	concurrentqueue/concurrentqueue.h	/^		ImplicitProducer(ConcurrentQueue* parent) :$/;"	f	struct:ConcurrentQueue::ImplicitProducer	access:public	signature:(ConcurrentQueue* parent)
ConcurrentQueue::ImplicitProducer::ProducerToken::ProducerToken	concurrentqueue/concurrentqueue.h	/^ProducerToken::ProducerToken(BlockingConcurrentQueue<T, Traits>& queue)$/;"	f	class:ConcurrentQueue::ImplicitProducer::ProducerToken	access:public	signature:(BlockingConcurrentQueue<T, Traits>& queue)
ConcurrentQueue::ImplicitProducer::ProducerToken::ProducerToken	concurrentqueue/concurrentqueue.h	/^ProducerToken::ProducerToken(ConcurrentQueue<T, Traits>& queue)$/;"	f	class:ConcurrentQueue::ImplicitProducer::ProducerToken	access:public	signature:(ConcurrentQueue<T, Traits>& queue)
ConcurrentQueue::ImplicitProducer::~ImplicitProducer	concurrentqueue/concurrentqueue.h	/^		~ImplicitProducer()$/;"	f	struct:ConcurrentQueue::ImplicitProducer	access:public	signature:()
ConcurrentQueue::InnerQueueContext	concurrentqueue/concurrentqueue.h	/^	enum InnerQueueContext { implicit_context = 0, explicit_context = 1 };$/;"	g	class:ConcurrentQueue	access:private
ConcurrentQueue::MAX_SUBQUEUE_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t MAX_SUBQUEUE_SIZE = (details::const_numeric_max<size_t>::value - static_cast<size_t>(Traits::MAX_SUBQUEUE_SIZE) < BLOCK_SIZE) ? details::const_numeric_max<size_t>::value : ((static_cast<size_t>(Traits::MAX_SUBQUEUE_SIZE) + (BLOCK_SIZE - 1)) \/ BLOCK_SIZE * BLOCK_SIZE);$/;"	m	class:ConcurrentQueue	access:public
ConcurrentQueue::MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ConcurrentQueue& operator=(ConcurrentQueue const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	class:ConcurrentQueue	access:public
ConcurrentQueue::MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ConcurrentQueue(ConcurrentQueue const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	class:ConcurrentQueue	access:public
ConcurrentQueue::ProducerBase	concurrentqueue/concurrentqueue.h	/^	struct ProducerBase : public details::ConcurrentQueueProducerTypelessBase$/;"	s	class:ConcurrentQueue	inherits:details::ConcurrentQueueProducerTypelessBase	access:private
ConcurrentQueue::ProducerBase::ProducerBase	concurrentqueue/concurrentqueue.h	/^		ProducerBase(ConcurrentQueue* parent, bool isExplicit) :$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:(ConcurrentQueue* parent, bool isExplicit)
ConcurrentQueue::ProducerBase::dequeue	concurrentqueue/concurrentqueue.h	/^		inline bool dequeue(U& element)$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:(U& element)
ConcurrentQueue::ProducerBase::dequeueOptimisticCount	concurrentqueue/concurrentqueue.h	/^		std::atomic<index_t> dequeueOptimisticCount;$/;"	m	struct:ConcurrentQueue::ProducerBase	access:protected
ConcurrentQueue::ProducerBase::dequeueOvercommit	concurrentqueue/concurrentqueue.h	/^		std::atomic<index_t> dequeueOvercommit;$/;"	m	struct:ConcurrentQueue::ProducerBase	access:protected
ConcurrentQueue::ProducerBase::dequeue_bulk	concurrentqueue/concurrentqueue.h	/^		inline size_t dequeue_bulk(It& itemFirst, size_t max)$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:(It& itemFirst, size_t max)
ConcurrentQueue::ProducerBase::getTail	concurrentqueue/concurrentqueue.h	/^		inline index_t getTail() const { return tailIndex.load(std::memory_order_relaxed); }$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:() const
ConcurrentQueue::ProducerBase::headIndex	concurrentqueue/concurrentqueue.h	/^		std::atomic<index_t> headIndex;		\/\/ Where to dequeue from next$/;"	m	struct:ConcurrentQueue::ProducerBase	access:protected
ConcurrentQueue::ProducerBase::isExplicit	concurrentqueue/concurrentqueue.h	/^		bool isExplicit;$/;"	m	struct:ConcurrentQueue::ProducerBase	access:public
ConcurrentQueue::ProducerBase::next_prod	concurrentqueue/concurrentqueue.h	/^		inline ProducerBase* next_prod() const { return static_cast<ProducerBase*>(next); }$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:() const
ConcurrentQueue::ProducerBase::parent	concurrentqueue/concurrentqueue.h	/^		ConcurrentQueue* parent;$/;"	m	struct:ConcurrentQueue::ProducerBase	access:public
ConcurrentQueue::ProducerBase::size_approx	concurrentqueue/concurrentqueue.h	/^		inline size_t size_approx() const$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:() const
ConcurrentQueue::ProducerBase::tailBlock	concurrentqueue/concurrentqueue.h	/^		Block* tailBlock;$/;"	m	struct:ConcurrentQueue::ProducerBase	access:protected
ConcurrentQueue::ProducerBase::tailIndex	concurrentqueue/concurrentqueue.h	/^		std::atomic<index_t> tailIndex;		\/\/ Where to enqueue to next$/;"	m	struct:ConcurrentQueue::ProducerBase	access:protected
ConcurrentQueue::ProducerBase::~ProducerBase	concurrentqueue/concurrentqueue.h	/^		virtual ~ProducerBase() { };$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:()
ConcurrentQueue::consumer_token_t	concurrentqueue/concurrentqueue.h	/^	typedef ::moodycamel::ConsumerToken consumer_token_t;$/;"	t	class:ConcurrentQueue	access:public
ConcurrentQueue::enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool enqueue(T const& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(T const& item)
ConcurrentQueue::enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool enqueue(T&& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(T&& item)
ConcurrentQueue::enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool enqueue(producer_token_t const& token, T const& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, T const& item)
ConcurrentQueue::enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool enqueue(producer_token_t const& token, T&& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, T&& item)
ConcurrentQueue::enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	bool enqueue_bulk(It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:public	signature:(It itemFirst, size_t count)
ConcurrentQueue::enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	bool enqueue_bulk(producer_token_t const& token, It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, It itemFirst, size_t count)
ConcurrentQueue::explicit_context	concurrentqueue/concurrentqueue.h	/^	enum InnerQueueContext { implicit_context = 0, explicit_context = 1 };$/;"	e	enum:ConcurrentQueue::InnerQueueContext
ConcurrentQueue::globalExplicitConsumerOffset	concurrentqueue/concurrentqueue.h	/^		globalExplicitConsumerOffset(other.globalExplicitConsumerOffset.load(std::memory_order_relaxed))$/;"	f	class:ConcurrentQueue	access:public	signature:(other.globalExplicitConsumerOffset.load(std::memory_order_relaxed))
ConcurrentQueue::implicit_context	concurrentqueue/concurrentqueue.h	/^	enum InnerQueueContext { implicit_context = 0, explicit_context = 1 };$/;"	e	enum:ConcurrentQueue::InnerQueueContext
ConcurrentQueue::index_t	concurrentqueue/concurrentqueue.h	/^	typedef typename Traits::index_t index_t;$/;"	t	class:ConcurrentQueue	access:public
ConcurrentQueue::initialBlockPool	concurrentqueue/concurrentqueue.h	/^		initialBlockPool(other.initialBlockPool),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.initialBlockPool)
ConcurrentQueue::initialBlockPoolIndex	concurrentqueue/concurrentqueue.h	/^		initialBlockPoolIndex(other.initialBlockPoolIndex.load(std::memory_order_relaxed)),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.initialBlockPoolIndex.load(std::memory_order_relaxed))
ConcurrentQueue::initialBlockPoolSize	concurrentqueue/concurrentqueue.h	/^		initialBlockPoolSize(other.initialBlockPoolSize),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.initialBlockPoolSize)
ConcurrentQueue::inner_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool inner_enqueue(U&& element)$/;"	f	class:ConcurrentQueue	access:private	signature:(U&& element)
ConcurrentQueue::inner_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool inner_enqueue(producer_token_t const& token, U&& element)$/;"	f	class:ConcurrentQueue	access:private	signature:(producer_token_t const& token, U&& element)
ConcurrentQueue::inner_enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	inline bool inner_enqueue_bulk(It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:private	signature:(It itemFirst, size_t count)
ConcurrentQueue::inner_enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	inline bool inner_enqueue_bulk(producer_token_t const& token, It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:private	signature:(producer_token_t const& token, It itemFirst, size_t count)
ConcurrentQueue::is_lock_free	concurrentqueue/concurrentqueue.h	/^	static bool is_lock_free()$/;"	f	class:ConcurrentQueue	access:public	signature:()
ConcurrentQueue::nextExplicitConsumerId	concurrentqueue/concurrentqueue.h	/^		nextExplicitConsumerId(other.nextExplicitConsumerId.load(std::memory_order_relaxed)),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.nextExplicitConsumerId.load(std::memory_order_relaxed))
ConcurrentQueue::producerCount	concurrentqueue/concurrentqueue.h	/^		producerCount(other.producerCount.load(std::memory_order_relaxed)),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.producerCount.load(std::memory_order_relaxed))
ConcurrentQueue::producerListTail	concurrentqueue/concurrentqueue.h	/^		: producerListTail(other.producerListTail.load(std::memory_order_relaxed)),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.producerListTail.load(std::memory_order_relaxed))
ConcurrentQueue::producer_token_t	concurrentqueue/concurrentqueue.h	/^	typedef ::moodycamel::ProducerToken producer_token_t;$/;"	t	class:ConcurrentQueue	access:public
ConcurrentQueue::size_approx	concurrentqueue/concurrentqueue.h	/^	size_t size_approx() const$/;"	f	class:ConcurrentQueue	access:public	signature:() const
ConcurrentQueue::size_t	concurrentqueue/concurrentqueue.h	/^	typedef typename Traits::size_t size_t;$/;"	t	class:ConcurrentQueue	access:public
ConcurrentQueue::sizeof	concurrentqueue/concurrentqueue.h	/^	static_assert(sizeof(index_t) >= sizeof(size_t), "Traits::index_t must be at least as wide as Traits::size_t");$/;"	p	class:ConcurrentQueue	access:public	signature:(index_t)
ConcurrentQueue::static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert((BLOCK_SIZE > 1) && !(BLOCK_SIZE & (BLOCK_SIZE - 1)), "Traits::BLOCK_SIZE must be a power of 2 (and at least 2)");$/;"	p	class:ConcurrentQueue	access:public	signature:(BLOCK_SIZE > 1) && !(BLOCK_SIZE & (BLOCK_SIZE - 1)), Ó
ConcurrentQueue::static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert((EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD > 1) && !(EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD & (EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD - 1)), "Traits::EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD must be a power of 2 (and greater than 1)");$/;"	p	class:ConcurrentQueue	access:public	signature:(EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD > 1) && !(EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD & (EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD - 1)), Ó
ConcurrentQueue::static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert((EXPLICIT_INITIAL_INDEX_SIZE > 1) && !(EXPLICIT_INITIAL_INDEX_SIZE & (EXPLICIT_INITIAL_INDEX_SIZE - 1)), "Traits::EXPLICIT_INITIAL_INDEX_SIZE must be a power of 2 (and greater than 1)");$/;"	p	class:ConcurrentQueue	access:public	signature:(EXPLICIT_INITIAL_INDEX_SIZE > 1) && !(EXPLICIT_INITIAL_INDEX_SIZE & (EXPLICIT_INITIAL_INDEX_SIZE - 1)), Ó
ConcurrentQueue::static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert((IMPLICIT_INITIAL_INDEX_SIZE > 1) && !(IMPLICIT_INITIAL_INDEX_SIZE & (IMPLICIT_INITIAL_INDEX_SIZE - 1)), "Traits::IMPLICIT_INITIAL_INDEX_SIZE must be a power of 2 (and greater than 1)");$/;"	p	class:ConcurrentQueue	access:public	signature:(IMPLICIT_INITIAL_INDEX_SIZE > 1) && !(IMPLICIT_INITIAL_INDEX_SIZE & (IMPLICIT_INITIAL_INDEX_SIZE - 1)), Ó
ConcurrentQueue::static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert((INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) || !(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE & (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE - 1)), "Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE must be a power of 2");$/;"	p	class:ConcurrentQueue	access:public	signature:(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) || !(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE & (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE - 1)), Ó
ConcurrentQueue::static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0 || INITIAL_IMPLICIT_PRODUCER_HASH_SIZE >= 1, "Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE must be at least 1 (or 0 to disable implicit enqueueing)");$/;"	p	class:ConcurrentQueue	access:public	signature:(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0 || INITIAL_IMPLICIT_PRODUCER_HASH_SIZE >= 1, Ó)
ConcurrentQueue::swap_internal	concurrentqueue/concurrentqueue.h	/^	ConcurrentQueue& swap_internal(ConcurrentQueue& other)$/;"	f	class:ConcurrentQueue	access:private	signature:(ConcurrentQueue& other)
ConcurrentQueue::try_dequeue	concurrentqueue/concurrentqueue.h	/^	bool try_dequeue(U& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(U& item)
ConcurrentQueue::try_dequeue	concurrentqueue/concurrentqueue.h	/^	bool try_dequeue(consumer_token_t& token, U& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(consumer_token_t& token, U& item)
ConcurrentQueue::try_dequeue_bulk	concurrentqueue/concurrentqueue.h	/^	size_t try_dequeue_bulk(It itemFirst, size_t max)$/;"	f	class:ConcurrentQueue	access:public	signature:(It itemFirst, size_t max)
ConcurrentQueue::try_dequeue_bulk	concurrentqueue/concurrentqueue.h	/^	size_t try_dequeue_bulk(consumer_token_t& token, It itemFirst, size_t max)$/;"	f	class:ConcurrentQueue	access:public	signature:(consumer_token_t& token, It itemFirst, size_t max)
ConcurrentQueue::try_dequeue_bulk_from_producer	concurrentqueue/concurrentqueue.h	/^	inline size_t try_dequeue_bulk_from_producer(producer_token_t const& producer, It itemFirst, size_t max)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& producer, It itemFirst, size_t max)
ConcurrentQueue::try_dequeue_from_producer	concurrentqueue/concurrentqueue.h	/^	inline bool try_dequeue_from_producer(producer_token_t const& producer, U& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& producer, U& item)
ConcurrentQueue::try_dequeue_non_interleaved	concurrentqueue/concurrentqueue.h	/^	bool try_dequeue_non_interleaved(U& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(U& item)
ConcurrentQueue::try_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool try_enqueue(T const& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(T const& item)
ConcurrentQueue::try_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool try_enqueue(T&& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(T&& item)
ConcurrentQueue::try_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool try_enqueue(producer_token_t const& token, T const& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, T const& item)
ConcurrentQueue::try_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool try_enqueue(producer_token_t const& token, T&& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, T&& item)
ConcurrentQueue::try_enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	bool try_enqueue_bulk(It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:public	signature:(It itemFirst, size_t count)
ConcurrentQueue::try_enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	bool try_enqueue_bulk(producer_token_t const& token, It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, It itemFirst, size_t count)
ConcurrentQueue::update_current_producer_after_rotation	concurrentqueue/concurrentqueue.h	/^	inline bool update_current_producer_after_rotation(consumer_token_t& token)$/;"	f	class:ConcurrentQueue	access:private	signature:(consumer_token_t& token)
ConcurrentQueue::~ConcurrentQueue	concurrentqueue/concurrentqueue.h	/^	~ConcurrentQueue()$/;"	f	class:ConcurrentQueue	access:public	signature:()
ConcurrentQueueDefaultTraits	concurrentqueue/concurrentqueue.h	/^struct ConcurrentQueueDefaultTraits$/;"	s	namespace:moodycamel
ConcurrentQueueProducerTypelessBase	concurrentqueue/concurrentqueue.h	/^		ConcurrentQueueProducerTypelessBase()$/;"	f	struct:moodycamel::details::ConcurrentQueueProducerTypelessBase	access:public	signature:()
ConcurrentQueueProducerTypelessBase	concurrentqueue/concurrentqueue.h	/^	struct ConcurrentQueueProducerTypelessBase$/;"	s	namespace:moodycamel::details
ConsumerToken	concurrentqueue/concurrentqueue.h	/^	explicit ConsumerToken(BlockingConcurrentQueue<T, Traits>& q);$/;"	p	struct:ConsumerToken	access:public	signature:(BlockingConcurrentQueue<T, Traits>& q)
ConsumerToken	concurrentqueue/concurrentqueue.h	/^	explicit ConsumerToken(ConcurrentQueue<T, Traits>& q);$/;"	p	struct:ConsumerToken	access:public	signature:(ConcurrentQueue<T, Traits>& q)
ConsumerToken	concurrentqueue/concurrentqueue.h	/^ConsumerToken::ConsumerToken(BlockingConcurrentQueue<T, Traits>& queue)$/;"	f	class:ConcurrentQueue::ImplicitProducer::ConsumerToken	access:public	signature:(BlockingConcurrentQueue<T, Traits>& queue)
ConsumerToken	concurrentqueue/concurrentqueue.h	/^ConsumerToken::ConsumerToken(ConcurrentQueue<T, Traits>& queue)$/;"	f	class:ConcurrentQueue::ImplicitProducer::ConsumerToken	access:public	signature:(ConcurrentQueue<T, Traits>& queue)
ConsumerToken	concurrentqueue/concurrentqueue.h	/^struct ConsumerToken$/;"	s
ConsumerToken::ConsumerToken	concurrentqueue/concurrentqueue.h	/^	explicit ConsumerToken(BlockingConcurrentQueue<T, Traits>& q);$/;"	p	struct:ConsumerToken	access:public	signature:(BlockingConcurrentQueue<T, Traits>& q)
ConsumerToken::ConsumerToken	concurrentqueue/concurrentqueue.h	/^	explicit ConsumerToken(ConcurrentQueue<T, Traits>& q);$/;"	p	struct:ConsumerToken	access:public	signature:(ConcurrentQueue<T, Traits>& q)
ConsumerToken::MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ConsumerToken& operator=(ConsumerToken const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	struct:ConsumerToken	access:public
ConsumerToken::MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ConsumerToken(ConsumerToken const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	struct:ConsumerToken	access:public
ConsumerToken::MOODYCAMEL_NOEXCEPT	concurrentqueue/concurrentqueue.h	/^	explicit ConsumerToken(ConsumerToken&& other) MOODYCAMEL_NOEXCEPT$/;"	m	struct:ConsumerToken	access:public
ConsumerToken::currentProducer	concurrentqueue/concurrentqueue.h	/^		: initialOffset(other.initialOffset), lastKnownGlobalOffset(other.lastKnownGlobalOffset), itemsConsumedFromCurrent(other.itemsConsumedFromCurrent), currentProducer(other.currentProducer), desiredProducer(other.desiredProducer)$/;"	p	struct:ConsumerToken	access:public	signature:(other.currentProducer)
ConsumerToken::currentProducer	concurrentqueue/concurrentqueue.h	/^	details::ConcurrentQueueProducerTypelessBase* currentProducer;$/;"	m	struct:ConsumerToken	access:private
ConsumerToken::desiredProducer	concurrentqueue/concurrentqueue.h	/^		: initialOffset(other.initialOffset), lastKnownGlobalOffset(other.lastKnownGlobalOffset), itemsConsumedFromCurrent(other.itemsConsumedFromCurrent), currentProducer(other.currentProducer), desiredProducer(other.desiredProducer)$/;"	f	struct:ConsumerToken	access:public	signature:(other.desiredProducer)
ConsumerToken::desiredProducer	concurrentqueue/concurrentqueue.h	/^	details::ConcurrentQueueProducerTypelessBase* desiredProducer;$/;"	m	struct:ConsumerToken	access:private
ConsumerToken::initialOffset	concurrentqueue/concurrentqueue.h	/^	std::uint32_t initialOffset;$/;"	m	struct:ConsumerToken	access:private
ConsumerToken::itemsConsumedFromCurrent	concurrentqueue/concurrentqueue.h	/^		: initialOffset(other.initialOffset), lastKnownGlobalOffset(other.lastKnownGlobalOffset), itemsConsumedFromCurrent(other.itemsConsumedFromCurrent), currentProducer(other.currentProducer), desiredProducer(other.desiredProducer)$/;"	p	struct:ConsumerToken	access:public	signature:(other.itemsConsumedFromCurrent)
ConsumerToken::itemsConsumedFromCurrent	concurrentqueue/concurrentqueue.h	/^	std::uint32_t itemsConsumedFromCurrent;$/;"	m	struct:ConsumerToken	access:private
ConsumerToken::lastKnownGlobalOffset	concurrentqueue/concurrentqueue.h	/^		: initialOffset(other.initialOffset), lastKnownGlobalOffset(other.lastKnownGlobalOffset), itemsConsumedFromCurrent(other.itemsConsumedFromCurrent), currentProducer(other.currentProducer), desiredProducer(other.desiredProducer)$/;"	p	struct:ConsumerToken	access:public	signature:(other.lastKnownGlobalOffset)
ConsumerToken::lastKnownGlobalOffset	concurrentqueue/concurrentqueue.h	/^	std::uint32_t lastKnownGlobalOffset;$/;"	m	struct:ConsumerToken	access:private
ContainerID	libusb/libusb.h	/^	uint8_t  ContainerID[16];$/;"	m	struct:libusb_container_id_descriptor	access:public
DEVICE_H	device/device.h	2;"	d
DOMAIN_H	device/domain.h	2;"	d
Domain	device/domain.h	/^	Domain() = default;$/;"	p	class:tamgef::device::Domain	access:public	signature:()
Domain	device/domain.h	/^	Domain(Domain<T> &&);$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> &&)
Domain	device/domain.h	/^	Domain(Domain<T> const&);$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> const&)
Domain	device/domain.h	/^	Domain(std::function<bool(T)>);$/;"	p	class:tamgef::device::Domain	access:public	signature:(std::function<bool(T)>)
Domain	device/domain.h	/^Domain<T>::Domain(Domain<T> && other) :$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> && other)
Domain	device/domain.h	/^Domain<T>::Domain(Domain<T> const& other) :$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> const& other)
Domain	device/domain.h	/^Domain<T>::Domain(std::function<bool(T)> predicate) :$/;"	f	class:tamgef::device::Domain	signature:(std::function<bool(T)> predicate)
Domain	device/domain.h	/^class Domain$/;"	c	namespace:tamgef::device
DuplicationPolicy	json/json.h	/^    enum DuplicationPolicy {$/;"	g	class:Json::Value::CZString	access:public
EVENT_H	device/event.h	2;"	d
EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD	concurrentqueue/concurrentqueue.h	/^	static const size_t EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD = 32;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD	concurrentqueue/concurrentqueue.h	/^	static const size_t EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD = static_cast<size_t>(Traits::EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD);$/;"	m	class:ConcurrentQueue	access:public
EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE	concurrentqueue/concurrentqueue.h	/^	static const std::uint32_t EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE = 256;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE	concurrentqueue/concurrentqueue.h	/^	static const std::uint32_t EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE = static_cast<std::uint32_t>(Traits::EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE);$/;"	m	class:ConcurrentQueue	access:public
EXPLICIT_INITIAL_INDEX_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t EXPLICIT_INITIAL_INDEX_SIZE = 32;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
EXPLICIT_INITIAL_INDEX_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t EXPLICIT_INITIAL_INDEX_SIZE = static_cast<size_t>(Traits::EXPLICIT_INITIAL_INDEX_SIZE);$/;"	m	class:ConcurrentQueue	access:public
ErrorInfo	json/json.h	/^  class ErrorInfo {$/;"	c	class:Json::Reader	access:private
Errors	json/json.h	/^  typedef std::deque<ErrorInfo> Errors;$/;"	t	class:Json::Reader	access:private
Event	device/event.h	/^	Event() = delete;$/;"	p	class:tamgef::device::Event	access:public	signature:()
Event	device/event.h	/^	Event(Event<T> &&);$/;"	p	class:tamgef::device::Event	access:public	signature:(Event<T> &&)
Event	device/event.h	/^	Event(Event<T> const&);$/;"	p	class:tamgef::device::Event	access:public	signature:(Event<T> const&)
Event	device/event.h	/^	Event(T const&);$/;"	p	class:tamgef::device::Event	access:public	signature:(T const&)
Event	device/event.h	/^Event<T>::Event(Event<T> && other) :$/;"	f	class:tamgef::device::Event	signature:(Event<T> && other)
Event	device/event.h	/^Event<T>::Event(Event<T> const& other) :$/;"	f	class:tamgef::device::Event	signature:(Event<T> const& other)
Event	device/event.h	/^Event<T>::Event(T const& type) :$/;"	f	class:tamgef::device::Event	signature:(T const& type)
Event	device/event.h	/^class Event$/;"	c	namespace:tamgef::device
EventFunction	device/device.h	/^	typedef std::function<Event<EventT>(StateT)> EventFunction;$/;"	t	class:tamgef::device::GenericDevice	access:public
EventList	device/device.h	/^	typedef std::vector<EventFunction> EventList;$/;"	t	class:tamgef::device::GenericDevice	access:public
Exception	json/json.h	/^  Exception(std::string const& msg);$/;"	p	class:Json::Exception	access:public	signature:(std::string const& msg)
Exception	json/json.h	/^class JSON_API Exception : public std::exception {$/;"	c	namespace:Json	inherits:std::exception
ExplicitProducer	concurrentqueue/concurrentqueue.h	/^		explicit ExplicitProducer(ConcurrentQueue* parent) :$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:(ConcurrentQueue* parent)
ExplicitProducer	concurrentqueue/concurrentqueue.h	/^	struct ExplicitProducer : public ProducerBase$/;"	s	class:ConcurrentQueue	inherits:ProducerBase	access:private
Factory	json/json.h	/^  class Factory {$/;"	c	class:Json::CharReader	access:public
Factory	json/json.h	/^  class JSON_API Factory {$/;"	c	class:Json::StreamWriter	access:public
FastWriter	json/json.h	/^  FastWriter();$/;"	p	class:Json::FastWriter	access:public	signature:()
FastWriter	json/json.h	/^class JSON_API FastWriter : public Writer {$/;"	c	namespace:Json	inherits:Writer
Features	json/json.h	/^  Features();$/;"	p	class:Json::Features	access:public	signature:()
Features	json/json.h	/^class JSON_API Features {$/;"	c	namespace:Json
FreeList	concurrentqueue/concurrentqueue.h	/^		FreeList() : freeListHead(nullptr) { }$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:()
FreeList	concurrentqueue/concurrentqueue.h	/^		FreeList(FreeList&& other) : freeListHead(other.freeListHead.load(std::memory_order_relaxed)) { other.freeListHead.store(nullptr, std::memory_order_relaxed); }$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:(FreeList&& other)
FreeList	concurrentqueue/concurrentqueue.h	/^	struct FreeList$/;"	s	class:ConcurrentQueue	access:private
FreeListNode	concurrentqueue/concurrentqueue.h	/^		FreeListNode() : freeListRefs(0), freeListNext(nullptr) { }$/;"	f	struct:ConcurrentQueue::FreeListNode	access:public	signature:()
FreeListNode	concurrentqueue/concurrentqueue.h	/^	struct FreeListNode$/;"	s	class:ConcurrentQueue	access:private
GenericDevice	device/device.h	/^	GenericDevice($/;"	p	class:tamgef::device::GenericDevice	access:public	signature:( GenericDevice<InputT, OutputT, StateT, EventT> const&)
GenericDevice	device/device.h	/^	GenericDevice($/;"	p	class:tamgef::device::GenericDevice	access:public	signature:( InputDomain, OutputDomain, ResolutionFunction, StateFunction, std::initializer_list<EventFunction> )
GenericDevice	device/device.h	/^	GenericDevice();$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:()
GenericDevice	device/device.h	/^	GenericDevice(GenericDevice<InputT, OutputT, StateT, EventT> &&);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(GenericDevice<InputT, OutputT, StateT, EventT> &&)
GenericDevice	device/device.h	/^GenericDevice($/;"	f	class:tamgef::device::GenericDevice	signature:( InputDomain inputDomain, OutputDomain outputDomain, ResolutionFunction resolutionFunction, StateFunction stateFunction, std::initializer_list<EventFunction> eventList)
GenericDevice	device/device.h	/^GenericDevice() :$/;"	f	class:tamgef::device::GenericDevice	signature:()
GenericDevice	device/device.h	/^GenericDevice(GenericDevice<InputT, OutputT, StateT, EventT> && other) :$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<InputT, OutputT, StateT, EventT> && other)
GenericDevice	device/device.h	/^GenericDevice(GenericDevice<InputT, OutputT, StateT, EventT> const& other) :$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<InputT, OutputT, StateT, EventT> const& other)
GenericDevice	device/device.h	/^class GenericDevice$/;"	c	namespace:tamgef::device
GetCurrentThreadId	concurrentqueue/concurrentqueue.h	/^extern "C" __declspec(dllimport) unsigned long __stdcall GetCurrentThreadId(void);$/;"	p	signature:(void)
IMPLICIT_INITIAL_INDEX_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t IMPLICIT_INITIAL_INDEX_SIZE = 32;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
IMPLICIT_INITIAL_INDEX_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t IMPLICIT_INITIAL_INDEX_SIZE = static_cast<size_t>(Traits::IMPLICIT_INITIAL_INDEX_SIZE);$/;"	m	class:ConcurrentQueue	access:public
INITIAL_IMPLICIT_PRODUCER_HASH_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t INITIAL_IMPLICIT_PRODUCER_HASH_SIZE = 32;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
INITIAL_IMPLICIT_PRODUCER_HASH_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t INITIAL_IMPLICIT_PRODUCER_HASH_SIZE = static_cast<size_t>(Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE);$/;"	m	class:ConcurrentQueue	access:public
IOBSERVABLE_H	observer/iobservable.h	6;"	d
IOBSERVER_H	observer/iobserver.h	6;"	d
IObservable	observer/iobservable.h	/^template<typename T> class IObservable$/;"	c	namespace:tamgef::observer
IObserver	observer/iobserver.h	/^class IObserver$/;"	c	namespace:tamgef::observer
IQUEUE_H	queue/iqueue.h	3;"	d
IQueue	queue/iqueue.h	/^class IQueue$/;"	c	namespace:tamgef::queue
ImplicitProducer	concurrentqueue/concurrentqueue.h	/^		ImplicitProducer(ConcurrentQueue* parent) :$/;"	f	struct:ConcurrentQueue::ImplicitProducer	access:public	signature:(ConcurrentQueue* parent)
ImplicitProducer	concurrentqueue/concurrentqueue.h	/^	struct ImplicitProducer : public ProducerBase$/;"	s	class:ConcurrentQueue	inherits:ProducerBase	access:private
InArgs	json/json.h	/^  typedef std::vector<const PathArgument*> InArgs;$/;"	t	class:Json::Path	access:private
InnerQueueContext	concurrentqueue/concurrentqueue.h	/^	enum InnerQueueContext { implicit_context = 0, explicit_context = 1 };$/;"	g	class:ConcurrentQueue	access:private
InputDomain	device/device.h	/^	typedef std::function<bool(InputT)> InputDomain;$/;"	t	class:tamgef::device::GenericDevice	access:public
Int	json/json-forwards.h	/^typedef int Int;$/;"	t	namespace:Json
Int	json/json.h	/^  typedef Json::Int Int;$/;"	t	class:Json::Value	access:public
Int	json/json.h	/^typedef int Int;$/;"	t	namespace:Json
Int64	json/json-forwards.h	/^typedef __int64 Int64;$/;"	t	namespace:Json
Int64	json/json-forwards.h	/^typedef long long int Int64;$/;"	t	namespace:Json
Int64	json/json.h	/^  typedef Json::Int64 Int64;$/;"	t	class:Json::Value	access:public
Int64	json/json.h	/^typedef __int64 Int64;$/;"	t	namespace:Json
Int64	json/json.h	/^typedef long long int Int64;$/;"	t	namespace:Json
JSONCPP_DEPRECATED	json/json-forwards.h	157;"	d
JSONCPP_DEPRECATED	json/json-forwards.h	160;"	d
JSONCPP_DEPRECATED	json/json-forwards.h	163;"	d
JSONCPP_DEPRECATED	json/json-forwards.h	165;"	d
JSONCPP_DEPRECATED	json/json-forwards.h	169;"	d
JSONCPP_DEPRECATED	json/json.h	183;"	d
JSONCPP_DEPRECATED	json/json.h	186;"	d
JSONCPP_DEPRECATED	json/json.h	189;"	d
JSONCPP_DEPRECATED	json/json.h	191;"	d
JSONCPP_DEPRECATED	json/json.h	195;"	d
JSONCPP_DISABLE_DLL_INTERFACE_WARNING	json/json-forwards.h	127;"	d
JSONCPP_DISABLE_DLL_INTERFACE_WARNING	json/json-forwards.h	132;"	d
JSONCPP_DISABLE_DLL_INTERFACE_WARNING	json/json.h	153;"	d
JSONCPP_DISABLE_DLL_INTERFACE_WARNING	json/json.h	158;"	d
JSONCPP_VERSION_HEXA	json/json.h	95;"	d
JSONCPP_VERSION_MAJOR	json/json.h	91;"	d
JSONCPP_VERSION_MINOR	json/json.h	92;"	d
JSONCPP_VERSION_PATCH	json/json.h	93;"	d
JSONCPP_VERSION_QUALIFIER	json/json.h	94;"	d
JSONCPP_VERSION_STRING	json/json.h	90;"	d
JSON_AMALGATED_H_INCLUDED	json/json.h	76;"	d
JSON_API	json/json-forwards.h	123;"	d
JSON_API	json/json-forwards.h	126;"	d
JSON_API	json/json-forwards.h	131;"	d
JSON_API	json/json-forwards.h	136;"	d
JSON_API	json/json.h	149;"	d
JSON_API	json/json.h	152;"	d
JSON_API	json/json.h	157;"	d
JSON_API	json/json.h	162;"	d
JSON_ASSERT	json/json.h	1990;"	d
JSON_ASSERT_MESSAGE	json/json.h	2016;"	d
JSON_CONFIG_H_INCLUDED	json/json-forwards.h	92;"	d
JSON_CONFIG_H_INCLUDED	json/json.h	118;"	d
JSON_FAIL_MESSAGE	json/json.h	1993;"	d
JSON_FORWARDS_H_INCLUDED	json/json-forwards.h	215;"	d
JSON_FORWARDS_H_INCLUDED	json/json.h	241;"	d
JSON_FORWARD_AMALGATED_H_INCLUDED	json/json-forwards.h	77;"	d
JSON_HAS_INT64	json/json-forwards.h	178;"	d
JSON_HAS_INT64	json/json-forwards.h	190;"	d
JSON_HAS_INT64	json/json.h	204;"	d
JSON_HAS_INT64	json/json.h	216;"	d
JSON_IS_AMALGAMATION	json/json-forwards.h	80;"	d
JSON_IS_AMALGAMATION	json/json.h	79;"	d
JSON_USE_CPPTL	json/json-forwards.h	118;"	d
JSON_USE_CPPTL	json/json.h	144;"	d
JSON_USE_EXCEPTION	json/json-forwards.h	107;"	d
JSON_USE_EXCEPTION	json/json.h	133;"	d
JSON_USE_INT64_DOUBLE_CONVERSION	json/json-forwards.h	147;"	d
JSON_USE_INT64_DOUBLE_CONVERSION	json/json.h	173;"	d
JSON_VERSION_H_INCLUDED	json/json.h	88;"	d
JSON_WRITER_H_INCLUDED	json/json.h	1633;"	d
Json	json/json-forwards.h	/^namespace Json {$/;"	n
Json	json/json.h	/^namespace Json {$/;"	n
Json::ArrayIndex	json/json-forwards.h	/^typedef unsigned int ArrayIndex;$/;"	t	namespace:Json
Json::ArrayIndex	json/json.h	/^typedef unsigned int ArrayIndex;$/;"	t	namespace:Json
Json::CharReader	json/json.h	/^class JSON_API CharReader {$/;"	c	namespace:Json
Json::CharReader::Factory	json/json.h	/^  class Factory {$/;"	c	class:Json::CharReader	access:public
Json::CharReader::Factory::newCharReader	json/json.h	/^    virtual CharReader* newCharReader() const = 0;$/;"	p	class:Json::CharReader::Factory	access:public	signature:() const
Json::CharReader::Factory::~Factory	json/json.h	/^    virtual ~Factory() {}$/;"	f	class:Json::CharReader::Factory	access:public	signature:()
Json::CharReader::parse	json/json.h	/^  virtual bool parse($/;"	p	class:Json::CharReader	access:public	signature:( char const* beginDoc, char const* endDoc, Value* root, std::string* errs)
Json::CharReader::~CharReader	json/json.h	/^  virtual ~CharReader() {}$/;"	f	class:Json::CharReader	access:public	signature:()
Json::CharReaderBuilder	json/json.h	/^class JSON_API CharReaderBuilder : public CharReader::Factory {$/;"	c	namespace:Json	inherits:CharReader::Factory
Json::CharReaderBuilder::CharReaderBuilder	json/json.h	/^  CharReaderBuilder();$/;"	p	class:Json::CharReaderBuilder	access:public	signature:()
Json::CharReaderBuilder::newCharReader	json/json.h	/^  virtual CharReader* newCharReader() const;$/;"	p	class:Json::CharReaderBuilder	access:public	signature:() const
Json::CharReaderBuilder::operator []	json/json.h	/^  Value& operator[](std::string key);$/;"	p	class:Json::CharReaderBuilder	access:public	signature:(std::string key)
Json::CharReaderBuilder::setDefaults	json/json.h	/^  static void setDefaults(Json::Value* settings);$/;"	p	class:Json::CharReaderBuilder	access:public	signature:(Json::Value* settings)
Json::CharReaderBuilder::settings_	json/json.h	/^  Json::Value settings_;$/;"	m	class:Json::CharReaderBuilder	access:public
Json::CharReaderBuilder::strictMode	json/json.h	/^  static void strictMode(Json::Value* settings);$/;"	p	class:Json::CharReaderBuilder	access:public	signature:(Json::Value* settings)
Json::CharReaderBuilder::validate	json/json.h	/^  bool validate(Json::Value* invalid) const;$/;"	p	class:Json::CharReaderBuilder	access:public	signature:(Json::Value* invalid) const
Json::CharReaderBuilder::~CharReaderBuilder	json/json.h	/^  virtual ~CharReaderBuilder();$/;"	p	class:Json::CharReaderBuilder	access:public	signature:()
Json::CommentPlacement	json/json.h	/^enum CommentPlacement {$/;"	g	namespace:Json
Json::Exception	json/json.h	/^class JSON_API Exception : public std::exception {$/;"	c	namespace:Json	inherits:std::exception
Json::Exception::Exception	json/json.h	/^  Exception(std::string const& msg);$/;"	p	class:Json::Exception	access:public	signature:(std::string const& msg)
Json::Exception::std::msg_	json/json.h	/^  std::string const msg_;$/;"	m	class:Json::Exception::std	access:protected
Json::Exception::what	json/json.h	/^  virtual char const* what() const throw();$/;"	p	class:Json::Exception	access:public	signature:() const
Json::Exception::~Exception	json/json.h	/^  virtual ~Exception() throw();$/;"	p	class:Json::Exception	access:public	signature:()
Json::FastWriter	json/json.h	/^class JSON_API FastWriter : public Writer {$/;"	c	namespace:Json	inherits:Writer
Json::FastWriter::FastWriter	json/json.h	/^  FastWriter();$/;"	p	class:Json::FastWriter	access:public	signature:()
Json::FastWriter::document_	json/json.h	/^  std::string document_;$/;"	m	class:Json::FastWriter	access:private
Json::FastWriter::dropNullPlaceholders	json/json.h	/^  void dropNullPlaceholders();$/;"	p	class:Json::FastWriter	access:public	signature:()
Json::FastWriter::dropNullPlaceholders_	json/json.h	/^  bool dropNullPlaceholders_;$/;"	m	class:Json::FastWriter	access:private
Json::FastWriter::enableYAMLCompatibility	json/json.h	/^  void enableYAMLCompatibility();$/;"	p	class:Json::FastWriter	access:public	signature:()
Json::FastWriter::omitEndingLineFeed	json/json.h	/^  void omitEndingLineFeed();$/;"	p	class:Json::FastWriter	access:public	signature:()
Json::FastWriter::omitEndingLineFeed_	json/json.h	/^  bool omitEndingLineFeed_;$/;"	m	class:Json::FastWriter	access:private
Json::FastWriter::write	json/json.h	/^  virtual std::string write(const Value& root);$/;"	p	class:Json::FastWriter	access:public	signature:(const Value& root)
Json::FastWriter::writeValue	json/json.h	/^  void writeValue(const Value& value);$/;"	p	class:Json::FastWriter	access:private	signature:(const Value& value)
Json::FastWriter::yamlCompatiblityEnabled_	json/json.h	/^  bool yamlCompatiblityEnabled_;$/;"	m	class:Json::FastWriter	access:private
Json::FastWriter::~FastWriter	json/json.h	/^  virtual ~FastWriter() {}$/;"	f	class:Json::FastWriter	access:public	signature:()
Json::Features	json/json.h	/^class JSON_API Features {$/;"	c	namespace:Json
Json::Features::Features	json/json.h	/^  Features();$/;"	p	class:Json::Features	access:public	signature:()
Json::Features::all	json/json.h	/^  static Features all();$/;"	p	class:Json::Features	access:public	signature:()
Json::Features::allowComments_	json/json.h	/^  bool allowComments_;$/;"	m	class:Json::Features	access:public
Json::Features::allowDroppedNullPlaceholders_	json/json.h	/^  bool allowDroppedNullPlaceholders_;$/;"	m	class:Json::Features	access:public
Json::Features::allowNumericKeys_	json/json.h	/^  bool allowNumericKeys_;$/;"	m	class:Json::Features	access:public
Json::Features::strictMode	json/json.h	/^  static Features strictMode();$/;"	p	class:Json::Features	access:public	signature:()
Json::Features::strictRoot_	json/json.h	/^  bool strictRoot_;$/;"	m	class:Json::Features	access:public
Json::Int	json/json-forwards.h	/^typedef int Int;$/;"	t	namespace:Json
Json::Int	json/json.h	/^typedef int Int;$/;"	t	namespace:Json
Json::Int64	json/json-forwards.h	/^typedef __int64 Int64;$/;"	t	namespace:Json
Json::Int64	json/json-forwards.h	/^typedef long long int Int64;$/;"	t	namespace:Json
Json::Int64	json/json.h	/^typedef __int64 Int64;$/;"	t	namespace:Json
Json::Int64	json/json.h	/^typedef long long int Int64;$/;"	t	namespace:Json
Json::LargestInt	json/json-forwards.h	/^typedef Int64 LargestInt;$/;"	t	namespace:Json
Json::LargestInt	json/json-forwards.h	/^typedef int LargestInt;$/;"	t	namespace:Json
Json::LargestInt	json/json.h	/^typedef Int64 LargestInt;$/;"	t	namespace:Json
Json::LargestInt	json/json.h	/^typedef int LargestInt;$/;"	t	namespace:Json
Json::LargestUInt	json/json-forwards.h	/^typedef UInt64 LargestUInt;$/;"	t	namespace:Json
Json::LargestUInt	json/json-forwards.h	/^typedef unsigned int LargestUInt;$/;"	t	namespace:Json
Json::LargestUInt	json/json.h	/^typedef UInt64 LargestUInt;$/;"	t	namespace:Json
Json::LargestUInt	json/json.h	/^typedef unsigned int LargestUInt;$/;"	t	namespace:Json
Json::LogicError	json/json.h	/^class JSON_API LogicError : public Exception {$/;"	c	namespace:Json	inherits:Exception
Json::LogicError::LogicError	json/json.h	/^  LogicError(std::string const& msg);$/;"	p	class:Json::LogicError	access:public	signature:(std::string const& msg)
Json::Path	json/json.h	/^class JSON_API Path {$/;"	c	namespace:Json
Json::Path::Args	json/json.h	/^  typedef std::vector<PathArgument> Args;$/;"	t	class:Json::Path	access:private
Json::Path::InArgs	json/json.h	/^  typedef std::vector<const PathArgument*> InArgs;$/;"	t	class:Json::Path	access:private
Json::Path::Path	json/json.h	/^  Path(const std::string& path,$/;"	p	class:Json::Path	access:public	signature:(const std::string& path, const PathArgument& a1 = PathArgument(), const PathArgument& a2 = PathArgument(), const PathArgument& a3 = PathArgument(), const PathArgument& a4 = PathArgument(), const PathArgument& a5 = PathArgument())
Json::Path::addPathInArg	json/json.h	/^  void addPathInArg(const std::string& path,$/;"	p	class:Json::Path	access:private	signature:(const std::string& path, const InArgs& in, InArgs::const_iterator& itInArg, PathArgument::Kind kind)
Json::Path::args_	json/json.h	/^  Args args_;$/;"	m	class:Json::Path	access:private
Json::Path::invalidPath	json/json.h	/^  void invalidPath(const std::string& path, int location);$/;"	p	class:Json::Path	access:private	signature:(const std::string& path, int location)
Json::Path::make	json/json.h	/^  Value& make(Value& root) const;$/;"	p	class:Json::Path	access:public	signature:(Value& root) const
Json::Path::makePath	json/json.h	/^  void makePath(const std::string& path, const InArgs& in);$/;"	p	class:Json::Path	access:private	signature:(const std::string& path, const InArgs& in)
Json::Path::resolve	json/json.h	/^  Value resolve(const Value& root, const Value& defaultValue) const;$/;"	p	class:Json::Path	access:public	signature:(const Value& root, const Value& defaultValue) const
Json::Path::resolve	json/json.h	/^  const Value& resolve(const Value& root) const;$/;"	p	class:Json::Path	access:public	signature:(const Value& root) const
Json::PathArgument	json/json.h	/^class JSON_API PathArgument {$/;"	c	namespace:Json
Json::PathArgument::Kind	json/json.h	/^  enum Kind {$/;"	g	class:Json::PathArgument	access:private
Json::PathArgument::PathArgument	json/json.h	/^  PathArgument();$/;"	p	class:Json::PathArgument	access:public	signature:()
Json::PathArgument::PathArgument	json/json.h	/^  PathArgument(ArrayIndex index);$/;"	p	class:Json::PathArgument	access:public	signature:(ArrayIndex index)
Json::PathArgument::PathArgument	json/json.h	/^  PathArgument(const char* key);$/;"	p	class:Json::PathArgument	access:public	signature:(const char* key)
Json::PathArgument::PathArgument	json/json.h	/^  PathArgument(const std::string& key);$/;"	p	class:Json::PathArgument	access:public	signature:(const std::string& key)
Json::PathArgument::index_	json/json.h	/^  ArrayIndex index_;$/;"	m	class:Json::PathArgument	access:private
Json::PathArgument::key_	json/json.h	/^  std::string key_;$/;"	m	class:Json::PathArgument	access:private
Json::PathArgument::kindIndex	json/json.h	/^    kindIndex,$/;"	e	enum:Json::PathArgument::Kind
Json::PathArgument::kindKey	json/json.h	/^    kindKey$/;"	e	enum:Json::PathArgument::Kind
Json::PathArgument::kindNone	json/json.h	/^    kindNone = 0,$/;"	e	enum:Json::PathArgument::Kind
Json::PathArgument::kind_	json/json.h	/^  Kind kind_;$/;"	m	class:Json::PathArgument	access:private
Json::Reader	json/json.h	/^class JSON_API Reader {$/;"	c	namespace:Json
Json::Reader::Char	json/json.h	/^  typedef char Char;$/;"	t	class:Json::Reader	access:public
Json::Reader::ErrorInfo	json/json.h	/^  class ErrorInfo {$/;"	c	class:Json::Reader	access:private
Json::Reader::ErrorInfo::extra_	json/json.h	/^    Location extra_;$/;"	m	class:Json::Reader::ErrorInfo	access:public
Json::Reader::ErrorInfo::message_	json/json.h	/^    std::string message_;$/;"	m	class:Json::Reader::ErrorInfo	access:public
Json::Reader::ErrorInfo::token_	json/json.h	/^    Token token_;$/;"	m	class:Json::Reader::ErrorInfo	access:public
Json::Reader::Errors	json/json.h	/^  typedef std::deque<ErrorInfo> Errors;$/;"	t	class:Json::Reader	access:private
Json::Reader::Location	json/json.h	/^  typedef const Char* Location;$/;"	t	class:Json::Reader	access:public
Json::Reader::Nodes	json/json.h	/^  typedef std::stack<Value*> Nodes;$/;"	t	class:Json::Reader	access:private
Json::Reader::Reader	json/json.h	/^  Reader();$/;"	p	class:Json::Reader	access:public	signature:()
Json::Reader::Reader	json/json.h	/^  Reader(const Features& features);$/;"	p	class:Json::Reader	access:public	signature:(const Features& features)
Json::Reader::StructuredError	json/json.h	/^  struct StructuredError {$/;"	s	class:Json::Reader	access:public
Json::Reader::StructuredError::message	json/json.h	/^    std::string message;$/;"	m	struct:Json::Reader::StructuredError	access:public
Json::Reader::StructuredError::offset_limit	json/json.h	/^    size_t offset_limit;$/;"	m	struct:Json::Reader::StructuredError	access:public
Json::Reader::StructuredError::offset_start	json/json.h	/^    size_t offset_start;$/;"	m	struct:Json::Reader::StructuredError	access:public
Json::Reader::Token	json/json.h	/^  class Token {$/;"	c	class:Json::Reader	access:private
Json::Reader::Token::end_	json/json.h	/^    Location end_;$/;"	m	class:Json::Reader::Token	access:public
Json::Reader::Token::start_	json/json.h	/^    Location start_;$/;"	m	class:Json::Reader::Token	access:public
Json::Reader::Token::type_	json/json.h	/^    TokenType type_;$/;"	m	class:Json::Reader::Token	access:public
Json::Reader::TokenType	json/json.h	/^  enum TokenType {$/;"	g	class:Json::Reader	access:private
Json::Reader::addComment	json/json.h	/^  void addComment(Location begin, Location end, CommentPlacement placement);$/;"	p	class:Json::Reader	access:private	signature:(Location begin, Location end, CommentPlacement placement)
Json::Reader::addError	json/json.h	/^  bool addError(const std::string& message, Token& token, Location extra = 0);$/;"	p	class:Json::Reader	access:private	signature:(const std::string& message, Token& token, Location extra = 0)
Json::Reader::addErrorAndRecover	json/json.h	/^  bool addErrorAndRecover(const std::string& message,$/;"	p	class:Json::Reader	access:private	signature:(const std::string& message, Token& token, TokenType skipUntilToken)
Json::Reader::begin_	json/json.h	/^  Location begin_;$/;"	m	class:Json::Reader	access:private
Json::Reader::collectComments_	json/json.h	/^  bool collectComments_;$/;"	m	class:Json::Reader	access:private
Json::Reader::commentsBefore_	json/json.h	/^  std::string commentsBefore_;$/;"	m	class:Json::Reader	access:private
Json::Reader::currentValue	json/json.h	/^  Value& currentValue();$/;"	p	class:Json::Reader	access:private	signature:()
Json::Reader::current_	json/json.h	/^  Location current_;$/;"	m	class:Json::Reader	access:private
Json::Reader::decodeDouble	json/json.h	/^  bool decodeDouble(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
Json::Reader::decodeDouble	json/json.h	/^  bool decodeDouble(Token& token, Value& decoded);$/;"	p	class:Json::Reader	access:private	signature:(Token& token, Value& decoded)
Json::Reader::decodeNumber	json/json.h	/^  bool decodeNumber(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
Json::Reader::decodeNumber	json/json.h	/^  bool decodeNumber(Token& token, Value& decoded);$/;"	p	class:Json::Reader	access:private	signature:(Token& token, Value& decoded)
Json::Reader::decodeString	json/json.h	/^  bool decodeString(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
Json::Reader::decodeString	json/json.h	/^  bool decodeString(Token& token, std::string& decoded);$/;"	p	class:Json::Reader	access:private	signature:(Token& token, std::string& decoded)
Json::Reader::decodeUnicodeCodePoint	json/json.h	/^  bool decodeUnicodeCodePoint(Token& token,$/;"	p	class:Json::Reader	access:private	signature:(Token& token, Location& current, Location end, unsigned int& unicode)
Json::Reader::decodeUnicodeEscapeSequence	json/json.h	/^  bool decodeUnicodeEscapeSequence(Token& token,$/;"	p	class:Json::Reader	access:private	signature:(Token& token, Location& current, Location end, unsigned int& unicode)
Json::Reader::document_	json/json.h	/^  std::string document_;$/;"	m	class:Json::Reader	access:private
Json::Reader::end_	json/json.h	/^  Location end_;$/;"	m	class:Json::Reader	access:private
Json::Reader::errors_	json/json.h	/^  Errors errors_;$/;"	m	class:Json::Reader	access:private
Json::Reader::features_	json/json.h	/^  Features features_;$/;"	m	class:Json::Reader	access:private
Json::Reader::getFormatedErrorMessages	json/json.h	/^  std::string getFormatedErrorMessages() const;$/;"	p	class:Json::Reader	access:public	signature:() const
Json::Reader::getFormattedErrorMessages	json/json.h	/^  std::string getFormattedErrorMessages() const;$/;"	p	class:Json::Reader	access:public	signature:() const
Json::Reader::getLocationLineAndColumn	json/json.h	/^  getLocationLineAndColumn(Location location, int& line, int& column) const;$/;"	p	class:Json::Reader	access:private	signature:(Location location, int& line, int& column) const
Json::Reader::getLocationLineAndColumn	json/json.h	/^  std::string getLocationLineAndColumn(Location location) const;$/;"	p	class:Json::Reader	access:private	signature:(Location location) const
Json::Reader::getNextChar	json/json.h	/^  Char getNextChar();$/;"	p	class:Json::Reader	access:private	signature:()
Json::Reader::getStructuredErrors	json/json.h	/^  std::vector<StructuredError> getStructuredErrors() const;$/;"	p	class:Json::Reader	access:public	signature:() const
Json::Reader::good	json/json.h	/^  bool good() const;$/;"	p	class:Json::Reader	access:public	signature:() const
Json::Reader::lastValueEnd_	json/json.h	/^  Location lastValueEnd_;$/;"	m	class:Json::Reader	access:private
Json::Reader::lastValue_	json/json.h	/^  Value* lastValue_;$/;"	m	class:Json::Reader	access:private
Json::Reader::match	json/json.h	/^  bool match(Location pattern, int patternLength);$/;"	p	class:Json::Reader	access:private	signature:(Location pattern, int patternLength)
Json::Reader::nodes_	json/json.h	/^  Nodes nodes_;$/;"	m	class:Json::Reader	access:private
Json::Reader::parse	json/json.h	/^  bool parse(const char* beginDoc,$/;"	p	class:Json::Reader	access:public	signature:(const char* beginDoc, const char* endDoc, Value& root, bool collectComments = true)
Json::Reader::parse	json/json.h	/^  bool parse(std::istream& is, Value& root, bool collectComments = true);$/;"	p	class:Json::Reader	access:public	signature:(std::istream& is, Value& root, bool collectComments = true)
Json::Reader::parse	json/json.h	/^  parse(const std::string& document, Value& root, bool collectComments = true);$/;"	p	class:Json::Reader	access:public	signature:(const std::string& document, Value& root, bool collectComments = true)
Json::Reader::pushError	json/json.h	/^  bool pushError(const Value& value, const std::string& message);$/;"	p	class:Json::Reader	access:public	signature:(const Value& value, const std::string& message)
Json::Reader::pushError	json/json.h	/^  bool pushError(const Value& value, const std::string& message, const Value& extra);$/;"	p	class:Json::Reader	access:public	signature:(const Value& value, const std::string& message, const Value& extra)
Json::Reader::readArray	json/json.h	/^  bool readArray(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
Json::Reader::readCStyleComment	json/json.h	/^  bool readCStyleComment();$/;"	p	class:Json::Reader	access:private	signature:()
Json::Reader::readComment	json/json.h	/^  bool readComment();$/;"	p	class:Json::Reader	access:private	signature:()
Json::Reader::readCppStyleComment	json/json.h	/^  bool readCppStyleComment();$/;"	p	class:Json::Reader	access:private	signature:()
Json::Reader::readNumber	json/json.h	/^  void readNumber();$/;"	p	class:Json::Reader	access:private	signature:()
Json::Reader::readObject	json/json.h	/^  bool readObject(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
Json::Reader::readString	json/json.h	/^  bool readString();$/;"	p	class:Json::Reader	access:private	signature:()
Json::Reader::readToken	json/json.h	/^  bool readToken(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
Json::Reader::readValue	json/json.h	/^  bool readValue();$/;"	p	class:Json::Reader	access:private	signature:()
Json::Reader::recoverFromError	json/json.h	/^  bool recoverFromError(TokenType skipUntilToken);$/;"	p	class:Json::Reader	access:private	signature:(TokenType skipUntilToken)
Json::Reader::skipCommentTokens	json/json.h	/^  void skipCommentTokens(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
Json::Reader::skipSpaces	json/json.h	/^  void skipSpaces();$/;"	p	class:Json::Reader	access:private	signature:()
Json::Reader::skipUntilSpace	json/json.h	/^  void skipUntilSpace();$/;"	p	class:Json::Reader	access:private	signature:()
Json::Reader::tokenArrayBegin	json/json.h	/^    tokenArrayBegin,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenArrayEnd	json/json.h	/^    tokenArrayEnd,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenArraySeparator	json/json.h	/^    tokenArraySeparator,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenComment	json/json.h	/^    tokenComment,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenEndOfStream	json/json.h	/^    tokenEndOfStream = 0,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenError	json/json.h	/^    tokenError$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenFalse	json/json.h	/^    tokenFalse,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenMemberSeparator	json/json.h	/^    tokenMemberSeparator,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenNull	json/json.h	/^    tokenNull,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenNumber	json/json.h	/^    tokenNumber,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenObjectBegin	json/json.h	/^    tokenObjectBegin,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenObjectEnd	json/json.h	/^    tokenObjectEnd,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenString	json/json.h	/^    tokenString,$/;"	e	enum:Json::Reader::TokenType
Json::Reader::tokenTrue	json/json.h	/^    tokenTrue,$/;"	e	enum:Json::Reader::TokenType
Json::RuntimeError	json/json.h	/^class JSON_API RuntimeError : public Exception {$/;"	c	namespace:Json	inherits:Exception
Json::RuntimeError::RuntimeError	json/json.h	/^  RuntimeError(std::string const& msg);$/;"	p	class:Json::RuntimeError	access:public	signature:(std::string const& msg)
Json::StaticString	json/json.h	/^class JSON_API StaticString {$/;"	c	namespace:Json
Json::StaticString::StaticString	json/json.h	/^  explicit StaticString(const char* czstring) : c_str_(czstring) {}$/;"	f	class:Json::StaticString	access:public	signature:(const char* czstring)
Json::StaticString::c_str	json/json.h	/^  const char* c_str() const { return c_str_; }$/;"	f	class:Json::StaticString	access:public	signature:() const
Json::StaticString::c_str_	json/json.h	/^  const char* c_str_;$/;"	m	class:Json::StaticString	access:private
Json::StaticString::operator const char*	json/json.h	/^  operator const char*() const { return c_str_; }$/;"	f	class:Json::StaticString	access:public	signature:() const
Json::StreamWriter	json/json.h	/^class JSON_API StreamWriter {$/;"	c	namespace:Json
Json::StreamWriter::Factory	json/json.h	/^  class JSON_API Factory {$/;"	c	class:Json::StreamWriter	access:public
Json::StreamWriter::Factory::newStreamWriter	json/json.h	/^    virtual StreamWriter* newStreamWriter() const = 0;$/;"	p	class:Json::StreamWriter::Factory	access:public	signature:() const
Json::StreamWriter::Factory::~Factory	json/json.h	/^    virtual ~Factory();$/;"	p	class:Json::StreamWriter::Factory	access:public	signature:()
Json::StreamWriter::StreamWriter	json/json.h	/^  StreamWriter();$/;"	p	class:Json::StreamWriter	access:public	signature:()
Json::StreamWriter::sout_	json/json.h	/^  std::ostream* sout_;  \/\/ not owned; will not delete$/;"	m	class:Json::StreamWriter	access:protected
Json::StreamWriter::write	json/json.h	/^  virtual int write(Value const& root, std::ostream* sout) = 0;$/;"	p	class:Json::StreamWriter	access:public	signature:(Value const& root, std::ostream* sout)
Json::StreamWriter::~StreamWriter	json/json.h	/^  virtual ~StreamWriter();$/;"	p	class:Json::StreamWriter	access:public	signature:()
Json::StreamWriterBuilder	json/json.h	/^class JSON_API StreamWriterBuilder : public StreamWriter::Factory {$/;"	c	namespace:Json	inherits:StreamWriter::Factory
Json::StreamWriterBuilder::StreamWriterBuilder	json/json.h	/^  StreamWriterBuilder();$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:()
Json::StreamWriterBuilder::newStreamWriter	json/json.h	/^  virtual StreamWriter* newStreamWriter() const;$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:() const
Json::StreamWriterBuilder::operator []	json/json.h	/^  Value& operator[](std::string key);$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:(std::string key)
Json::StreamWriterBuilder::setDefaults	json/json.h	/^  static void setDefaults(Json::Value* settings);$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:(Json::Value* settings)
Json::StreamWriterBuilder::settings_	json/json.h	/^  Json::Value settings_;$/;"	m	class:Json::StreamWriterBuilder	access:public
Json::StreamWriterBuilder::validate	json/json.h	/^  bool validate(Json::Value* invalid) const;$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:(Json::Value* invalid) const
Json::StreamWriterBuilder::~StreamWriterBuilder	json/json.h	/^  virtual ~StreamWriterBuilder();$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:()
Json::StyledStreamWriter	json/json.h	/^class JSON_API StyledStreamWriter {$/;"	c	namespace:Json
Json::StyledStreamWriter::ChildValues	json/json.h	/^  typedef std::vector<std::string> ChildValues;$/;"	t	class:Json::StyledStreamWriter	access:private
Json::StyledStreamWriter::StyledStreamWriter	json/json.h	/^  StyledStreamWriter(std::string indentation = "\\t");$/;"	p	class:Json::StyledStreamWriter	access:public	signature:(std::string indentation = Ó)
Json::StyledStreamWriter::childValues_	json/json.h	/^  ChildValues childValues_;$/;"	m	class:Json::StyledStreamWriter	access:private
Json::StyledStreamWriter::document_	json/json.h	/^  std::ostream* document_;$/;"	m	class:Json::StyledStreamWriter	access:private
Json::StyledStreamWriter::hasCommentForValue	json/json.h	/^  bool hasCommentForValue(const Value& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& value)
Json::StyledStreamWriter::indent	json/json.h	/^  void indent();$/;"	p	class:Json::StyledStreamWriter	access:private	signature:()
Json::StyledStreamWriter::indentString_	json/json.h	/^  std::string indentString_;$/;"	m	class:Json::StyledStreamWriter	access:private
Json::StyledStreamWriter::indentation_	json/json.h	/^  std::string indentation_;$/;"	m	class:Json::StyledStreamWriter	access:private
Json::StyledStreamWriter::isMultineArray	json/json.h	/^  bool isMultineArray(const Value& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& value)
Json::StyledStreamWriter::normalizeEOL	json/json.h	/^  static std::string normalizeEOL(const std::string& text);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const std::string& text)
Json::StyledStreamWriter::pushValue	json/json.h	/^  void pushValue(const std::string& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const std::string& value)
Json::StyledStreamWriter::rightMargin_	json/json.h	/^  int rightMargin_;$/;"	m	class:Json::StyledStreamWriter	access:private
Json::StyledStreamWriter::unindent	json/json.h	/^  void unindent();$/;"	p	class:Json::StyledStreamWriter	access:private	signature:()
Json::StyledStreamWriter::write	json/json.h	/^  void write(std::ostream& out, const Value& root);$/;"	p	class:Json::StyledStreamWriter	access:public	signature:(std::ostream& out, const Value& root)
Json::StyledStreamWriter::writeArrayValue	json/json.h	/^  void writeArrayValue(const Value& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& value)
Json::StyledStreamWriter::writeCommentAfterValueOnSameLine	json/json.h	/^  void writeCommentAfterValueOnSameLine(const Value& root);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& root)
Json::StyledStreamWriter::writeCommentBeforeValue	json/json.h	/^  void writeCommentBeforeValue(const Value& root);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& root)
Json::StyledStreamWriter::writeIndent	json/json.h	/^  void writeIndent();$/;"	p	class:Json::StyledStreamWriter	access:private	signature:()
Json::StyledStreamWriter::writeValue	json/json.h	/^  void writeValue(const Value& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& value)
Json::StyledStreamWriter::writeWithIndent	json/json.h	/^  void writeWithIndent(const std::string& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const std::string& value)
Json::StyledStreamWriter::~StyledStreamWriter	json/json.h	/^  ~StyledStreamWriter() {}$/;"	f	class:Json::StyledStreamWriter	access:public	signature:()
Json::StyledWriter	json/json.h	/^class JSON_API StyledWriter : public Writer {$/;"	c	namespace:Json	inherits:Writer
Json::StyledWriter::ChildValues	json/json.h	/^  typedef std::vector<std::string> ChildValues;$/;"	t	class:Json::StyledWriter	access:private
Json::StyledWriter::StyledWriter	json/json.h	/^  StyledWriter();$/;"	p	class:Json::StyledWriter	access:public	signature:()
Json::StyledWriter::addChildValues_	json/json.h	/^  bool addChildValues_;$/;"	m	class:Json::StyledWriter	access:private
Json::StyledWriter::childValues_	json/json.h	/^  ChildValues childValues_;$/;"	m	class:Json::StyledWriter	access:private
Json::StyledWriter::document_	json/json.h	/^  std::string document_;$/;"	m	class:Json::StyledWriter	access:private
Json::StyledWriter::hasCommentForValue	json/json.h	/^  bool hasCommentForValue(const Value& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& value)
Json::StyledWriter::indent	json/json.h	/^  void indent();$/;"	p	class:Json::StyledWriter	access:private	signature:()
Json::StyledWriter::indentSize_	json/json.h	/^  int indentSize_;$/;"	m	class:Json::StyledWriter	access:private
Json::StyledWriter::indentString_	json/json.h	/^  std::string indentString_;$/;"	m	class:Json::StyledWriter	access:private
Json::StyledWriter::isMultineArray	json/json.h	/^  bool isMultineArray(const Value& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& value)
Json::StyledWriter::normalizeEOL	json/json.h	/^  static std::string normalizeEOL(const std::string& text);$/;"	p	class:Json::StyledWriter	access:private	signature:(const std::string& text)
Json::StyledWriter::pushValue	json/json.h	/^  void pushValue(const std::string& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const std::string& value)
Json::StyledWriter::rightMargin_	json/json.h	/^  int rightMargin_;$/;"	m	class:Json::StyledWriter	access:private
Json::StyledWriter::unindent	json/json.h	/^  void unindent();$/;"	p	class:Json::StyledWriter	access:private	signature:()
Json::StyledWriter::write	json/json.h	/^  virtual std::string write(const Value& root);$/;"	p	class:Json::StyledWriter	access:public	signature:(const Value& root)
Json::StyledWriter::writeArrayValue	json/json.h	/^  void writeArrayValue(const Value& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& value)
Json::StyledWriter::writeCommentAfterValueOnSameLine	json/json.h	/^  void writeCommentAfterValueOnSameLine(const Value& root);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& root)
Json::StyledWriter::writeCommentBeforeValue	json/json.h	/^  void writeCommentBeforeValue(const Value& root);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& root)
Json::StyledWriter::writeIndent	json/json.h	/^  void writeIndent();$/;"	p	class:Json::StyledWriter	access:private	signature:()
Json::StyledWriter::writeValue	json/json.h	/^  void writeValue(const Value& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& value)
Json::StyledWriter::writeWithIndent	json/json.h	/^  void writeWithIndent(const std::string& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const std::string& value)
Json::StyledWriter::~StyledWriter	json/json.h	/^  virtual ~StyledWriter() {}$/;"	f	class:Json::StyledWriter	access:public	signature:()
Json::UInt	json/json-forwards.h	/^typedef unsigned int UInt;$/;"	t	namespace:Json
Json::UInt	json/json.h	/^typedef unsigned int UInt;$/;"	t	namespace:Json
Json::UInt64	json/json-forwards.h	/^typedef unsigned __int64 UInt64;$/;"	t	namespace:Json
Json::UInt64	json/json-forwards.h	/^typedef unsigned long long int UInt64;$/;"	t	namespace:Json
Json::UInt64	json/json.h	/^typedef unsigned __int64 UInt64;$/;"	t	namespace:Json
Json::UInt64	json/json.h	/^typedef unsigned long long int UInt64;$/;"	t	namespace:Json
Json::Value	json/json.h	/^class JSON_API Value {$/;"	c	namespace:Json
Json::Value::ArrayIndex	json/json.h	/^  typedef Json::ArrayIndex ArrayIndex;$/;"	t	class:Json::Value	access:public
Json::Value::CZString	json/json.h	/^  class CZString {$/;"	c	class:Json::Value	access:private
Json::Value::CZString::CZString	json/json.h	/^    CZString(ArrayIndex index);$/;"	p	class:Json::Value::CZString	access:public	signature:(ArrayIndex index)
Json::Value::CZString::CZString	json/json.h	/^    CZString(CZString const& other);$/;"	p	class:Json::Value::CZString	access:public	signature:(CZString const& other)
Json::Value::CZString::CZString	json/json.h	/^    CZString(char const* str, unsigned length, DuplicationPolicy allocate);$/;"	p	class:Json::Value::CZString	access:public	signature:(char const* str, unsigned length, DuplicationPolicy allocate)
Json::Value::CZString::DuplicationPolicy	json/json.h	/^    enum DuplicationPolicy {$/;"	g	class:Json::Value::CZString	access:public
Json::Value::CZString::StringStorage	json/json.h	/^    struct StringStorage {$/;"	s	class:Json::Value::CZString	access:private
Json::Value::CZString::StringStorage::length_	json/json.h	/^      unsigned length_: 30; \/\/ 1GB max$/;"	m	struct:Json::Value::CZString::StringStorage	access:public
Json::Value::CZString::StringStorage::policy_	json/json.h	/^      unsigned policy_: 2;$/;"	m	struct:Json::Value::CZString::StringStorage	access:public
Json::Value::CZString::__anon19::index_	json/json.h	/^      ArrayIndex index_;$/;"	m	union:Json::Value::CZString::__anon19	access:public
Json::Value::CZString::__anon19::storage_	json/json.h	/^      StringStorage storage_;$/;"	m	union:Json::Value::CZString::__anon19	access:public
Json::Value::CZString::cstr_	json/json.h	/^    char const* cstr_;  \/\/ actually, a prefixed string, unless policy is noDup$/;"	m	class:Json::Value::CZString	access:private
Json::Value::CZString::data	json/json.h	/^    char const* data() const;$/;"	p	class:Json::Value::CZString	access:public	signature:() const
Json::Value::CZString::duplicate	json/json.h	/^      duplicate,$/;"	e	enum:Json::Value::CZString::DuplicationPolicy
Json::Value::CZString::duplicateOnCopy	json/json.h	/^      duplicateOnCopy$/;"	e	enum:Json::Value::CZString::DuplicationPolicy
Json::Value::CZString::index	json/json.h	/^    ArrayIndex index() const;$/;"	p	class:Json::Value::CZString	access:public	signature:() const
Json::Value::CZString::isStaticString	json/json.h	/^    bool isStaticString() const;$/;"	p	class:Json::Value::CZString	access:public	signature:() const
Json::Value::CZString::length	json/json.h	/^    unsigned length() const;$/;"	p	class:Json::Value::CZString	access:public	signature:() const
Json::Value::CZString::noDuplication	json/json.h	/^      noDuplication = 0,$/;"	e	enum:Json::Value::CZString::DuplicationPolicy
Json::Value::CZString::operator <	json/json.h	/^    bool operator<(CZString const& other) const;$/;"	p	class:Json::Value::CZString	access:public	signature:(CZString const& other) const
Json::Value::CZString::operator =	json/json.h	/^    CZString& operator=(CZString other);$/;"	p	class:Json::Value::CZString	access:public	signature:(CZString other)
Json::Value::CZString::operator ==	json/json.h	/^    bool operator==(CZString const& other) const;$/;"	p	class:Json::Value::CZString	access:public	signature:(CZString const& other) const
Json::Value::CZString::swap	json/json.h	/^    void swap(CZString& other);$/;"	p	class:Json::Value::CZString	access:private	signature:(CZString& other)
Json::Value::CZString::~CZString	json/json.h	/^    ~CZString();$/;"	p	class:Json::Value::CZString	access:public	signature:()
Json::Value::CommentInfo	json/json.h	/^  struct CommentInfo {$/;"	s	class:Json::Value	access:private
Json::Value::CommentInfo::CommentInfo	json/json.h	/^    CommentInfo();$/;"	p	struct:Json::Value::CommentInfo	access:public	signature:()
Json::Value::CommentInfo::comment_	json/json.h	/^    char* comment_;$/;"	m	struct:Json::Value::CommentInfo	access:public
Json::Value::CommentInfo::setComment	json/json.h	/^    void setComment(const char* text, size_t len);$/;"	p	struct:Json::Value::CommentInfo	access:public	signature:(const char* text, size_t len)
Json::Value::CommentInfo::~CommentInfo	json/json.h	/^    ~CommentInfo();$/;"	p	struct:Json::Value::CommentInfo	access:public	signature:()
Json::Value::Int	json/json.h	/^  typedef Json::Int Int;$/;"	t	class:Json::Value	access:public
Json::Value::Int64	json/json.h	/^  typedef Json::Int64 Int64;$/;"	t	class:Json::Value	access:public
Json::Value::LargestInt	json/json.h	/^  typedef Json::LargestInt LargestInt;$/;"	t	class:Json::Value	access:public
Json::Value::LargestUInt	json/json.h	/^  typedef Json::LargestUInt LargestUInt;$/;"	t	class:Json::Value	access:public
Json::Value::Members	json/json.h	/^  typedef std::vector<std::string> Members;$/;"	t	class:Json::Value	access:public
Json::Value::ObjectValues	json/json.h	/^  typedef CppTL::SmallMap<CZString, Value> ObjectValues;$/;"	t	class:Json::Value	access:public
Json::Value::ObjectValues	json/json.h	/^  typedef std::map<CZString, Value> ObjectValues;$/;"	t	class:Json::Value	access:public
Json::Value::UInt	json/json.h	/^  typedef Json::UInt UInt;$/;"	t	class:Json::Value	access:public
Json::Value::UInt64	json/json.h	/^  typedef Json::UInt64 UInt64;$/;"	t	class:Json::Value	access:public
Json::Value::Value	json/json.h	/^  Value(Int value);$/;"	p	class:Json::Value	access:public	signature:(Int value)
Json::Value::Value	json/json.h	/^  Value(Int64 value);$/;"	p	class:Json::Value	access:public	signature:(Int64 value)
Json::Value::Value	json/json.h	/^  Value(UInt value);$/;"	p	class:Json::Value	access:public	signature:(UInt value)
Json::Value::Value	json/json.h	/^  Value(UInt64 value);$/;"	p	class:Json::Value	access:public	signature:(UInt64 value)
Json::Value::Value	json/json.h	/^  Value(ValueType type = nullValue);$/;"	p	class:Json::Value	access:public	signature:(ValueType type = nullValue)
Json::Value::Value	json/json.h	/^  Value(bool value);$/;"	p	class:Json::Value	access:public	signature:(bool value)
Json::Value::Value	json/json.h	/^  Value(const CppTL::ConstString& value);$/;"	p	class:Json::Value	access:public	signature:(const CppTL::ConstString& value)
Json::Value::Value	json/json.h	/^  Value(const StaticString& value);$/;"	p	class:Json::Value	access:public	signature:(const StaticString& value)
Json::Value::Value	json/json.h	/^  Value(const Value& other);$/;"	p	class:Json::Value	access:public	signature:(const Value& other)
Json::Value::Value	json/json.h	/^  Value(const char* begin, const char* end); \/\/\/< Copy all, incl zeroes.$/;"	p	class:Json::Value	access:public	signature:(const char* begin, const char* end)
Json::Value::Value	json/json.h	/^  Value(const char* value); \/\/\/< Copy til first 0. (NULL causes to seg-fault.)$/;"	p	class:Json::Value	access:public	signature:(const char* value)
Json::Value::Value	json/json.h	/^  Value(const std::string& value); \/\/\/< Copy data() til size(). Embedded zeroes too.$/;"	p	class:Json::Value	access:public	signature:(const std::string& value)
Json::Value::Value	json/json.h	/^  Value(double value);$/;"	p	class:Json::Value	access:public	signature:(double value)
Json::Value::ValueHolder	json/json.h	/^  union ValueHolder {$/;"	u	class:Json::Value	access:private
Json::Value::ValueHolder::bool_	json/json.h	/^    bool bool_;$/;"	m	union:Json::Value::ValueHolder	access:public
Json::Value::ValueHolder::int_	json/json.h	/^    LargestInt int_;$/;"	m	union:Json::Value::ValueHolder	access:public
Json::Value::ValueHolder::map_	json/json.h	/^    ObjectValues* map_;$/;"	m	union:Json::Value::ValueHolder	access:public
Json::Value::ValueHolder::real_	json/json.h	/^    double real_;$/;"	m	union:Json::Value::ValueHolder	access:public
Json::Value::ValueHolder::string_	json/json.h	/^    char* string_;  \/\/ actually ptr to unsigned, followed by str, unless !allocated_$/;"	m	union:Json::Value::ValueHolder	access:public
Json::Value::ValueHolder::uint_	json/json.h	/^    LargestUInt uint_;$/;"	m	union:Json::Value::ValueHolder	access:public
Json::Value::append	json/json.h	/^  Value& append(const Value& value);$/;"	p	class:Json::Value	access:public	signature:(const Value& value)
Json::Value::asBool	json/json.h	/^  bool asBool() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asCString	json/json.h	/^  const char* asCString() const; \/\/\/< Embedded zeroes could cause you trouble!$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asConstString	json/json.h	/^  CppTL::ConstString asConstString() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asDouble	json/json.h	/^  double asDouble() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asFloat	json/json.h	/^  float asFloat() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asInt	json/json.h	/^  Int asInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asInt64	json/json.h	/^  Int64 asInt64() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asLargestInt	json/json.h	/^  LargestInt asLargestInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asLargestUInt	json/json.h	/^  LargestUInt asLargestUInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asString	json/json.h	/^  std::string asString() const; \/\/\/< Embedded zeroes are possible.$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asUInt	json/json.h	/^  UInt asUInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::asUInt64	json/json.h	/^  UInt64 asUInt64() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::begin	json/json.h	/^  const_iterator begin() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::begin	json/json.h	/^  iterator begin();$/;"	p	class:Json::Value	access:public	signature:()
Json::Value::clear	json/json.h	/^  void clear();$/;"	p	class:Json::Value	access:public	signature:()
Json::Value::comments_	json/json.h	/^  CommentInfo* comments_;$/;"	m	class:Json::Value	access:private
Json::Value::compare	json/json.h	/^  int compare(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
Json::Value::const_iterator	json/json.h	/^  typedef ValueConstIterator const_iterator;$/;"	t	class:Json::Value	access:public
Json::Value::demand	json/json.h	/^  Value const* demand(char const* begin, char const* end);$/;"	p	class:Json::Value	access:public	signature:(char const* begin, char const* end)
Json::Value::empty	json/json.h	/^  bool empty() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::end	json/json.h	/^  const_iterator end() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::end	json/json.h	/^  iterator end();$/;"	p	class:Json::Value	access:public	signature:()
Json::Value::find	json/json.h	/^  Value const* find(char const* begin, char const* end) const;$/;"	p	class:Json::Value	access:public	signature:(char const* begin, char const* end) const
Json::Value::get	json/json.h	/^  Value get(ArrayIndex index, const Value& defaultValue) const;$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex index, const Value& defaultValue) const
Json::Value::get	json/json.h	/^  Value get(const CppTL::ConstString& key, const Value& defaultValue) const;$/;"	p	class:Json::Value	access:public	signature:(const CppTL::ConstString& key, const Value& defaultValue) const
Json::Value::get	json/json.h	/^  Value get(const char* begin, const char* end, const Value& defaultValue) const;$/;"	p	class:Json::Value	access:public	signature:(const char* begin, const char* end, const Value& defaultValue) const
Json::Value::get	json/json.h	/^  Value get(const char* key, const Value& defaultValue) const;$/;"	p	class:Json::Value	access:public	signature:(const char* key, const Value& defaultValue) const
Json::Value::get	json/json.h	/^  Value get(const std::string& key, const Value& defaultValue) const;$/;"	p	class:Json::Value	access:public	signature:(const std::string& key, const Value& defaultValue) const
Json::Value::getComment	json/json.h	/^  std::string getComment(CommentPlacement placement) const;$/;"	p	class:Json::Value	access:public	signature:(CommentPlacement placement) const
Json::Value::getMemberNames	json/json.h	/^  Members getMemberNames() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::getOffsetLimit	json/json.h	/^  size_t getOffsetLimit() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::getOffsetStart	json/json.h	/^  size_t getOffsetStart() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::getString	json/json.h	/^  bool getString($/;"	p	class:Json::Value	access:public	signature:( char const** begin, char const** end) const
Json::Value::hasComment	json/json.h	/^  bool hasComment(CommentPlacement placement) const;$/;"	p	class:Json::Value	access:public	signature:(CommentPlacement placement) const
Json::Value::initBasic	json/json.h	/^  void initBasic(ValueType type, bool allocated = false);$/;"	p	class:Json::Value	access:private	signature:(ValueType type, bool allocated = false)
Json::Value::isArray	json/json.h	/^  bool isArray() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isBool	json/json.h	/^  bool isBool() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isConvertibleTo	json/json.h	/^  bool isConvertibleTo(ValueType other) const;$/;"	p	class:Json::Value	access:public	signature:(ValueType other) const
Json::Value::isDouble	json/json.h	/^  bool isDouble() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isInt	json/json.h	/^  bool isInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isInt64	json/json.h	/^  bool isInt64() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isIntegral	json/json.h	/^  bool isIntegral() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isMember	json/json.h	/^  bool isMember(const CppTL::ConstString& key) const;$/;"	p	class:Json::Value	access:public	signature:(const CppTL::ConstString& key) const
Json::Value::isMember	json/json.h	/^  bool isMember(const char* begin, const char* end) const;$/;"	p	class:Json::Value	access:public	signature:(const char* begin, const char* end) const
Json::Value::isMember	json/json.h	/^  bool isMember(const char* key) const;$/;"	p	class:Json::Value	access:public	signature:(const char* key) const
Json::Value::isMember	json/json.h	/^  bool isMember(const std::string& key) const;$/;"	p	class:Json::Value	access:public	signature:(const std::string& key) const
Json::Value::isNull	json/json.h	/^  bool isNull() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isNumeric	json/json.h	/^  bool isNumeric() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isObject	json/json.h	/^  bool isObject() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isString	json/json.h	/^  bool isString() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isUInt	json/json.h	/^  bool isUInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isUInt64	json/json.h	/^  bool isUInt64() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::isValidIndex	json/json.h	/^  bool isValidIndex(ArrayIndex index) const;$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex index) const
Json::Value::iterator	json/json.h	/^  typedef ValueIterator iterator;$/;"	t	class:Json::Value	access:public
Json::Value::limit_	json/json.h	/^  size_t limit_;$/;"	m	class:Json::Value	access:private
Json::Value::maxInt	json/json.h	/^  static const Int maxInt;$/;"	m	class:Json::Value	access:public
Json::Value::maxInt64	json/json.h	/^  static const Int64 maxInt64;$/;"	m	class:Json::Value	access:public
Json::Value::maxLargestInt	json/json.h	/^  static const LargestInt maxLargestInt;$/;"	m	class:Json::Value	access:public
Json::Value::maxLargestUInt	json/json.h	/^  static const LargestUInt maxLargestUInt;$/;"	m	class:Json::Value	access:public
Json::Value::maxUInt	json/json.h	/^  static const UInt maxUInt;$/;"	m	class:Json::Value	access:public
Json::Value::maxUInt64	json/json.h	/^  static const UInt64 maxUInt64;$/;"	m	class:Json::Value	access:public
Json::Value::minInt	json/json.h	/^  static const Int minInt;$/;"	m	class:Json::Value	access:public
Json::Value::minInt64	json/json.h	/^  static const Int64 minInt64;$/;"	m	class:Json::Value	access:public
Json::Value::minLargestInt	json/json.h	/^  static const LargestInt minLargestInt;$/;"	m	class:Json::Value	access:public
Json::Value::null	json/json.h	/^  static const Value& null;  \/\/\/< We regret this reference to a global instance; prefer the simpler Value().$/;"	m	class:Json::Value	access:public
Json::Value::nullRef	json/json.h	/^  static const Value& nullRef;  \/\/\/< just a kludge for binary-compatibility; same as null$/;"	m	class:Json::Value	access:public
Json::Value::operator !	json/json.h	/^  bool operator!() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::operator !=	json/json.h	/^  bool operator!=(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
Json::Value::operator <	json/json.h	/^  bool operator<(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
Json::Value::operator <=	json/json.h	/^  bool operator<=(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
Json::Value::operator =	json/json.h	/^  Value& operator=(Value other);$/;"	p	class:Json::Value	access:public	signature:(Value other)
Json::Value::operator ==	json/json.h	/^  bool operator==(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
Json::Value::operator >	json/json.h	/^  bool operator>(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
Json::Value::operator >=	json/json.h	/^  bool operator>=(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
Json::Value::operator []	json/json.h	/^  Value& operator[](ArrayIndex index);$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex index)
Json::Value::operator []	json/json.h	/^  Value& operator[](const CppTL::ConstString& key);$/;"	p	class:Json::Value	access:public	signature:(const CppTL::ConstString& key)
Json::Value::operator []	json/json.h	/^  Value& operator[](const StaticString& key);$/;"	p	class:Json::Value	access:public	signature:(const StaticString& key)
Json::Value::operator []	json/json.h	/^  Value& operator[](const char* key);$/;"	p	class:Json::Value	access:public	signature:(const char* key)
Json::Value::operator []	json/json.h	/^  Value& operator[](const std::string& key);$/;"	p	class:Json::Value	access:public	signature:(const std::string& key)
Json::Value::operator []	json/json.h	/^  Value& operator[](int index);$/;"	p	class:Json::Value	access:public	signature:(int index)
Json::Value::operator []	json/json.h	/^  const Value& operator[](ArrayIndex index) const;$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex index) const
Json::Value::operator []	json/json.h	/^  const Value& operator[](const CppTL::ConstString& key) const;$/;"	p	class:Json::Value	access:public	signature:(const CppTL::ConstString& key) const
Json::Value::operator []	json/json.h	/^  const Value& operator[](const char* key) const;$/;"	p	class:Json::Value	access:public	signature:(const char* key) const
Json::Value::operator []	json/json.h	/^  const Value& operator[](const std::string& key) const;$/;"	p	class:Json::Value	access:public	signature:(const std::string& key) const
Json::Value::operator []	json/json.h	/^  const Value& operator[](int index) const;$/;"	p	class:Json::Value	access:public	signature:(int index) const
Json::Value::removeIndex	json/json.h	/^  bool removeIndex(ArrayIndex i, Value* removed);$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex i, Value* removed)
Json::Value::removeMember	json/json.h	/^  Value removeMember(const char* key);$/;"	p	class:Json::Value	access:public	signature:(const char* key)
Json::Value::removeMember	json/json.h	/^  Value removeMember(const std::string& key);$/;"	p	class:Json::Value	access:public	signature:(const std::string& key)
Json::Value::removeMember	json/json.h	/^  bool removeMember(const char* begin, const char* end, Value* removed);$/;"	p	class:Json::Value	access:public	signature:(const char* begin, const char* end, Value* removed)
Json::Value::removeMember	json/json.h	/^  bool removeMember(const char* key, Value* removed);$/;"	p	class:Json::Value	access:public	signature:(const char* key, Value* removed)
Json::Value::removeMember	json/json.h	/^  bool removeMember(std::string const& key, Value* removed);$/;"	p	class:Json::Value	access:public	signature:(std::string const& key, Value* removed)
Json::Value::resize	json/json.h	/^  void resize(ArrayIndex size);$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex size)
Json::Value::resolveReference	json/json.h	/^  Value& resolveReference(const char* key);$/;"	p	class:Json::Value	access:private	signature:(const char* key)
Json::Value::resolveReference	json/json.h	/^  Value& resolveReference(const char* key, const char* end);$/;"	p	class:Json::Value	access:private	signature:(const char* key, const char* end)
Json::Value::setComment	json/json.h	/^  void setComment(const char* comment, CommentPlacement placement);$/;"	p	class:Json::Value	access:public	signature:(const char* comment, CommentPlacement placement)
Json::Value::setComment	json/json.h	/^  void setComment(const char* comment, size_t len, CommentPlacement placement);$/;"	p	class:Json::Value	access:public	signature:(const char* comment, size_t len, CommentPlacement placement)
Json::Value::setComment	json/json.h	/^  void setComment(const std::string& comment, CommentPlacement placement);$/;"	p	class:Json::Value	access:public	signature:(const std::string& comment, CommentPlacement placement)
Json::Value::setOffsetLimit	json/json.h	/^  void setOffsetLimit(size_t limit);$/;"	p	class:Json::Value	access:public	signature:(size_t limit)
Json::Value::setOffsetStart	json/json.h	/^  void setOffsetStart(size_t start);$/;"	p	class:Json::Value	access:public	signature:(size_t start)
Json::Value::size	json/json.h	/^  ArrayIndex size() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::start_	json/json.h	/^  size_t start_;$/;"	m	class:Json::Value	access:private
Json::Value::swap	json/json.h	/^  void swap(Value& other);$/;"	p	class:Json::Value	access:public	signature:(Value& other)
Json::Value::swapPayload	json/json.h	/^  void swapPayload(Value& other);$/;"	p	class:Json::Value	access:public	signature:(Value& other)
Json::Value::toStyledString	json/json.h	/^  std::string toStyledString() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::type	json/json.h	/^  ValueType type() const;$/;"	p	class:Json::Value	access:public	signature:() const
Json::Value::value_	json/json.h	/^  } value_;$/;"	m	class:Json::Value	typeref:union:Json::Value::ValueHolder	access:private
Json::Value::~Value	json/json.h	/^  ~Value();$/;"	p	class:Json::Value	access:public	signature:()
Json::ValueConstIterator	json/json.h	/^class JSON_API ValueConstIterator : public ValueIteratorBase {$/;"	c	namespace:Json	inherits:ValueIteratorBase
Json::ValueConstIterator::SelfType	json/json.h	/^  typedef ValueConstIterator SelfType;$/;"	t	class:Json::ValueConstIterator	access:public
Json::ValueConstIterator::ValueConstIterator	json/json.h	/^  ValueConstIterator();$/;"	p	class:Json::ValueConstIterator	access:public	signature:()
Json::ValueConstIterator::ValueConstIterator	json/json.h	/^  explicit ValueConstIterator(const Value::ObjectValues::iterator& current);$/;"	p	class:Json::ValueConstIterator	access:private	signature:(const Value::ObjectValues::iterator& current)
Json::ValueConstIterator::operator *	json/json.h	/^  reference operator*() const { return deref(); }$/;"	f	class:Json::ValueConstIterator	access:public	signature:() const
Json::ValueConstIterator::operator ++	json/json.h	/^  SelfType operator++(int) {$/;"	f	class:Json::ValueConstIterator	access:public	signature:(int)
Json::ValueConstIterator::operator ++	json/json.h	/^  SelfType& operator++() {$/;"	f	class:Json::ValueConstIterator	access:public	signature:()
Json::ValueConstIterator::operator --	json/json.h	/^  SelfType operator--(int) {$/;"	f	class:Json::ValueConstIterator	access:public	signature:(int)
Json::ValueConstIterator::operator --	json/json.h	/^  SelfType& operator--() {$/;"	f	class:Json::ValueConstIterator	access:public	signature:()
Json::ValueConstIterator::operator ->	json/json.h	/^  pointer operator->() const { return &deref(); }$/;"	f	class:Json::ValueConstIterator	access:public	signature:() const
Json::ValueConstIterator::operator =	json/json.h	/^  SelfType& operator=(const ValueIteratorBase& other);$/;"	p	class:Json::ValueConstIterator	access:public	signature:(const ValueIteratorBase& other)
Json::ValueConstIterator::pointer	json/json.h	/^  typedef const Value* pointer;$/;"	t	class:Json::ValueConstIterator	access:public
Json::ValueConstIterator::reference	json/json.h	/^  typedef const Value& reference;$/;"	t	class:Json::ValueConstIterator	access:public
Json::ValueConstIterator::value_type	json/json.h	/^  typedef const Value value_type;$/;"	t	class:Json::ValueConstIterator	access:public
Json::ValueIterator	json/json.h	/^class JSON_API ValueIterator : public ValueIteratorBase {$/;"	c	namespace:Json	inherits:ValueIteratorBase
Json::ValueIterator::SelfType	json/json.h	/^  typedef ValueIterator SelfType;$/;"	t	class:Json::ValueIterator	access:public
Json::ValueIterator::ValueIterator	json/json.h	/^  ValueIterator();$/;"	p	class:Json::ValueIterator	access:public	signature:()
Json::ValueIterator::ValueIterator	json/json.h	/^  ValueIterator(const ValueConstIterator& other);$/;"	p	class:Json::ValueIterator	access:public	signature:(const ValueConstIterator& other)
Json::ValueIterator::ValueIterator	json/json.h	/^  ValueIterator(const ValueIterator& other);$/;"	p	class:Json::ValueIterator	access:public	signature:(const ValueIterator& other)
Json::ValueIterator::ValueIterator	json/json.h	/^  explicit ValueIterator(const Value::ObjectValues::iterator& current);$/;"	p	class:Json::ValueIterator	access:private	signature:(const Value::ObjectValues::iterator& current)
Json::ValueIterator::difference_type	json/json.h	/^  typedef int difference_type;$/;"	t	class:Json::ValueIterator	access:public
Json::ValueIterator::operator *	json/json.h	/^  reference operator*() const { return deref(); }$/;"	f	class:Json::ValueIterator	access:public	signature:() const
Json::ValueIterator::operator ++	json/json.h	/^  SelfType operator++(int) {$/;"	f	class:Json::ValueIterator	access:public	signature:(int)
Json::ValueIterator::operator ++	json/json.h	/^  SelfType& operator++() {$/;"	f	class:Json::ValueIterator	access:public	signature:()
Json::ValueIterator::operator --	json/json.h	/^  SelfType operator--(int) {$/;"	f	class:Json::ValueIterator	access:public	signature:(int)
Json::ValueIterator::operator --	json/json.h	/^  SelfType& operator--() {$/;"	f	class:Json::ValueIterator	access:public	signature:()
Json::ValueIterator::operator ->	json/json.h	/^  pointer operator->() const { return &deref(); }$/;"	f	class:Json::ValueIterator	access:public	signature:() const
Json::ValueIterator::operator =	json/json.h	/^  SelfType& operator=(const SelfType& other);$/;"	p	class:Json::ValueIterator	access:public	signature:(const SelfType& other)
Json::ValueIterator::pointer	json/json.h	/^  typedef Value* pointer;$/;"	t	class:Json::ValueIterator	access:public
Json::ValueIterator::reference	json/json.h	/^  typedef Value& reference;$/;"	t	class:Json::ValueIterator	access:public
Json::ValueIterator::size_t	json/json.h	/^  typedef unsigned int size_t;$/;"	t	class:Json::ValueIterator	access:public
Json::ValueIterator::value_type	json/json.h	/^  typedef Value value_type;$/;"	t	class:Json::ValueIterator	access:public
Json::ValueIteratorBase	json/json.h	/^class JSON_API ValueIteratorBase {$/;"	c	namespace:Json
Json::ValueIteratorBase::SelfType	json/json.h	/^  typedef ValueIteratorBase SelfType;$/;"	t	class:Json::ValueIteratorBase	access:public
Json::ValueIteratorBase::ValueIteratorBase	json/json.h	/^  ValueIteratorBase();$/;"	p	class:Json::ValueIteratorBase	access:public	signature:()
Json::ValueIteratorBase::ValueIteratorBase	json/json.h	/^  explicit ValueIteratorBase(const Value::ObjectValues::iterator& current);$/;"	p	class:Json::ValueIteratorBase	access:public	signature:(const Value::ObjectValues::iterator& current)
Json::ValueIteratorBase::computeDistance	json/json.h	/^  difference_type computeDistance(const SelfType& other) const;$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:(const SelfType& other) const
Json::ValueIteratorBase::copy	json/json.h	/^  void copy(const SelfType& other);$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:(const SelfType& other)
Json::ValueIteratorBase::current_	json/json.h	/^  Value::ObjectValues::iterator current_;$/;"	m	class:Json::ValueIteratorBase	access:private
Json::ValueIteratorBase::decrement	json/json.h	/^  void decrement();$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:()
Json::ValueIteratorBase::deref	json/json.h	/^  Value& deref() const;$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:() const
Json::ValueIteratorBase::difference_type	json/json.h	/^  typedef int difference_type;$/;"	t	class:Json::ValueIteratorBase	access:public
Json::ValueIteratorBase::increment	json/json.h	/^  void increment();$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:()
Json::ValueIteratorBase::index	json/json.h	/^  UInt index() const;$/;"	p	class:Json::ValueIteratorBase	access:public	signature:() const
Json::ValueIteratorBase::isEqual	json/json.h	/^  bool isEqual(const SelfType& other) const;$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:(const SelfType& other) const
Json::ValueIteratorBase::isNull_	json/json.h	/^  bool isNull_;$/;"	m	class:Json::ValueIteratorBase	access:private
Json::ValueIteratorBase::iterator_category	json/json.h	/^  typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:Json::ValueIteratorBase	access:public
Json::ValueIteratorBase::key	json/json.h	/^  Value key() const;$/;"	p	class:Json::ValueIteratorBase	access:public	signature:() const
Json::ValueIteratorBase::memberName	json/json.h	/^  char const* memberName() const;$/;"	p	class:Json::ValueIteratorBase	access:public	signature:() const
Json::ValueIteratorBase::memberName	json/json.h	/^  char const* memberName(char const** end) const;$/;"	p	class:Json::ValueIteratorBase	access:public	signature:(char const** end) const
Json::ValueIteratorBase::name	json/json.h	/^  std::string name() const;$/;"	p	class:Json::ValueIteratorBase	access:public	signature:() const
Json::ValueIteratorBase::operator !=	json/json.h	/^  bool operator!=(const SelfType& other) const { return !isEqual(other); }$/;"	f	class:Json::ValueIteratorBase	access:public	signature:(const SelfType& other) const
Json::ValueIteratorBase::operator -	json/json.h	/^  difference_type operator-(const SelfType& other) const {$/;"	f	class:Json::ValueIteratorBase	access:public	signature:(const SelfType& other) const
Json::ValueIteratorBase::operator ==	json/json.h	/^  bool operator==(const SelfType& other) const { return isEqual(other); }$/;"	f	class:Json::ValueIteratorBase	access:public	signature:(const SelfType& other) const
Json::ValueIteratorBase::size_t	json/json.h	/^  typedef unsigned int size_t;$/;"	t	class:Json::ValueIteratorBase	access:public
Json::ValueType	json/json.h	/^enum ValueType {$/;"	g	namespace:Json
Json::Writer	json/json.h	/^class JSON_API Writer {$/;"	c	namespace:Json
Json::Writer::write	json/json.h	/^  virtual std::string write(const Value& root) = 0;$/;"	p	class:Json::Writer	access:public	signature:(const Value& root)
Json::Writer::~Writer	json/json.h	/^  virtual ~Writer();$/;"	p	class:Json::Writer	access:public	signature:()
Json::arrayValue	json/json.h	/^  arrayValue,    \/\/\/< array value (ordered list)$/;"	e	enum:Json::ValueType
Json::booleanValue	json/json.h	/^  booleanValue,  \/\/\/< bool value$/;"	e	enum:Json::ValueType
Json::commentAfter	json/json.h	/^  commentAfter, \/\/\/< a comment on the line after a value (only make sense for$/;"	e	enum:Json::CommentPlacement
Json::commentAfterOnSameLine	json/json.h	/^  commentAfterOnSameLine, \/\/\/< a comment just after a value on the same line$/;"	e	enum:Json::CommentPlacement
Json::commentBefore	json/json.h	/^  commentBefore = 0,      \/\/\/< a comment placed on the line before a value$/;"	e	enum:Json::CommentPlacement
Json::intValue	json/json.h	/^  intValue,      \/\/\/< signed integer value$/;"	e	enum:Json::ValueType
Json::nullValue	json/json.h	/^  nullValue = 0, \/\/\/< 'null' value$/;"	e	enum:Json::ValueType
Json::numberOfCommentPlacement	json/json.h	/^  numberOfCommentPlacement$/;"	e	enum:Json::CommentPlacement
Json::objectValue	json/json.h	/^  objectValue    \/\/\/< object value (collection of name\/value pairs).$/;"	e	enum:Json::ValueType
Json::operator <<	json/json.h	/^JSON_API std::ostream& operator<<(std::ostream&, const Value& root);$/;"	p	namespace:Json	signature:(std::ostream&, const Value& root)
Json::operator >>	json/json.h	/^JSON_API std::istream& operator>>(std::istream&, Value&);$/;"	p	namespace:Json	signature:(std::istream&, Value&)
Json::parseFromStream	json/json.h	/^bool JSON_API parseFromStream($/;"	p	namespace:Json	signature:( CharReader::Factory const&, std::istream&, Value* root, std::string* errs)
Json::realValue	json/json.h	/^  realValue,     \/\/\/< double value$/;"	e	enum:Json::ValueType
Json::stringValue	json/json.h	/^  stringValue,   \/\/\/< UTF-8 string value$/;"	e	enum:Json::ValueType
Json::throwLogicError	json/json.h	/^void throwLogicError(std::string const& msg);$/;"	p	namespace:Json	signature:(std::string const& msg)
Json::throwRuntimeError	json/json.h	/^void throwRuntimeError(std::string const& msg);$/;"	p	namespace:Json	signature:(std::string const& msg)
Json::uintValue	json/json.h	/^  uintValue,     \/\/\/< unsigned integer value$/;"	e	enum:Json::ValueType
Json::valueToQuotedString	json/json.h	/^std::string JSON_API valueToQuotedString(const char* value);$/;"	p	namespace:Json	signature:(const char* value)
Json::valueToString	json/json.h	/^std::string JSON_API valueToString(Int value);$/;"	p	namespace:Json	signature:(Int value)
Json::valueToString	json/json.h	/^std::string JSON_API valueToString(LargestInt value);$/;"	p	namespace:Json	signature:(LargestInt value)
Json::valueToString	json/json.h	/^std::string JSON_API valueToString(LargestUInt value);$/;"	p	namespace:Json	signature:(LargestUInt value)
Json::valueToString	json/json.h	/^std::string JSON_API valueToString(UInt value);$/;"	p	namespace:Json	signature:(UInt value)
Json::valueToString	json/json.h	/^std::string JSON_API valueToString(bool value);$/;"	p	namespace:Json	signature:(bool value)
Json::valueToString	json/json.h	/^std::string JSON_API valueToString(double value);$/;"	p	namespace:Json	signature:(double value)
Json::writeString	json/json.h	/^std::string JSON_API writeString(StreamWriter::Factory const& factory, Value const& root);$/;"	p	namespace:Json	signature:(StreamWriter::Factory const& factory, Value const& root)
Kind	json/json.h	/^  enum Kind {$/;"	g	class:Json::PathArgument	access:private
LIBUSBX_API_VERSION	libusb/libusb.h	147;"	d
LIBUSB_API_VERSION	libusb/libusb.h	144;"	d
LIBUSB_BM_LPM_SUPPORT	libusb/libusb.h	/^	LIBUSB_BM_LPM_SUPPORT = 2,$/;"	e	enum:libusb_usb_2_0_extension_attributes
LIBUSB_BM_LTM_SUPPORT	libusb/libusb.h	/^	LIBUSB_BM_LTM_SUPPORT = 2,$/;"	e	enum:libusb_ss_usb_device_capability_attributes
LIBUSB_BT_CONTAINER_ID	libusb/libusb.h	/^	LIBUSB_BT_CONTAINER_ID				= 4,$/;"	e	enum:libusb_bos_type
LIBUSB_BT_CONTAINER_ID_SIZE	libusb/libusb.h	303;"	d
LIBUSB_BT_SS_USB_DEVICE_CAPABILITY	libusb/libusb.h	/^	LIBUSB_BT_SS_USB_DEVICE_CAPABILITY		= 3,$/;"	e	enum:libusb_bos_type
LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE	libusb/libusb.h	302;"	d
LIBUSB_BT_USB_2_0_EXTENSION	libusb/libusb.h	/^	LIBUSB_BT_USB_2_0_EXTENSION			= 2,$/;"	e	enum:libusb_bos_type
LIBUSB_BT_USB_2_0_EXTENSION_SIZE	libusb/libusb.h	301;"	d
LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY	libusb/libusb.h	/^	LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY	= 1,$/;"	e	enum:libusb_bos_type
LIBUSB_CALL	libusb/libusb.h	119;"	d
LIBUSB_CALL	libusb/libusb.h	121;"	d
LIBUSB_CAP_HAS_CAPABILITY	libusb/libusb.h	/^	LIBUSB_CAP_HAS_CAPABILITY = 0x0000,$/;"	e	enum:libusb_capability
LIBUSB_CAP_HAS_HID_ACCESS	libusb/libusb.h	/^	LIBUSB_CAP_HAS_HID_ACCESS = 0x0100,$/;"	e	enum:libusb_capability
LIBUSB_CAP_HAS_HOTPLUG	libusb/libusb.h	/^	LIBUSB_CAP_HAS_HOTPLUG = 0x0001,$/;"	e	enum:libusb_capability
LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER	libusb/libusb.h	/^	LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER = 0x0101$/;"	e	enum:libusb_capability
LIBUSB_CLASS_APPLICATION	libusb/libusb.h	/^	LIBUSB_CLASS_APPLICATION = 0xfe,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_AUDIO	libusb/libusb.h	/^	LIBUSB_CLASS_AUDIO = 1,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_COMM	libusb/libusb.h	/^	LIBUSB_CLASS_COMM = 2,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_CONTENT_SECURITY	libusb/libusb.h	/^	LIBUSB_CLASS_CONTENT_SECURITY = 0x0d,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_DATA	libusb/libusb.h	/^	LIBUSB_CLASS_DATA = 10,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_DIAGNOSTIC_DEVICE	libusb/libusb.h	/^	LIBUSB_CLASS_DIAGNOSTIC_DEVICE = 0xdc,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_HID	libusb/libusb.h	/^	LIBUSB_CLASS_HID = 3,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_HUB	libusb/libusb.h	/^	LIBUSB_CLASS_HUB = 9,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_IMAGE	libusb/libusb.h	/^	LIBUSB_CLASS_IMAGE = 6,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_MASS_STORAGE	libusb/libusb.h	/^	LIBUSB_CLASS_MASS_STORAGE = 8,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_PERSONAL_HEALTHCARE	libusb/libusb.h	/^	LIBUSB_CLASS_PERSONAL_HEALTHCARE = 0x0f,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_PER_INTERFACE	libusb/libusb.h	/^	LIBUSB_CLASS_PER_INTERFACE = 0,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_PHYSICAL	libusb/libusb.h	/^	LIBUSB_CLASS_PHYSICAL = 5,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_PRINTER	libusb/libusb.h	/^	LIBUSB_CLASS_PRINTER = 7,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_PTP	libusb/libusb.h	/^	LIBUSB_CLASS_PTP = 6, \/* legacy name from libusb-0.1 usb.h *\/$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_SMART_CARD	libusb/libusb.h	/^	LIBUSB_CLASS_SMART_CARD = 0x0b,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_VENDOR_SPEC	libusb/libusb.h	/^	LIBUSB_CLASS_VENDOR_SPEC = 0xff$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_VIDEO	libusb/libusb.h	/^	LIBUSB_CLASS_VIDEO = 0x0e,$/;"	e	enum:libusb_class_code
LIBUSB_CLASS_WIRELESS	libusb/libusb.h	/^	LIBUSB_CLASS_WIRELESS = 0xe0,$/;"	e	enum:libusb_class_code
LIBUSB_CONTROL_SETUP_SIZE	libusb/libusb.h	894;"	d
LIBUSB_DEPRECATED_FOR	libusb/libusb.h	80;"	d
LIBUSB_DEPRECATED_FOR	libusb/libusb.h	83;"	d
LIBUSB_DT_BOS	libusb/libusb.h	/^	LIBUSB_DT_BOS = 0x0f,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_BOS_MAX_SIZE	libusb/libusb.h	306;"	d
LIBUSB_DT_BOS_SIZE	libusb/libusb.h	297;"	d
LIBUSB_DT_CONFIG	libusb/libusb.h	/^	LIBUSB_DT_CONFIG = 0x02,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_CONFIG_SIZE	libusb/libusb.h	291;"	d
LIBUSB_DT_DEVICE	libusb/libusb.h	/^	LIBUSB_DT_DEVICE = 0x01,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_DEVICE_CAPABILITY	libusb/libusb.h	/^	LIBUSB_DT_DEVICE_CAPABILITY = 0x10,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_DEVICE_CAPABILITY_SIZE	libusb/libusb.h	298;"	d
LIBUSB_DT_DEVICE_SIZE	libusb/libusb.h	290;"	d
LIBUSB_DT_ENDPOINT	libusb/libusb.h	/^	LIBUSB_DT_ENDPOINT = 0x05,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_ENDPOINT_AUDIO_SIZE	libusb/libusb.h	294;"	d
LIBUSB_DT_ENDPOINT_SIZE	libusb/libusb.h	293;"	d
LIBUSB_DT_HID	libusb/libusb.h	/^	LIBUSB_DT_HID = 0x21,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_HUB	libusb/libusb.h	/^	LIBUSB_DT_HUB = 0x29,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_HUB_NONVAR_SIZE	libusb/libusb.h	295;"	d
LIBUSB_DT_INTERFACE	libusb/libusb.h	/^	LIBUSB_DT_INTERFACE = 0x04,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_INTERFACE_SIZE	libusb/libusb.h	292;"	d
LIBUSB_DT_PHYSICAL	libusb/libusb.h	/^	LIBUSB_DT_PHYSICAL = 0x23,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_REPORT	libusb/libusb.h	/^	LIBUSB_DT_REPORT = 0x22,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_SS_ENDPOINT_COMPANION	libusb/libusb.h	/^	LIBUSB_DT_SS_ENDPOINT_COMPANION = 0x30$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE	libusb/libusb.h	296;"	d
LIBUSB_DT_STRING	libusb/libusb.h	/^	LIBUSB_DT_STRING = 0x03,$/;"	e	enum:libusb_descriptor_type
LIBUSB_DT_SUPERSPEED_HUB	libusb/libusb.h	/^	LIBUSB_DT_SUPERSPEED_HUB = 0x2a,$/;"	e	enum:libusb_descriptor_type
LIBUSB_ENDPOINT_ADDRESS_MASK	libusb/libusb.h	311;"	d
LIBUSB_ENDPOINT_DIR_MASK	libusb/libusb.h	312;"	d
LIBUSB_ENDPOINT_IN	libusb/libusb.h	/^	LIBUSB_ENDPOINT_IN = 0x80,$/;"	e	enum:libusb_endpoint_direction
LIBUSB_ENDPOINT_OUT	libusb/libusb.h	/^	LIBUSB_ENDPOINT_OUT = 0x00$/;"	e	enum:libusb_endpoint_direction
LIBUSB_ERROR_ACCESS	libusb/libusb.h	/^	LIBUSB_ERROR_ACCESS = -3,$/;"	e	enum:libusb_error
LIBUSB_ERROR_BUSY	libusb/libusb.h	/^	LIBUSB_ERROR_BUSY = -6,$/;"	e	enum:libusb_error
LIBUSB_ERROR_COUNT	libusb/libusb.h	1102;"	d
LIBUSB_ERROR_INTERRUPTED	libusb/libusb.h	/^	LIBUSB_ERROR_INTERRUPTED = -10,$/;"	e	enum:libusb_error
LIBUSB_ERROR_INVALID_PARAM	libusb/libusb.h	/^	LIBUSB_ERROR_INVALID_PARAM = -2,$/;"	e	enum:libusb_error
LIBUSB_ERROR_IO	libusb/libusb.h	/^	LIBUSB_ERROR_IO = -1,$/;"	e	enum:libusb_error
LIBUSB_ERROR_NOT_FOUND	libusb/libusb.h	/^	LIBUSB_ERROR_NOT_FOUND = -5,$/;"	e	enum:libusb_error
LIBUSB_ERROR_NOT_SUPPORTED	libusb/libusb.h	/^	LIBUSB_ERROR_NOT_SUPPORTED = -12,$/;"	e	enum:libusb_error
LIBUSB_ERROR_NO_DEVICE	libusb/libusb.h	/^	LIBUSB_ERROR_NO_DEVICE = -4,$/;"	e	enum:libusb_error
LIBUSB_ERROR_NO_MEM	libusb/libusb.h	/^	LIBUSB_ERROR_NO_MEM = -11,$/;"	e	enum:libusb_error
LIBUSB_ERROR_OTHER	libusb/libusb.h	/^	LIBUSB_ERROR_OTHER = -99,$/;"	e	enum:libusb_error
LIBUSB_ERROR_OVERFLOW	libusb/libusb.h	/^	LIBUSB_ERROR_OVERFLOW = -8,$/;"	e	enum:libusb_error
LIBUSB_ERROR_PIPE	libusb/libusb.h	/^	LIBUSB_ERROR_PIPE = -9,$/;"	e	enum:libusb_error
LIBUSB_ERROR_TIMEOUT	libusb/libusb.h	/^	LIBUSB_ERROR_TIMEOUT = -7,$/;"	e	enum:libusb_error
LIBUSB_FULL_SPEED_OPERATION	libusb/libusb.h	/^	LIBUSB_FULL_SPEED_OPERATION  = 2,$/;"	e	enum:libusb_supported_speed
LIBUSB_H	libusb/libusb.h	25;"	d
LIBUSB_HIGH_SPEED_OPERATION	libusb/libusb.h	/^	LIBUSB_HIGH_SPEED_OPERATION  = 4,$/;"	e	enum:libusb_supported_speed
LIBUSB_HOTPLUG_ENUMERATE	libusb/libusb.h	/^	LIBUSB_HOTPLUG_ENUMERATE = 1<<0,$/;"	e	enum:__anon1
LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED	libusb/libusb.h	/^	LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED = 0x01,$/;"	e	enum:__anon2
LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT	libusb/libusb.h	/^	LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT    = 0x02,$/;"	e	enum:__anon2
LIBUSB_HOTPLUG_MATCH_ANY	libusb/libusb.h	1909;"	d
LIBUSB_HOTPLUG_NO_FLAGS	libusb/libusb.h	/^	LIBUSB_HOTPLUG_NO_FLAGS = 0,$/;"	e	enum:__anon1
LIBUSB_ISO_SYNC_TYPE_ADAPTIVE	libusb/libusb.h	/^	LIBUSB_ISO_SYNC_TYPE_ADAPTIVE = 2,$/;"	e	enum:libusb_iso_sync_type
LIBUSB_ISO_SYNC_TYPE_ASYNC	libusb/libusb.h	/^	LIBUSB_ISO_SYNC_TYPE_ASYNC = 1,$/;"	e	enum:libusb_iso_sync_type
LIBUSB_ISO_SYNC_TYPE_MASK	libusb/libusb.h	433;"	d
LIBUSB_ISO_SYNC_TYPE_NONE	libusb/libusb.h	/^	LIBUSB_ISO_SYNC_TYPE_NONE = 0,$/;"	e	enum:libusb_iso_sync_type
LIBUSB_ISO_SYNC_TYPE_SYNC	libusb/libusb.h	/^	LIBUSB_ISO_SYNC_TYPE_SYNC = 3$/;"	e	enum:libusb_iso_sync_type
LIBUSB_ISO_USAGE_TYPE_DATA	libusb/libusb.h	/^	LIBUSB_ISO_USAGE_TYPE_DATA = 0,$/;"	e	enum:libusb_iso_usage_type
LIBUSB_ISO_USAGE_TYPE_FEEDBACK	libusb/libusb.h	/^	LIBUSB_ISO_USAGE_TYPE_FEEDBACK = 1,$/;"	e	enum:libusb_iso_usage_type
LIBUSB_ISO_USAGE_TYPE_IMPLICIT	libusb/libusb.h	/^	LIBUSB_ISO_USAGE_TYPE_IMPLICIT = 2,$/;"	e	enum:libusb_iso_usage_type
LIBUSB_ISO_USAGE_TYPE_MASK	libusb/libusb.h	454;"	d
LIBUSB_LOG_LEVEL_DEBUG	libusb/libusb.h	/^	LIBUSB_LOG_LEVEL_DEBUG,$/;"	e	enum:libusb_log_level
LIBUSB_LOG_LEVEL_ERROR	libusb/libusb.h	/^	LIBUSB_LOG_LEVEL_ERROR,$/;"	e	enum:libusb_log_level
LIBUSB_LOG_LEVEL_INFO	libusb/libusb.h	/^	LIBUSB_LOG_LEVEL_INFO,$/;"	e	enum:libusb_log_level
LIBUSB_LOG_LEVEL_NONE	libusb/libusb.h	/^	LIBUSB_LOG_LEVEL_NONE = 0,$/;"	e	enum:libusb_log_level
LIBUSB_LOG_LEVEL_WARNING	libusb/libusb.h	/^	LIBUSB_LOG_LEVEL_WARNING,$/;"	e	enum:libusb_log_level
LIBUSB_LOW_SPEED_OPERATION	libusb/libusb.h	/^	LIBUSB_LOW_SPEED_OPERATION   = 1,$/;"	e	enum:libusb_supported_speed
LIBUSB_RECIPIENT_DEVICE	libusb/libusb.h	/^	LIBUSB_RECIPIENT_DEVICE = 0x00,$/;"	e	enum:libusb_request_recipient
LIBUSB_RECIPIENT_ENDPOINT	libusb/libusb.h	/^	LIBUSB_RECIPIENT_ENDPOINT = 0x02,$/;"	e	enum:libusb_request_recipient
LIBUSB_RECIPIENT_INTERFACE	libusb/libusb.h	/^	LIBUSB_RECIPIENT_INTERFACE = 0x01,$/;"	e	enum:libusb_request_recipient
LIBUSB_RECIPIENT_OTHER	libusb/libusb.h	/^	LIBUSB_RECIPIENT_OTHER = 0x03,$/;"	e	enum:libusb_request_recipient
LIBUSB_REQUEST_CLEAR_FEATURE	libusb/libusb.h	/^	LIBUSB_REQUEST_CLEAR_FEATURE = 0x01,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_GET_CONFIGURATION	libusb/libusb.h	/^	LIBUSB_REQUEST_GET_CONFIGURATION = 0x08,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_GET_DESCRIPTOR	libusb/libusb.h	/^	LIBUSB_REQUEST_GET_DESCRIPTOR = 0x06,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_GET_INTERFACE	libusb/libusb.h	/^	LIBUSB_REQUEST_GET_INTERFACE = 0x0A,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_GET_STATUS	libusb/libusb.h	/^	LIBUSB_REQUEST_GET_STATUS = 0x00,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_SET_ADDRESS	libusb/libusb.h	/^	LIBUSB_REQUEST_SET_ADDRESS = 0x05,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_SET_CONFIGURATION	libusb/libusb.h	/^	LIBUSB_REQUEST_SET_CONFIGURATION = 0x09,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_SET_DESCRIPTOR	libusb/libusb.h	/^	LIBUSB_REQUEST_SET_DESCRIPTOR = 0x07,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_SET_FEATURE	libusb/libusb.h	/^	LIBUSB_REQUEST_SET_FEATURE = 0x03,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_SET_INTERFACE	libusb/libusb.h	/^	LIBUSB_REQUEST_SET_INTERFACE = 0x0B,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_SET_SEL	libusb/libusb.h	/^	LIBUSB_REQUEST_SET_SEL = 0x30,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_SYNCH_FRAME	libusb/libusb.h	/^	LIBUSB_REQUEST_SYNCH_FRAME = 0x0C,$/;"	e	enum:libusb_standard_request
LIBUSB_REQUEST_TYPE_CLASS	libusb/libusb.h	/^	LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5),$/;"	e	enum:libusb_request_type
LIBUSB_REQUEST_TYPE_RESERVED	libusb/libusb.h	/^	LIBUSB_REQUEST_TYPE_RESERVED = (0x03 << 5)$/;"	e	enum:libusb_request_type
LIBUSB_REQUEST_TYPE_STANDARD	libusb/libusb.h	/^	LIBUSB_REQUEST_TYPE_STANDARD = (0x00 << 5),$/;"	e	enum:libusb_request_type
LIBUSB_REQUEST_TYPE_VENDOR	libusb/libusb.h	/^	LIBUSB_REQUEST_TYPE_VENDOR = (0x02 << 5),$/;"	e	enum:libusb_request_type
LIBUSB_SET_ISOCH_DELAY	libusb/libusb.h	/^	LIBUSB_SET_ISOCH_DELAY = 0x31,$/;"	e	enum:libusb_standard_request
LIBUSB_SPEED_FULL	libusb/libusb.h	/^	LIBUSB_SPEED_FULL = 2,$/;"	e	enum:libusb_speed
LIBUSB_SPEED_HIGH	libusb/libusb.h	/^	LIBUSB_SPEED_HIGH = 3,$/;"	e	enum:libusb_speed
LIBUSB_SPEED_LOW	libusb/libusb.h	/^	LIBUSB_SPEED_LOW = 1,$/;"	e	enum:libusb_speed
LIBUSB_SPEED_SUPER	libusb/libusb.h	/^	LIBUSB_SPEED_SUPER = 4,$/;"	e	enum:libusb_speed
LIBUSB_SPEED_UNKNOWN	libusb/libusb.h	/^	LIBUSB_SPEED_UNKNOWN = 0,$/;"	e	enum:libusb_speed
LIBUSB_SUCCESS	libusb/libusb.h	/^	LIBUSB_SUCCESS = 0,$/;"	e	enum:libusb_error
LIBUSB_SUPER_SPEED_OPERATION	libusb/libusb.h	/^	LIBUSB_SUPER_SPEED_OPERATION = 8,$/;"	e	enum:libusb_supported_speed
LIBUSB_TRANSFER_ADD_ZERO_PACKET	libusb/libusb.h	/^	LIBUSB_TRANSFER_ADD_ZERO_PACKET = 1 << 3,$/;"	e	enum:libusb_transfer_flags
LIBUSB_TRANSFER_CANCELLED	libusb/libusb.h	/^	LIBUSB_TRANSFER_CANCELLED,$/;"	e	enum:libusb_transfer_status
LIBUSB_TRANSFER_COMPLETED	libusb/libusb.h	/^	LIBUSB_TRANSFER_COMPLETED,$/;"	e	enum:libusb_transfer_status
LIBUSB_TRANSFER_ERROR	libusb/libusb.h	/^	LIBUSB_TRANSFER_ERROR,$/;"	e	enum:libusb_transfer_status
LIBUSB_TRANSFER_FREE_BUFFER	libusb/libusb.h	/^	LIBUSB_TRANSFER_FREE_BUFFER = 1<<1,$/;"	e	enum:libusb_transfer_flags
LIBUSB_TRANSFER_FREE_TRANSFER	libusb/libusb.h	/^	LIBUSB_TRANSFER_FREE_TRANSFER = 1<<2,$/;"	e	enum:libusb_transfer_flags
LIBUSB_TRANSFER_NO_DEVICE	libusb/libusb.h	/^	LIBUSB_TRANSFER_NO_DEVICE,$/;"	e	enum:libusb_transfer_status
LIBUSB_TRANSFER_OVERFLOW	libusb/libusb.h	/^	LIBUSB_TRANSFER_OVERFLOW,$/;"	e	enum:libusb_transfer_status
LIBUSB_TRANSFER_SHORT_NOT_OK	libusb/libusb.h	/^	LIBUSB_TRANSFER_SHORT_NOT_OK = 1<<0,$/;"	e	enum:libusb_transfer_flags
LIBUSB_TRANSFER_STALL	libusb/libusb.h	/^	LIBUSB_TRANSFER_STALL,$/;"	e	enum:libusb_transfer_status
LIBUSB_TRANSFER_TIMED_OUT	libusb/libusb.h	/^	LIBUSB_TRANSFER_TIMED_OUT,$/;"	e	enum:libusb_transfer_status
LIBUSB_TRANSFER_TYPE_BULK	libusb/libusb.h	/^	LIBUSB_TRANSFER_TYPE_BULK = 2,$/;"	e	enum:libusb_transfer_type
LIBUSB_TRANSFER_TYPE_BULK_STREAM	libusb/libusb.h	/^	LIBUSB_TRANSFER_TYPE_BULK_STREAM = 4,$/;"	e	enum:libusb_transfer_type
LIBUSB_TRANSFER_TYPE_CONTROL	libusb/libusb.h	/^	LIBUSB_TRANSFER_TYPE_CONTROL = 0,$/;"	e	enum:libusb_transfer_type
LIBUSB_TRANSFER_TYPE_INTERRUPT	libusb/libusb.h	/^	LIBUSB_TRANSFER_TYPE_INTERRUPT = 3,$/;"	e	enum:libusb_transfer_type
LIBUSB_TRANSFER_TYPE_ISOCHRONOUS	libusb/libusb.h	/^	LIBUSB_TRANSFER_TYPE_ISOCHRONOUS = 1,$/;"	e	enum:libusb_transfer_type
LIBUSB_TRANSFER_TYPE_MASK	libusb/libusb.h	326;"	d
LargestInt	json/json-forwards.h	/^typedef Int64 LargestInt;$/;"	t	namespace:Json
LargestInt	json/json-forwards.h	/^typedef int LargestInt;$/;"	t	namespace:Json
LargestInt	json/json.h	/^  typedef Json::LargestInt LargestInt;$/;"	t	class:Json::Value	access:public
LargestInt	json/json.h	/^typedef Int64 LargestInt;$/;"	t	namespace:Json
LargestInt	json/json.h	/^typedef int LargestInt;$/;"	t	namespace:Json
LargestUInt	json/json-forwards.h	/^typedef UInt64 LargestUInt;$/;"	t	namespace:Json
LargestUInt	json/json-forwards.h	/^typedef unsigned int LargestUInt;$/;"	t	namespace:Json
LargestUInt	json/json.h	/^  typedef Json::LargestUInt LargestUInt;$/;"	t	class:Json::Value	access:public
LargestUInt	json/json.h	/^typedef UInt64 LargestUInt;$/;"	t	namespace:Json
LargestUInt	json/json.h	/^typedef unsigned int LargestUInt;$/;"	t	namespace:Json
Location	json/json.h	/^  typedef const Char* Location;$/;"	t	class:Json::Reader	access:public
LogicError	json/json.h	/^  LogicError(std::string const& msg);$/;"	p	class:Json::LogicError	access:public	signature:(std::string const& msg)
LogicError	json/json.h	/^class JSON_API LogicError : public Exception {$/;"	c	namespace:Json	inherits:Exception
MAX_SUBQUEUE_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t MAX_SUBQUEUE_SIZE = (details::const_numeric_max<size_t>::value - static_cast<size_t>(Traits::MAX_SUBQUEUE_SIZE) < BLOCK_SIZE) ? details::const_numeric_max<size_t>::value : ((static_cast<size_t>(Traits::MAX_SUBQUEUE_SIZE) + (BLOCK_SIZE - 1)) \/ BLOCK_SIZE * BLOCK_SIZE);$/;"	m	class:ConcurrentQueue	access:public
MAX_SUBQUEUE_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t MAX_SUBQUEUE_SIZE = details::const_numeric_max<size_t>::value;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
MOODYCAMEL_CATCH	concurrentqueue/concurrentqueue.h	113;"	d
MOODYCAMEL_CPP11_THREAD_LOCAL_SUPPORTED	concurrentqueue/concurrentqueue.h	148;"	d
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^		FreeList& operator=(FreeList const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	struct:ConcurrentQueue::FreeList	access:public
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^		FreeList(FreeList const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	struct:ConcurrentQueue::FreeList	access:public
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^		ThreadExitNotifier& operator=(ThreadExitNotifier const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	class:moodycamel::details::ThreadExitNotifier	access:private
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^		ThreadExitNotifier(ThreadExitNotifier const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	class:moodycamel::details::ThreadExitNotifier	access:private
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ConcurrentQueue& operator=(ConcurrentQueue const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	class:ConcurrentQueue	access:public
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ConcurrentQueue(ConcurrentQueue const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	class:ConcurrentQueue	access:public
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ConsumerToken& operator=(ConsumerToken const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	struct:ConsumerToken	access:public
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ConsumerToken(ConsumerToken const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	struct:ConsumerToken	access:public
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ProducerToken& operator=(ProducerToken const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	namespace:moodycamel
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ProducerToken(ProducerToken const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	namespace:moodycamel
MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	163;"	d
MOODYCAMEL_EXCEPTIONS_ENABLED	concurrentqueue/concurrentqueue.h	111;"	d
MOODYCAMEL_NOEXCEPT	concurrentqueue/concurrentqueue.h	/^	explicit ConsumerToken(ConsumerToken&& other) MOODYCAMEL_NOEXCEPT$/;"	m	struct:ConsumerToken	access:public
MOODYCAMEL_NOEXCEPT	concurrentqueue/concurrentqueue.h	/^	explicit ProducerToken(ProducerToken&& other) MOODYCAMEL_NOEXCEPT$/;"	m	struct:moodycamel::ProducerToken	access:public
MOODYCAMEL_NOEXCEPT	concurrentqueue/concurrentqueue.h	126;"	d
MOODYCAMEL_NOEXCEPT_ASSIGN	concurrentqueue/concurrentqueue.h	128;"	d
MOODYCAMEL_NOEXCEPT_CTOR	concurrentqueue/concurrentqueue.h	127;"	d
MOODYCAMEL_RETHROW	concurrentqueue/concurrentqueue.h	114;"	d
MOODYCAMEL_THREADLOCAL	concurrentqueue/concurrentqueue.h	93;"	d
MOODYCAMEL_THROW	concurrentqueue/concurrentqueue.h	115;"	d
MOODYCAMEL_TRY	concurrentqueue/concurrentqueue.h	112;"	d
MaxPower	libusb/libusb.h	/^	uint8_t  MaxPower;$/;"	m	struct:libusb_config_descriptor	access:public
Members	json/json.h	/^  typedef std::vector<std::string> Members;$/;"	t	class:Json::Value	access:public
Nodes	json/json.h	/^  typedef std::stack<Value*> Nodes;$/;"	t	class:Json::Reader	access:private
OBSERVERQUEUECONTROLLER_H	queue/observer_queue_controller.h	4;"	d
OBSERVER_H	observer/observable.h	2;"	d
ObjectValues	json/json.h	/^  typedef CppTL::SmallMap<CZString, Value> ObjectValues;$/;"	t	class:Json::Value	access:public
ObjectValues	json/json.h	/^  typedef std::map<CZString, Value> ObjectValues;$/;"	t	class:Json::Value	access:public
Observable	observer/observable.h	/^	Observable() = default;$/;"	p	class:tamgef::observer::Observable	access:public	signature:()
Observable	observer/observable.h	/^	Observable(Observable<T> &&);$/;"	p	class:tamgef::observer::Observable	access:public	signature:(Observable<T> &&)
Observable	observer/observable.h	/^	Observable(Observable<T> const&);$/;"	p	class:tamgef::observer::Observable	access:public	signature:(Observable<T> const&)
Observable	observer/observable.h	/^	Observable(std::initializer_list<std::shared_ptr<IObserver<T>>>);$/;"	p	class:tamgef::observer::Observable	access:public	signature:(std::initializer_list<std::shared_ptr<IObserver<T>>>)
Observable	observer/observable.h	/^Observable<T>::Observable(Observable<T> && other) :$/;"	f	class:tamgef::observer::Observable	signature:(Observable<T> && other)
Observable	observer/observable.h	/^Observable<T>::Observable(Observable<T> const& other) :$/;"	f	class:tamgef::observer::Observable	signature:(Observable<T> const& other)
Observable	observer/observable.h	/^Observable<T>::Observable(std::initializer_list<std::shared_ptr<IObserver<T>>> observers) :$/;"	f	class:tamgef::observer::Observable	signature:(std::initializer_list<std::shared_ptr<IObserver<T>>> observers)
Observable	observer/observable.h	/^class Observable : public IObservable<T>$/;"	c	namespace:tamgef::observer	inherits:IObservable
ObserverQueueController	queue/observer_queue_controller.h	/^	ObserverQueueController($/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:( ObserverQueueController<T> &&)
ObserverQueueController	queue/observer_queue_controller.h	/^	ObserverQueueController($/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:( ObserverQueueController<T> const&)
ObserverQueueController	queue/observer_queue_controller.h	/^	ObserverQueueController() = delete;$/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:()
ObserverQueueController	queue/observer_queue_controller.h	/^	ObserverQueueController(QueueReader<T>, $/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:(QueueReader<T>, std::initializer_list<std::shared_ptr<observer::IObserver<T>>>)
ObserverQueueController	queue/observer_queue_controller.h	/^ObserverQueueController<T>::ObserverQueueController(QueueReader<T> queueReader,$/;"	f	class:tamgef::queue::ObserverQueueController	signature:(QueueReader<T> queueReader, std::initializer_list<std::shared_ptr<observer::IObserver<T>>> observers)
ObserverQueueController	queue/observer_queue_controller.h	/^class ObserverQueueController$/;"	c	namespace:tamgef::queue
OutputDomain	device/device.h	/^	typedef std::function<bool(OutputT)> OutputDomain;$/;"	t	class:tamgef::device::GenericDevice	access:public
Path	json/json.h	/^  Path(const std::string& path,$/;"	p	class:Json::Path	access:public	signature:(const std::string& path, const PathArgument& a1 = PathArgument(), const PathArgument& a2 = PathArgument(), const PathArgument& a3 = PathArgument(), const PathArgument& a4 = PathArgument(), const PathArgument& a5 = PathArgument())
Path	json/json.h	/^class JSON_API Path {$/;"	c	namespace:Json
PathArgument	json/json.h	/^  PathArgument();$/;"	p	class:Json::PathArgument	access:public	signature:()
PathArgument	json/json.h	/^  PathArgument(ArrayIndex index);$/;"	p	class:Json::PathArgument	access:public	signature:(ArrayIndex index)
PathArgument	json/json.h	/^  PathArgument(const char* key);$/;"	p	class:Json::PathArgument	access:public	signature:(const char* key)
PathArgument	json/json.h	/^  PathArgument(const std::string& key);$/;"	p	class:Json::PathArgument	access:public	signature:(const std::string& key)
PathArgument	json/json.h	/^class JSON_API PathArgument {$/;"	c	namespace:Json
ProducerBase	concurrentqueue/concurrentqueue.h	/^		ProducerBase(ConcurrentQueue* parent, bool isExplicit) :$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:(ConcurrentQueue* parent, bool isExplicit)
ProducerBase	concurrentqueue/concurrentqueue.h	/^	struct ProducerBase : public details::ConcurrentQueueProducerTypelessBase$/;"	s	class:ConcurrentQueue	inherits:details::ConcurrentQueueProducerTypelessBase	access:private
ProducerToken	concurrentqueue/concurrentqueue.h	/^	explicit ProducerToken(BlockingConcurrentQueue<T, Traits>& queue);$/;"	p	struct:moodycamel::ProducerToken	access:public	signature:(BlockingConcurrentQueue<T, Traits>& queue)
ProducerToken	concurrentqueue/concurrentqueue.h	/^	explicit ProducerToken(ConcurrentQueue<T, Traits>& queue);$/;"	p	struct:moodycamel::ProducerToken	access:public	signature:(ConcurrentQueue<T, Traits>& queue)
ProducerToken	concurrentqueue/concurrentqueue.h	/^ProducerToken::ProducerToken(BlockingConcurrentQueue<T, Traits>& queue)$/;"	f	class:ConcurrentQueue::ImplicitProducer::ProducerToken	access:public	signature:(BlockingConcurrentQueue<T, Traits>& queue)
ProducerToken	concurrentqueue/concurrentqueue.h	/^ProducerToken::ProducerToken(ConcurrentQueue<T, Traits>& queue)$/;"	f	class:ConcurrentQueue::ImplicitProducer::ProducerToken	access:public	signature:(ConcurrentQueue<T, Traits>& queue)
ProducerToken	concurrentqueue/concurrentqueue.h	/^struct ProducerToken$/;"	s	namespace:moodycamel
QUEUE_H	queue/queue.h	2;"	d
QUEUE_POLLER_H	queue/queue_poller.h	2;"	d
QUEUE_READER_H	queue/queue_reader.h	2;"	d
Queue	queue/queue.h	/^class Queue : public IQueue<T>$/;"	c	namespace:tamgef::queue	inherits:IQueue
QueuePoller	queue/queue_poller.h	/^	QueuePoller(QueuePoller<T> &&);$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:(QueuePoller<T> &&)
QueuePoller	queue/queue_poller.h	/^	QueuePoller(QueuePoller<T> const&);$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:(QueuePoller<T> const&)
QueuePoller	queue/queue_poller.h	/^	QueuePoller(QueueReader<T> &);$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:(QueueReader<T> &)
QueuePoller	queue/queue_poller.h	/^QueuePoller<T>::QueuePoller($/;"	f	class:tamgef::queue::QueuePoller	signature:( QueueReader<T> & queueReader, std::function<void(T) handler)
QueuePoller	queue/queue_poller.h	/^QueuePoller<T>::QueuePoller(QueuePoller<T> && other) :$/;"	f	class:tamgef::queue::QueuePoller	signature:(QueuePoller<T> && other)
QueuePoller	queue/queue_poller.h	/^QueuePoller<T>::QueuePoller(QueuePoller<T> const& other) :$/;"	f	class:tamgef::queue::QueuePoller	signature:(QueuePoller<T> const& other)
QueuePoller	queue/queue_poller.h	/^class QueuePoller$/;"	c	namespace:tamgef::queue
QueueReader	queue/queue_reader.h	/^	QueueReader() = default;$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
QueueReader	queue/queue_reader.h	/^	QueueReader(QueueReader<T> &&);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(QueueReader<T> &&)
QueueReader	queue/queue_reader.h	/^	QueueReader(QueueReader<T> const&);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(QueueReader<T> const&)
QueueReader	queue/queue_reader.h	/^	QueueReader(std::shared_ptr<IQueue<T>>);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(std::shared_ptr<IQueue<T>>)
QueueReader	queue/queue_reader.h	/^QueueReader<T>::QueueReader(QueueReader<T> && other)$/;"	f	class:tamgef::queue::QueueReader	signature:(QueueReader<T> && other)
QueueReader	queue/queue_reader.h	/^QueueReader<T>::QueueReader(QueueReader<T> const& other) :$/;"	f	class:tamgef::queue::QueueReader	signature:(QueueReader<T> const& other)
QueueReader	queue/queue_reader.h	/^QueueReader<T>::QueueReader(std::shared_ptr<IQueue<T>> queue) :$/;"	f	class:tamgef::queue::QueueReader	signature:(std::shared_ptr<IQueue<T>> queue)
QueueReader	queue/queue_reader.h	/^class QueueReader$/;"	c	namespace:tamgef::queue
REFS_MASK	concurrentqueue/concurrentqueue.h	/^	static const std::uint32_t REFS_MASK = 0x7FFFFFFF;$/;"	m	struct:ConcurrentQueue::FreeList	access:private
Reader	json/json.h	/^  Reader();$/;"	p	class:Json::Reader	access:public	signature:()
Reader	json/json.h	/^  Reader(const Features& features);$/;"	p	class:Json::Reader	access:public	signature:(const Features& features)
Reader	json/json.h	/^class JSON_API Reader {$/;"	c	namespace:Json
ResolutionFunction	device/device.h	/^	typedef std::function<OutputT(InputT)> ResolutionFunction;$/;"	t	class:tamgef::device::GenericDevice	access:public
RuntimeError	json/json.h	/^  RuntimeError(std::string const& msg);$/;"	p	class:Json::RuntimeError	access:public	signature:(std::string const& msg)
RuntimeError	json/json.h	/^class JSON_API RuntimeError : public Exception {$/;"	c	namespace:Json	inherits:Exception
SHOULD_BE_ON_FREELIST	concurrentqueue/concurrentqueue.h	/^	static const std::uint32_t SHOULD_BE_ON_FREELIST = 0x80000000;$/;"	m	struct:ConcurrentQueue::FreeList	access:private
STATES_H	device/state_machine.h	2;"	d
SelfType	json/json.h	/^  typedef ValueConstIterator SelfType;$/;"	t	class:Json::ValueConstIterator	access:public
SelfType	json/json.h	/^  typedef ValueIterator SelfType;$/;"	t	class:Json::ValueIterator	access:public
SelfType	json/json.h	/^  typedef ValueIteratorBase SelfType;$/;"	t	class:Json::ValueIteratorBase	access:public
StateFunction	device/device.h	/^		StateFunction;$/;"	t	class:tamgef::device::GenericDevice	access:public
StateMachine	device/state_machine.h	/^	StateMachine();$/;"	p	class:tamgef::device::StateMachine	access:public	signature:()
StateMachine	device/state_machine.h	/^	StateMachine(StateMachine const&) = delete;$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(StateMachine const&)
StateMachine	device/state_machine.h	/^	StateMachine(StateMachine&&);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(StateMachine&&)
StateMachine	device/state_machine.h	/^StateMachine<T>::StateMachine() :$/;"	f	class:tamgef::device::StateMachine	signature:()
StateMachine	device/state_machine.h	/^class StateMachine$/;"	c	namespace:tamgef::device
StaticString	json/json.h	/^  explicit StaticString(const char* czstring) : c_str_(czstring) {}$/;"	f	class:Json::StaticString	access:public	signature:(const char* czstring)
StaticString	json/json.h	/^class JSON_API StaticString {$/;"	c	namespace:Json
StreamWriter	json/json.h	/^  StreamWriter();$/;"	p	class:Json::StreamWriter	access:public	signature:()
StreamWriter	json/json.h	/^class JSON_API StreamWriter {$/;"	c	namespace:Json
StreamWriterBuilder	json/json.h	/^  StreamWriterBuilder();$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:()
StreamWriterBuilder	json/json.h	/^class JSON_API StreamWriterBuilder : public StreamWriter::Factory {$/;"	c	namespace:Json	inherits:StreamWriter::Factory
StringStorage	json/json.h	/^    struct StringStorage {$/;"	s	class:Json::Value::CZString	access:private
StructuredError	json/json.h	/^  struct StructuredError {$/;"	s	class:Json::Reader	access:public
StyledStreamWriter	json/json.h	/^  StyledStreamWriter(std::string indentation = "\\t");$/;"	p	class:Json::StyledStreamWriter	access:public	signature:(std::string indentation = Ó)
StyledStreamWriter	json/json.h	/^class JSON_API StyledStreamWriter {$/;"	c	namespace:Json
StyledWriter	json/json.h	/^  StyledWriter();$/;"	p	class:Json::StyledWriter	access:public	signature:()
StyledWriter	json/json.h	/^class JSON_API StyledWriter : public Writer {$/;"	c	namespace:Json	inherits:Writer
ThreadExitListener	concurrentqueue/concurrentqueue.h	/^	struct ThreadExitListener$/;"	s	namespace:moodycamel::details
ThreadExitListener	concurrentqueue/concurrentqueue.h	/^	typedef RelacyThreadExitListener ThreadExitListener;$/;"	t	namespace:moodycamel::details
ThreadExitNotifier	concurrentqueue/concurrentqueue.h	/^		ThreadExitNotifier() : tail(nullptr) { }$/;"	f	class:moodycamel::details::ThreadExitNotifier	access:private	signature:()
ThreadExitNotifier	concurrentqueue/concurrentqueue.h	/^	class ThreadExitNotifier$/;"	c	namespace:moodycamel::details
ThreadExitNotifier	concurrentqueue/concurrentqueue.h	/^	typedef RelacyThreadExitNotifier ThreadExitNotifier;$/;"	t	namespace:moodycamel::details
Token	json/json.h	/^  class Token {$/;"	c	class:Json::Reader	access:private
TokenType	json/json.h	/^  enum TokenType {$/;"	g	class:Json::Reader	access:private
UInt	json/json-forwards.h	/^typedef unsigned int UInt;$/;"	t	namespace:Json
UInt	json/json.h	/^  typedef Json::UInt UInt;$/;"	t	class:Json::Value	access:public
UInt	json/json.h	/^typedef unsigned int UInt;$/;"	t	namespace:Json
UInt64	json/json-forwards.h	/^typedef unsigned __int64 UInt64;$/;"	t	namespace:Json
UInt64	json/json-forwards.h	/^typedef unsigned long long int UInt64;$/;"	t	namespace:Json
UInt64	json/json.h	/^  typedef Json::UInt64 UInt64;$/;"	t	class:Json::Value	access:public
UInt64	json/json.h	/^typedef unsigned __int64 UInt64;$/;"	t	namespace:Json
UInt64	json/json.h	/^typedef unsigned long long int UInt64;$/;"	t	namespace:Json
USBWriter	device/usb_writer.h	/^class USBWriter$/;"	c	namespace:tamgef::device
USB_WRITER_H	device/usb_writer.h	2;"	d
Value	json/json.h	/^  Value(Int value);$/;"	p	class:Json::Value	access:public	signature:(Int value)
Value	json/json.h	/^  Value(Int64 value);$/;"	p	class:Json::Value	access:public	signature:(Int64 value)
Value	json/json.h	/^  Value(UInt value);$/;"	p	class:Json::Value	access:public	signature:(UInt value)
Value	json/json.h	/^  Value(UInt64 value);$/;"	p	class:Json::Value	access:public	signature:(UInt64 value)
Value	json/json.h	/^  Value(ValueType type = nullValue);$/;"	p	class:Json::Value	access:public	signature:(ValueType type = nullValue)
Value	json/json.h	/^  Value(bool value);$/;"	p	class:Json::Value	access:public	signature:(bool value)
Value	json/json.h	/^  Value(const CppTL::ConstString& value);$/;"	p	class:Json::Value	access:public	signature:(const CppTL::ConstString& value)
Value	json/json.h	/^  Value(const StaticString& value);$/;"	p	class:Json::Value	access:public	signature:(const StaticString& value)
Value	json/json.h	/^  Value(const Value& other);$/;"	p	class:Json::Value	access:public	signature:(const Value& other)
Value	json/json.h	/^  Value(const char* begin, const char* end); \/\/\/< Copy all, incl zeroes.$/;"	p	class:Json::Value	access:public	signature:(const char* begin, const char* end)
Value	json/json.h	/^  Value(const char* value); \/\/\/< Copy til first 0. (NULL causes to seg-fault.)$/;"	p	class:Json::Value	access:public	signature:(const char* value)
Value	json/json.h	/^  Value(const std::string& value); \/\/\/< Copy data() til size(). Embedded zeroes too.$/;"	p	class:Json::Value	access:public	signature:(const std::string& value)
Value	json/json.h	/^  Value(double value);$/;"	p	class:Json::Value	access:public	signature:(double value)
Value	json/json.h	/^class JSON_API Value {$/;"	c	namespace:Json
ValueConstIterator	json/json.h	/^  ValueConstIterator();$/;"	p	class:Json::ValueConstIterator	access:public	signature:()
ValueConstIterator	json/json.h	/^  explicit ValueConstIterator(const Value::ObjectValues::iterator& current);$/;"	p	class:Json::ValueConstIterator	access:private	signature:(const Value::ObjectValues::iterator& current)
ValueConstIterator	json/json.h	/^class JSON_API ValueConstIterator : public ValueIteratorBase {$/;"	c	namespace:Json	inherits:ValueIteratorBase
ValueHolder	json/json.h	/^  union ValueHolder {$/;"	u	class:Json::Value	access:private
ValueIterator	json/json.h	/^  ValueIterator();$/;"	p	class:Json::ValueIterator	access:public	signature:()
ValueIterator	json/json.h	/^  ValueIterator(const ValueConstIterator& other);$/;"	p	class:Json::ValueIterator	access:public	signature:(const ValueConstIterator& other)
ValueIterator	json/json.h	/^  ValueIterator(const ValueIterator& other);$/;"	p	class:Json::ValueIterator	access:public	signature:(const ValueIterator& other)
ValueIterator	json/json.h	/^  explicit ValueIterator(const Value::ObjectValues::iterator& current);$/;"	p	class:Json::ValueIterator	access:private	signature:(const Value::ObjectValues::iterator& current)
ValueIterator	json/json.h	/^class JSON_API ValueIterator : public ValueIteratorBase {$/;"	c	namespace:Json	inherits:ValueIteratorBase
ValueIteratorBase	json/json.h	/^  ValueIteratorBase();$/;"	p	class:Json::ValueIteratorBase	access:public	signature:()
ValueIteratorBase	json/json.h	/^  explicit ValueIteratorBase(const Value::ObjectValues::iterator& current);$/;"	p	class:Json::ValueIteratorBase	access:public	signature:(const Value::ObjectValues::iterator& current)
ValueIteratorBase	json/json.h	/^class JSON_API ValueIteratorBase {$/;"	c	namespace:Json
ValueType	json/json.h	/^enum ValueType {$/;"	g	namespace:Json
Writer	json/json.h	/^class JSON_API Writer {$/;"	c	namespace:Json
_SSIZE_T_DEFINED	libusb/libusb.h	34;"	d
_hash_32_or_64	concurrentqueue/concurrentqueue.h	/^	template<> struct _hash_32_or_64<1> {$/;"	s	namespace:moodycamel::details
_hash_32_or_64	concurrentqueue/concurrentqueue.h	/^	template<bool use32> struct _hash_32_or_64 {$/;"	s	namespace:moodycamel::details
actual_length	libusb/libusb.h	/^	int actual_length;$/;"	m	struct:libusb_transfer	access:public
actual_length	libusb/libusb.h	/^	unsigned int actual_length;$/;"	m	struct:libusb_iso_packet_descriptor	access:public
add	concurrentqueue/concurrentqueue.h	/^		inline void add(N* node)$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:(N* node)
addChildValues_	json/json.h	/^  bool addChildValues_;$/;"	m	class:Json::StyledWriter	access:private
addComment	json/json.h	/^  void addComment(Location begin, Location end, CommentPlacement placement);$/;"	p	class:Json::Reader	access:private	signature:(Location begin, Location end, CommentPlacement placement)
addError	json/json.h	/^  bool addError(const std::string& message, Token& token, Location extra = 0);$/;"	p	class:Json::Reader	access:private	signature:(const std::string& message, Token& token, Location extra = 0)
addErrorAndRecover	json/json.h	/^  bool addErrorAndRecover(const std::string& message,$/;"	p	class:Json::Reader	access:private	signature:(const std::string& message, Token& token, TokenType skipUntilToken)
addPathInArg	json/json.h	/^  void addPathInArg(const std::string& path,$/;"	p	class:Json::Path	access:private	signature:(const std::string& path, const InArgs& in, InArgs::const_iterator& itInArg, PathArgument::Kind kind)
addState	device/state_machine.h	/^	bool addState(std::string const& stateName);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& stateName)
addState	device/state_machine.h	/^	bool addState(std::string const& stateName,$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& stateName, std::function<T> const& stateEvent)
addState	device/state_machine.h	/^bool StateMachine<T>::addState(std::string const& stateName)$/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& stateName)
addState	device/state_machine.h	/^bool StateMachine<T>::addState(std::string const& stateName, $/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& stateName, std::function<T> const& stateEvent)
addTransition	device/state_machine.h	/^	bool addTransition(std::string const& fromStateName,$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& fromStateName, std::string const& toStateName)
addTransition	device/state_machine.h	/^	bool addTransition(std::string const& fromStateName,$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& fromStateName, std::string const& toStateName, std::function<bool()> const& transitionPredicate)
addTransition	device/state_machine.h	/^bool StateMachine<T>::addTransition(std::string const& fromState, $/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& fromState, std::string const& toState)
addTransition	device/state_machine.h	/^bool StateMachine<T>::addTransition(std::string const& fromState, $/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& fromState, std::string const& toState, std::function<bool()> const& transitionPredicate)
add_knowing_refcount_is_zero	concurrentqueue/concurrentqueue.h	/^		inline void add_knowing_refcount_is_zero(N* node)$/;"	f	struct:ConcurrentQueue::FreeList	access:private	signature:(N* node)
align_for	concurrentqueue/concurrentqueue.h	/^	static inline char* align_for(char* ptr)$/;"	f	namespace:moodycamel::details	signature:(char* ptr)
all	json/json.h	/^  static Features all();$/;"	p	class:Json::Features	access:public	signature:()
allowComments_	json/json.h	/^  bool allowComments_;$/;"	m	class:Json::Features	access:public
allowDroppedNullPlaceholders_	json/json.h	/^  bool allowDroppedNullPlaceholders_;$/;"	m	class:Json::Features	access:public
allowNumericKeys_	json/json.h	/^  bool allowNumericKeys_;$/;"	m	class:Json::Features	access:public
altsetting	libusb/libusb.h	/^	const struct libusb_interface_descriptor *altsetting;$/;"	m	struct:libusb_interface	typeref:struct:libusb_interface::libusb_interface_descriptor	access:public
append	json/json.h	/^  Value& append(const Value& value);$/;"	p	class:Json::Value	access:public	signature:(const Value& value)
args_	json/json.h	/^  Args args_;$/;"	m	class:Json::Path	access:private
arrayValue	json/json.h	/^  arrayValue,    \/\/\/< array value (ordered list)$/;"	e	enum:Json::ValueType
asBool	json/json.h	/^  bool asBool() const;$/;"	p	class:Json::Value	access:public	signature:() const
asCString	json/json.h	/^  const char* asCString() const; \/\/\/< Embedded zeroes could cause you trouble!$/;"	p	class:Json::Value	access:public	signature:() const
asConstString	json/json.h	/^  CppTL::ConstString asConstString() const;$/;"	p	class:Json::Value	access:public	signature:() const
asDouble	json/json.h	/^  double asDouble() const;$/;"	p	class:Json::Value	access:public	signature:() const
asFloat	json/json.h	/^  float asFloat() const;$/;"	p	class:Json::Value	access:public	signature:() const
asInt	json/json.h	/^  Int asInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
asInt64	json/json.h	/^  Int64 asInt64() const;$/;"	p	class:Json::Value	access:public	signature:() const
asLargestInt	json/json.h	/^  LargestInt asLargestInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
asLargestUInt	json/json.h	/^  LargestUInt asLargestUInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
asString	json/json.h	/^  std::string asString() const; \/\/\/< Embedded zeroes are possible.$/;"	p	class:Json::Value	access:public	signature:() const
asUInt	json/json.h	/^  UInt asUInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
asUInt64	json/json.h	/^  UInt64 asUInt64() const;$/;"	p	class:Json::Value	access:public	signature:() const
attachObserver	observer/iobservable.h	/^	virtual void attachObserver($/;"	p	class:tamgef::observer::IObservable	access:public	signature:( std::shared_ptr<IObserver<T>> observer)
attachObserver	observer/observable.h	/^	virtual void attachObserver(std::initializer_list<std::shared_ptr<IObserver<T>>>);$/;"	p	class:tamgef::observer::Observable	access:public	signature:(std::initializer_list<std::shared_ptr<IObserver<T>>>)
attachObserver	observer/observable.h	/^void Observable<T>::attachObserver($/;"	f	class:tamgef::observer::Observable	signature:( std::initializer_list<std::shared_ptr<IObserver<T>>> observers)
attachObserver	observer/observable.h	/^void Observable<T>::attachObserver($/;"	f	class:tamgef::observer::Observable	signature:( std::shared_ptr<IObserver<T>> observer)
attachObserver	queue/observer_queue_controller.h	/^	void attachObserver(std::shared_ptr<observer::IObserver<T>>);$/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:(std::shared_ptr<observer::IObserver<T>>)
attachObserver	queue/observer_queue_controller.h	/^void ObserverQueueController<T>::attachObserver($/;"	f	class:tamgef::queue::ObserverQueueController	signature:( std::shared_ptr<observer::IObserver<T>> observer_ptr)
bAlternateSetting	libusb/libusb.h	/^	uint8_t  bAlternateSetting;$/;"	m	struct:libusb_interface_descriptor	access:public
bConfigurationValue	libusb/libusb.h	/^	uint8_t  bConfigurationValue;$/;"	m	struct:libusb_config_descriptor	access:public
bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_bos_descriptor	access:public
bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_config_descriptor	access:public
bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_container_id_descriptor	access:public
bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_device_descriptor	access:public
bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_endpoint_descriptor	access:public
bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_interface_descriptor	access:public
bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_ss_endpoint_companion_descriptor	access:public
bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_usb_2_0_extension_descriptor	access:public
bDescriptorType	libusb/libusb.h	/^	uint8_t bDescriptorType;$/;"	m	struct:libusb_bos_dev_capability_descriptor	access:public
bDevCapabilityType	libusb/libusb.h	/^	uint8_t  bDevCapabilityType;$/;"	m	struct:libusb_container_id_descriptor	access:public
bDevCapabilityType	libusb/libusb.h	/^	uint8_t  bDevCapabilityType;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
bDevCapabilityType	libusb/libusb.h	/^	uint8_t  bDevCapabilityType;$/;"	m	struct:libusb_usb_2_0_extension_descriptor	access:public
bDevCapabilityType	libusb/libusb.h	/^	uint8_t bDevCapabilityType;$/;"	m	struct:libusb_bos_dev_capability_descriptor	access:public
bDeviceClass	libusb/libusb.h	/^	uint8_t  bDeviceClass;$/;"	m	struct:libusb_device_descriptor	access:public
bDeviceProtocol	libusb/libusb.h	/^	uint8_t  bDeviceProtocol;$/;"	m	struct:libusb_device_descriptor	access:public
bDeviceSubClass	libusb/libusb.h	/^	uint8_t  bDeviceSubClass;$/;"	m	struct:libusb_device_descriptor	access:public
bEndpointAddress	libusb/libusb.h	/^	uint8_t  bEndpointAddress;$/;"	m	struct:libusb_endpoint_descriptor	access:public
bFunctionalitySupport	libusb/libusb.h	/^	uint8_t  bFunctionalitySupport;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
bInterfaceClass	libusb/libusb.h	/^	uint8_t  bInterfaceClass;$/;"	m	struct:libusb_interface_descriptor	access:public
bInterfaceNumber	libusb/libusb.h	/^	uint8_t  bInterfaceNumber;$/;"	m	struct:libusb_interface_descriptor	access:public
bInterfaceProtocol	libusb/libusb.h	/^	uint8_t  bInterfaceProtocol;$/;"	m	struct:libusb_interface_descriptor	access:public
bInterfaceSubClass	libusb/libusb.h	/^	uint8_t  bInterfaceSubClass;$/;"	m	struct:libusb_interface_descriptor	access:public
bInterval	libusb/libusb.h	/^	uint8_t  bInterval;$/;"	m	struct:libusb_endpoint_descriptor	access:public
bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_bos_descriptor	access:public
bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_config_descriptor	access:public
bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_container_id_descriptor	access:public
bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_device_descriptor	access:public
bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_endpoint_descriptor	access:public
bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_interface_descriptor	access:public
bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_ss_endpoint_companion_descriptor	access:public
bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_usb_2_0_extension_descriptor	access:public
bLength	libusb/libusb.h	/^	uint8_t bLength;$/;"	m	struct:libusb_bos_dev_capability_descriptor	access:public
bMaxBurst	libusb/libusb.h	/^	uint8_t  bMaxBurst;$/;"	m	struct:libusb_ss_endpoint_companion_descriptor	access:public
bMaxPacketSize0	libusb/libusb.h	/^	uint8_t  bMaxPacketSize0;$/;"	m	struct:libusb_device_descriptor	access:public
bNumConfigurations	libusb/libusb.h	/^	uint8_t  bNumConfigurations;$/;"	m	struct:libusb_device_descriptor	access:public
bNumDeviceCaps	libusb/libusb.h	/^	uint8_t  bNumDeviceCaps;$/;"	m	struct:libusb_bos_descriptor	access:public
bNumEndpoints	libusb/libusb.h	/^	uint8_t  bNumEndpoints;$/;"	m	struct:libusb_interface_descriptor	access:public
bNumInterfaces	libusb/libusb.h	/^	uint8_t  bNumInterfaces;$/;"	m	struct:libusb_config_descriptor	access:public
bRefresh	libusb/libusb.h	/^	uint8_t  bRefresh;$/;"	m	struct:libusb_endpoint_descriptor	access:public
bRequest	libusb/libusb.h	/^	uint8_t  bRequest;$/;"	m	struct:libusb_control_setup	access:public
bReserved	libusb/libusb.h	/^	uint8_t bReserved;$/;"	m	struct:libusb_container_id_descriptor	access:public
bSynchAddress	libusb/libusb.h	/^	uint8_t  bSynchAddress;$/;"	m	struct:libusb_endpoint_descriptor	access:public
bU1DevExitLat	libusb/libusb.h	/^	uint8_t  bU1DevExitLat;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
bU2DevExitLat	libusb/libusb.h	/^	uint16_t bU2DevExitLat;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
base	concurrentqueue/concurrentqueue.h	/^			index_t base;$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexEntry	access:public
bcdDevice	libusb/libusb.h	/^	uint16_t bcdDevice;$/;"	m	struct:libusb_device_descriptor	access:public
bcdUSB	libusb/libusb.h	/^	uint16_t bcdUSB;$/;"	m	struct:libusb_device_descriptor	access:public
begin	json/json.h	/^  const_iterator begin() const;$/;"	p	class:Json::Value	access:public	signature:() const
begin	json/json.h	/^  iterator begin();$/;"	p	class:Json::Value	access:public	signature:()
begin_	json/json.h	/^  Location begin_;$/;"	m	class:Json::Reader	access:private
block	concurrentqueue/concurrentqueue.h	/^			Block* block;$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexEntry	access:public
blockIndex	concurrentqueue/concurrentqueue.h	/^		std::atomic<BlockIndexHeader*> blockIndex;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
bmAttributes	libusb/libusb.h	/^	uint32_t  bmAttributes;$/;"	m	struct:libusb_usb_2_0_extension_descriptor	access:public
bmAttributes	libusb/libusb.h	/^	uint8_t  bmAttributes;$/;"	m	struct:libusb_config_descriptor	access:public
bmAttributes	libusb/libusb.h	/^	uint8_t  bmAttributes;$/;"	m	struct:libusb_endpoint_descriptor	access:public
bmAttributes	libusb/libusb.h	/^	uint8_t  bmAttributes;$/;"	m	struct:libusb_ss_endpoint_companion_descriptor	access:public
bmAttributes	libusb/libusb.h	/^	uint8_t  bmAttributes;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
bmRequestType	libusb/libusb.h	/^	uint8_t  bmRequestType;$/;"	m	struct:libusb_control_setup	access:public
bool_	json/json.h	/^    bool bool_;$/;"	m	union:Json::Value::ValueHolder	access:public
booleanValue	json/json.h	/^  booleanValue,  \/\/\/< bool value$/;"	e	enum:Json::ValueType
buffer	libusb/libusb.h	/^	unsigned char *buffer;$/;"	m	struct:libusb_transfer	access:public
c_str	json/json.h	/^  const char* c_str() const { return c_str_; }$/;"	f	class:Json::StaticString	access:public	signature:() const
c_str_	json/json.h	/^  const char* c_str_;$/;"	m	class:Json::StaticString	access:private
callback	concurrentqueue/concurrentqueue.h	/^		callback_t callback;$/;"	m	struct:moodycamel::details::ThreadExitListener	access:public
callback	libusb/libusb.h	/^	libusb_transfer_cb_fn callback;$/;"	m	struct:libusb_transfer	access:public
callback_t	concurrentqueue/concurrentqueue.h	/^		typedef void (*callback_t)(void*);$/;"	t	struct:moodycamel::details::ThreadExitListener	access:public
ceil_to_pow_2	concurrentqueue/concurrentqueue.h	/^	static inline T ceil_to_pow_2(T x)$/;"	f	namespace:moodycamel::details	signature:(T x)
childValues_	json/json.h	/^  ChildValues childValues_;$/;"	m	class:Json::StyledStreamWriter	access:private
childValues_	json/json.h	/^  ChildValues childValues_;$/;"	m	class:Json::StyledWriter	access:private
circular_less_than	concurrentqueue/concurrentqueue.h	/^	static inline bool circular_less_than(T a, T b)$/;"	f	namespace:moodycamel::details	signature:(T a, T b)
clear	json/json.h	/^  void clear();$/;"	p	class:Json::Value	access:public	signature:()
collectComments_	json/json.h	/^  bool collectComments_;$/;"	m	class:Json::Reader	access:private
combine	device/device.h	/^	combine(GenericDevice<InputT, OutputT, StateT, EventT> const&);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(GenericDevice<InputT, OutputT, StateT, EventT> const&)
combine	device/device.h	/^combine(GenericDevice<InputT, OutputT, StateT, EventT> const& other)$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<InputT, OutputT, StateT, EventT> const& other)
commentAfter	json/json.h	/^  commentAfter, \/\/\/< a comment on the line after a value (only make sense for$/;"	e	enum:Json::CommentPlacement
commentAfterOnSameLine	json/json.h	/^  commentAfterOnSameLine, \/\/\/< a comment just after a value on the same line$/;"	e	enum:Json::CommentPlacement
commentBefore	json/json.h	/^  commentBefore = 0,      \/\/\/< a comment placed on the line before a value$/;"	e	enum:Json::CommentPlacement
comment_	json/json.h	/^    char* comment_;$/;"	m	struct:Json::Value::CommentInfo	access:public
commentsBefore_	json/json.h	/^  std::string commentsBefore_;$/;"	m	class:Json::Reader	access:private
comments_	json/json.h	/^  CommentInfo* comments_;$/;"	m	class:Json::Value	access:private
compare	json/json.h	/^  int compare(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
computeDistance	json/json.h	/^  difference_type computeDistance(const SelfType& other) const;$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:(const SelfType& other) const
connect	device/device.h	/^	void connect(GenericDevice<OtherInputT, InputT, OtherStateT, OtherEventT> const&);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(GenericDevice<OtherInputT, InputT, OtherStateT, OtherEventT> const&)
connect	device/device.h	/^	void connect(QueueReader<Event<EventT>> &);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(QueueReader<Event<EventT>> &)
connect	device/device.h	/^	void connect(QueueReader<InputT>);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(QueueReader<InputT>)
connect	device/device.h	/^	void connect(QueueReader<OutputT> &);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(QueueReader<OutputT> &)
connect	device/device.h	/^connect(GenericDevice<OtherInputT, InputT, OtherStateT, OtherEventT> const& other)$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<OtherInputT, InputT, OtherStateT, OtherEventT> const& other)
connect	device/device.h	/^connect(QueueReader<Event<EventT>> & eventReader)$/;"	f	class:tamgef::device::GenericDevice	signature:(QueueReader<Event<EventT>> & eventReader)
connect	device/device.h	/^connect(QueueReader<InputT> inputConnection)$/;"	f	class:tamgef::device::GenericDevice	signature:(QueueReader<InputT> inputConnection)
connect	device/device.h	/^connect(QueueReader<OutputT> & outputReader) $/;"	f	class:tamgef::device::GenericDevice	signature:(QueueReader<OutputT> & outputReader)
connect	queue/queue_reader.h	/^	void connect(std::shared_ptr<IQueue<T>>);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(std::shared_ptr<IQueue<T>>)
connect	queue/queue_reader.h	/^void QueueReader<T>::connect(std::shared_ptr<IQueue<T>> queue)$/;"	f	class:tamgef::queue::QueueReader	signature:(std::shared_ptr<IQueue<T>> queue)
const_iterator	json/json.h	/^  typedef ValueConstIterator const_iterator;$/;"	t	class:Json::Value	access:public
const_numeric_max	concurrentqueue/concurrentqueue.h	/^	struct const_numeric_max {$/;"	s	namespace:moodycamel::details
consumer_token_t	concurrentqueue/concurrentqueue.h	/^	typedef ::moodycamel::ConsumerToken consumer_token_t;$/;"	t	class:ConcurrentQueue	access:public
copy	json/json.h	/^  void copy(const SelfType& other);$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:(const SelfType& other)
cstr_	json/json.h	/^    char const* cstr_;  \/\/ actually, a prefixed string, unless policy is noDup$/;"	m	class:Json::Value::CZString	access:private
currentProducer	concurrentqueue/concurrentqueue.h	/^		: initialOffset(other.initialOffset), lastKnownGlobalOffset(other.lastKnownGlobalOffset), itemsConsumedFromCurrent(other.itemsConsumedFromCurrent), currentProducer(other.currentProducer), desiredProducer(other.desiredProducer)$/;"	p	struct:ConsumerToken	access:public	signature:(other.currentProducer)
currentProducer	concurrentqueue/concurrentqueue.h	/^	details::ConcurrentQueueProducerTypelessBase* currentProducer;$/;"	m	struct:ConsumerToken	access:private
currentValue	json/json.h	/^  Value& currentValue();$/;"	p	class:Json::Reader	access:private	signature:()
current_	json/json.h	/^  Location current_;$/;"	m	class:Json::Reader	access:private
current_	json/json.h	/^  Value::ObjectValues::iterator current_;$/;"	m	class:Json::ValueIteratorBase	access:private
data	json/json.h	/^    char const* data() const;$/;"	p	class:Json::Value::CZString	access:public	signature:() const
decodeDouble	json/json.h	/^  bool decodeDouble(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
decodeDouble	json/json.h	/^  bool decodeDouble(Token& token, Value& decoded);$/;"	p	class:Json::Reader	access:private	signature:(Token& token, Value& decoded)
decodeNumber	json/json.h	/^  bool decodeNumber(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
decodeNumber	json/json.h	/^  bool decodeNumber(Token& token, Value& decoded);$/;"	p	class:Json::Reader	access:private	signature:(Token& token, Value& decoded)
decodeString	json/json.h	/^  bool decodeString(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
decodeString	json/json.h	/^  bool decodeString(Token& token, std::string& decoded);$/;"	p	class:Json::Reader	access:private	signature:(Token& token, std::string& decoded)
decodeUnicodeCodePoint	json/json.h	/^  bool decodeUnicodeCodePoint(Token& token,$/;"	p	class:Json::Reader	access:private	signature:(Token& token, Location& current, Location end, unsigned int& unicode)
decodeUnicodeEscapeSequence	json/json.h	/^  bool decodeUnicodeEscapeSequence(Token& token,$/;"	p	class:Json::Reader	access:private	signature:(Token& token, Location& current, Location end, unsigned int& unicode)
decrement	json/json.h	/^  void decrement();$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:()
delete	concurrentqueue/concurrentqueue.h	52;"	d
demand	json/json.h	/^  Value const* demand(char const* begin, char const* end);$/;"	p	class:Json::Value	access:public	signature:(char const* begin, char const* end)
dequeue	concurrentqueue/concurrentqueue.h	/^		bool dequeue(U& element)$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:(U& element)
dequeue	concurrentqueue/concurrentqueue.h	/^		inline bool dequeue(U& element)$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:(U& element)
dequeue	queue/iqueue.h	/^	virtual bool dequeue(T & element) = 0;$/;"	p	class:tamgef::queue::IQueue	access:public	signature:(T & element)
dequeue	queue/queue.h	/^bool Queue<T>::dequeue(T& element)$/;"	f	class:tamgef::queue::Queue	signature:(T& element)
dequeue	queue/queue_reader.h	/^	bool dequeue(T &);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(T &)
dequeue	queue/queue_reader.h	/^bool QueueReader<T>::dequeue(T & item)$/;"	f	class:tamgef::queue::QueueReader	signature:(T & item)
dequeueOptimisticCount	concurrentqueue/concurrentqueue.h	/^		std::atomic<index_t> dequeueOptimisticCount;$/;"	m	struct:ConcurrentQueue::ProducerBase	access:protected
dequeueOvercommit	concurrentqueue/concurrentqueue.h	/^		std::atomic<index_t> dequeueOvercommit;$/;"	m	struct:ConcurrentQueue::ProducerBase	access:protected
dequeue_bulk	concurrentqueue/concurrentqueue.h	/^		inline size_t dequeue_bulk(It& itemFirst, size_t max)$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:(It& itemFirst, size_t max)
dequeue_bulk	concurrentqueue/concurrentqueue.h	/^		size_t dequeue_bulk(It& itemFirst, size_t max)$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:(It& itemFirst, size_t max)
deref	json/json.h	/^  Value& deref() const;$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:() const
describe	libusb/libusb.h	/^	const char* describe;$/;"	m	struct:libusb_version	access:public
desiredProducer	concurrentqueue/concurrentqueue.h	/^		: initialOffset(other.initialOffset), lastKnownGlobalOffset(other.lastKnownGlobalOffset), itemsConsumedFromCurrent(other.itemsConsumedFromCurrent), currentProducer(other.currentProducer), desiredProducer(other.desiredProducer)$/;"	f	struct:ConsumerToken	access:public	signature:(other.desiredProducer)
desiredProducer	concurrentqueue/concurrentqueue.h	/^	details::ConcurrentQueueProducerTypelessBase* desiredProducer;$/;"	m	struct:ConsumerToken	access:private
detachObserver	observer/iobservable.h	/^	virtual void detachObserver($/;"	p	class:tamgef::observer::IObservable	access:public	signature:( std::shared_ptr<IObserver<T>> observer)
detachObserver	observer/observable.h	/^void Observable<T>::detachObserver($/;"	f	class:tamgef::observer::Observable	signature:( std::shared_ptr<IObserver<T>> observer)
detachObserver	queue/observer_queue_controller.h	/^	void detachObserver(std::shared_ptr<observer::IObserver<T>>);$/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:(std::shared_ptr<observer::IObserver<T>>)
detachObserver	queue/observer_queue_controller.h	/^void ObserverQueueController<T>::detachObserver($/;"	f	class:tamgef::queue::ObserverQueueController	signature:( std::shared_ptr<observer::IObserver<T>> observer_ptr)
details	concurrentqueue/concurrentqueue.h	/^namespace details {$/;"	n	namespace:moodycamel
details	concurrentqueue/concurrentqueue.h	/^namespace details$/;"	n	namespace:moodycamel
details	concurrentqueue/concurrentqueue.h	/^namespace moodycamel { namespace details {$/;"	n	namespace:moodycamel
dev_capability	libusb/libusb.h	/^	struct libusb_bos_dev_capability_descriptor *dev_capability$/;"	m	struct:libusb_bos_descriptor	typeref:struct:libusb_bos_descriptor::libusb_bos_dev_capability_descriptor	access:public
dev_capability_data	libusb/libusb.h	/^	uint8_t dev_capability_data$/;"	m	struct:libusb_bos_dev_capability_descriptor	access:public
dev_handle	libusb/libusb.h	/^	libusb_device_handle *dev_handle;$/;"	m	struct:libusb_transfer	access:public
device	device/device.h	/^namespace device {$/;"	n	namespace:tamgef
device	device/domain.h	/^namespace device { $/;"	n	namespace:tamgef
device	device/event.h	/^namespace device {$/;"	n	namespace:tamgef
device	device/state_machine.h	/^namespace device {$/;"	n	namespace:tamgef
device	device/usb_writer.h	/^namespace device {$/;"	n	namespace:tamgef
difference_type	json/json.h	/^  typedef int difference_type;$/;"	t	class:Json::ValueIterator	access:public
difference_type	json/json.h	/^  typedef int difference_type;$/;"	t	class:Json::ValueIteratorBase	access:public
disconnect	device/device.h	/^	void disconnect();$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:()
disconnect	device/device.h	/^disconnect()$/;"	f	class:tamgef::device::GenericDevice	signature:()
disconnect	queue/queue_reader.h	/^	void disconnect();$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
disconnect	queue/queue_reader.h	/^void QueueReader<T>::disconnect()$/;"	f	class:tamgef::queue::QueueReader	signature:()
document_	json/json.h	/^  std::ostream* document_;$/;"	m	class:Json::StyledStreamWriter	access:private
document_	json/json.h	/^  std::string document_;$/;"	m	class:Json::FastWriter	access:private
document_	json/json.h	/^  std::string document_;$/;"	m	class:Json::Reader	access:private
document_	json/json.h	/^  std::string document_;$/;"	m	class:Json::StyledWriter	access:private
dropNullPlaceholders	json/json.h	/^  void dropNullPlaceholders();$/;"	p	class:Json::FastWriter	access:public	signature:()
dropNullPlaceholders_	json/json.h	/^  bool dropNullPlaceholders_;$/;"	m	class:Json::FastWriter	access:private
duplicate	json/json.h	/^      duplicate,$/;"	e	enum:Json::Value::CZString::DuplicationPolicy
duplicateOnCopy	json/json.h	/^      duplicateOnCopy$/;"	e	enum:Json::Value::CZString::DuplicationPolicy
dynamicallyAllocated	concurrentqueue/concurrentqueue.h	/^		bool dynamicallyAllocated;		\/\/ Perhaps a better name for this would be 'isNotPartOfInitialBlockPool'$/;"	m	struct:ConcurrentQueue::Block	access:public
elements	concurrentqueue/concurrentqueue.h	/^		char elements[sizeof(T) * BLOCK_SIZE];$/;"	m	struct:ConcurrentQueue::Block	access:private
elementsCompletelyDequeued	concurrentqueue/concurrentqueue.h	/^		std::atomic<size_t> elementsCompletelyDequeued;$/;"	m	struct:ConcurrentQueue::Block	access:public
empty	json/json.h	/^  bool empty() const;$/;"	p	class:Json::Value	access:public	signature:() const
empty	queue/iqueue.h	/^	virtual bool empty() const$/;"	f	class:tamgef::queue::IQueue	access:public	signature:() const
empty	queue/queue_reader.h	/^	bool empty();$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
empty	queue/queue_reader.h	/^bool QueueReader<T>::empty()$/;"	f	class:tamgef::queue::QueueReader	signature:()
emptyFlags	concurrentqueue/concurrentqueue.h	/^		std::atomic<bool> emptyFlags[BLOCK_SIZE <= EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD ? BLOCK_SIZE : 1];$/;"	m	struct:ConcurrentQueue::Block	access:public
enableYAMLCompatibility	json/json.h	/^  void enableYAMLCompatibility();$/;"	p	class:Json::FastWriter	access:public	signature:()
end	json/json.h	/^  const_iterator end() const;$/;"	p	class:Json::Value	access:public	signature:() const
end	json/json.h	/^  iterator end();$/;"	p	class:Json::Value	access:public	signature:()
end_	json/json.h	/^    Location end_;$/;"	m	class:Json::Reader::Token	access:public
end_	json/json.h	/^  Location end_;$/;"	m	class:Json::Reader	access:private
endpoint	libusb/libusb.h	/^	const struct libusb_endpoint_descriptor *endpoint;$/;"	m	struct:libusb_interface_descriptor	typeref:struct:libusb_interface_descriptor::libusb_endpoint_descriptor	access:public
endpoint	libusb/libusb.h	/^	unsigned char endpoint;$/;"	m	struct:libusb_transfer	access:public
enqueue	concurrentqueue/concurrentqueue.h	/^		inline bool enqueue(U&& element)$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:(U&& element)
enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool enqueue(T const& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(T const& item)
enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool enqueue(T&& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(T&& item)
enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool enqueue(producer_token_t const& token, T const& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, T const& item)
enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool enqueue(producer_token_t const& token, T&& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, T&& item)
enqueue	queue/iqueue.h	/^	virtual bool enqueue(T element) = 0;$/;"	p	class:tamgef::queue::IQueue	access:public	signature:(T element)
enqueue	queue/queue.h	/^bool Queue<T>::enqueue(T element)$/;"	f	class:tamgef::queue::Queue	signature:(T element)
enqueue_bulk	concurrentqueue/concurrentqueue.h	/^		bool enqueue_bulk(It itemFirst, size_t count)$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:(It itemFirst, size_t count)
enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	bool enqueue_bulk(It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:public	signature:(It itemFirst, size_t count)
enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	bool enqueue_bulk(producer_token_t const& token, It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, It itemFirst, size_t count)
entries	concurrentqueue/concurrentqueue.h	/^			BlockIndexEntry* entries;$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexHeader	access:public
error	queue/queue_poller.h	/^	std::exception_ptr error();$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:()
error	queue/queue_poller.h	/^std::exception_ptr QueuePoller<T>::error()$/;"	f	class:tamgef::queue::QueuePoller	signature:()
errors_	json/json.h	/^  Errors errors_;$/;"	m	class:Json::Reader	access:private
eval	concurrentqueue/concurrentqueue.h	/^		static inline T const& eval(T const& x)$/;"	f	struct:moodycamel::details::nomove_if	access:public	signature:(T const& x)
events	libusb/libusb.h	/^	short events;$/;"	m	struct:libusb_pollfd	access:public
expired	queue/queue_reader.h	/^	bool expired();$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
expired	queue/queue_reader.h	/^bool QueueReader<T>::expired()$/;"	f	class:tamgef::queue::QueueReader	signature:()
explicit_context	concurrentqueue/concurrentqueue.h	/^	enum InnerQueueContext { implicit_context = 0, explicit_context = 1 };$/;"	e	enum:ConcurrentQueue::InnerQueueContext
extra	libusb/libusb.h	/^	const unsigned char *extra;$/;"	m	struct:libusb_config_descriptor	access:public
extra	libusb/libusb.h	/^	const unsigned char *extra;$/;"	m	struct:libusb_endpoint_descriptor	access:public
extra	libusb/libusb.h	/^	const unsigned char *extra;$/;"	m	struct:libusb_interface_descriptor	access:public
extra_	json/json.h	/^    Location extra_;$/;"	m	class:Json::Reader::ErrorInfo	access:public
extra_length	libusb/libusb.h	/^	int extra_length;$/;"	m	struct:libusb_config_descriptor	access:public
extra_length	libusb/libusb.h	/^	int extra_length;$/;"	m	struct:libusb_endpoint_descriptor	access:public
extra_length	libusb/libusb.h	/^	int extra_length;$/;"	m	struct:libusb_interface_descriptor	access:public
fd	libusb/libusb.h	/^	int fd;$/;"	m	struct:libusb_pollfd	access:public
features_	json/json.h	/^  Features features_;$/;"	m	class:Json::Reader	access:private
find	json/json.h	/^  Value const* find(char const* begin, char const* end) const;$/;"	p	class:Json::Value	access:public	signature:(char const* begin, char const* end) const
flags	libusb/libusb.h	/^	uint8_t flags;$/;"	m	struct:libusb_transfer	access:public
forward	concurrentqueue/concurrentqueue.h	/^			-> decltype(std::forward<U>(x))$/;"	f	struct:moodycamel::details::nomove_if	access:public	signature:(x)
free	concurrentqueue/concurrentqueue.h	/^	static inline void free(void* ptr) { return rl::rl_free(ptr, $); }$/;"	f	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public	signature:(void* ptr)
free	concurrentqueue/concurrentqueue.h	/^	static inline void free(void* ptr) { return std::free(ptr); }$/;"	f	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public	signature:(void* ptr)
free	concurrentqueue/concurrentqueue.h	54;"	d
freeListHead	concurrentqueue/concurrentqueue.h	/^		std::atomic<N*> freeListHead;$/;"	m	struct:ConcurrentQueue::FreeList	access:private
freeListNext	concurrentqueue/concurrentqueue.h	/^		std::atomic<Block*> freeListNext;$/;"	m	struct:ConcurrentQueue::Block	access:public
freeListNext	concurrentqueue/concurrentqueue.h	/^		std::atomic<N*> freeListNext;$/;"	m	struct:ConcurrentQueue::FreeListNode	access:public
freeListRefs	concurrentqueue/concurrentqueue.h	/^		std::atomic<std::uint32_t> freeListRefs;$/;"	m	struct:ConcurrentQueue::Block	access:public
freeListRefs	concurrentqueue/concurrentqueue.h	/^		std::atomic<std::uint32_t> freeListRefs;$/;"	m	struct:ConcurrentQueue::FreeListNode	access:public
front	concurrentqueue/concurrentqueue.h	/^			std::atomic<size_t> front;		\/\/ Current slot (not next, like pr_blockIndexFront)$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexHeader	access:public
get	json/json.h	/^  Value get(ArrayIndex index, const Value& defaultValue) const;$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex index, const Value& defaultValue) const
get	json/json.h	/^  Value get(const CppTL::ConstString& key, const Value& defaultValue) const;$/;"	p	class:Json::Value	access:public	signature:(const CppTL::ConstString& key, const Value& defaultValue) const
get	json/json.h	/^  Value get(const char* begin, const char* end, const Value& defaultValue) const;$/;"	p	class:Json::Value	access:public	signature:(const char* begin, const char* end, const Value& defaultValue) const
get	json/json.h	/^  Value get(const char* key, const Value& defaultValue) const;$/;"	p	class:Json::Value	access:public	signature:(const char* key, const Value& defaultValue) const
get	json/json.h	/^  Value get(const std::string& key, const Value& defaultValue) const;$/;"	p	class:Json::Value	access:public	signature:(const std::string& key, const Value& defaultValue) const
getComment	json/json.h	/^  std::string getComment(CommentPlacement placement) const;$/;"	p	class:Json::Value	access:public	signature:(CommentPlacement placement) const
getFormatedErrorMessages	json/json.h	/^  std::string getFormatedErrorMessages() const;$/;"	p	class:Json::Reader	access:public	signature:() const
getFormattedErrorMessages	json/json.h	/^  std::string getFormattedErrorMessages() const;$/;"	p	class:Json::Reader	access:public	signature:() const
getLocationLineAndColumn	json/json.h	/^  getLocationLineAndColumn(Location location, int& line, int& column) const;$/;"	p	class:Json::Reader	access:private	signature:(Location location, int& line, int& column) const
getLocationLineAndColumn	json/json.h	/^  std::string getLocationLineAndColumn(Location location) const;$/;"	p	class:Json::Reader	access:private	signature:(Location location) const
getMemberNames	json/json.h	/^  Members getMemberNames() const;$/;"	p	class:Json::Value	access:public	signature:() const
getNextChar	json/json.h	/^  Char getNextChar();$/;"	p	class:Json::Reader	access:private	signature:()
getOffsetLimit	json/json.h	/^  size_t getOffsetLimit() const;$/;"	p	class:Json::Value	access:public	signature:() const
getOffsetStart	json/json.h	/^  size_t getOffsetStart() const;$/;"	p	class:Json::Value	access:public	signature:() const
getPresentState	device/state_machine.h	/^	std::string getPresentState() const;$/;"	p	class:tamgef::device::StateMachine	access:public	signature:() const
getPresentState	device/state_machine.h	/^std::string StateMachine<T>::getPresentState() const$/;"	f	class:tamgef::device::StateMachine	signature:() const
getString	json/json.h	/^  bool getString($/;"	p	class:Json::Value	access:public	signature:( char const** begin, char const** end) const
getStructuredErrors	json/json.h	/^  std::vector<StructuredError> getStructuredErrors() const;$/;"	p	class:Json::Reader	access:public	signature:() const
getTail	concurrentqueue/concurrentqueue.h	/^		inline index_t getTail() const { return tailIndex.load(std::memory_order_relaxed); }$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:() const
globalExplicitConsumerOffset	concurrentqueue/concurrentqueue.h	/^		globalExplicitConsumerOffset(other.globalExplicitConsumerOffset.load(std::memory_order_relaxed))$/;"	f	class:ConcurrentQueue	access:public	signature:(other.globalExplicitConsumerOffset.load(std::memory_order_relaxed))
good	json/json.h	/^  bool good() const;$/;"	p	class:Json::Reader	access:public	signature:() const
hasComment	json/json.h	/^  bool hasComment(CommentPlacement placement) const;$/;"	p	class:Json::Value	access:public	signature:(CommentPlacement placement) const
hasCommentForValue	json/json.h	/^  bool hasCommentForValue(const Value& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& value)
hasCommentForValue	json/json.h	/^  bool hasCommentForValue(const Value& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& value)
hash	concurrentqueue/concurrentqueue.h	/^		static inline std::uint32_t hash(std::uint32_t h)$/;"	f	struct:moodycamel::details::_hash_32_or_64	access:public	signature:(std::uint32_t h)
hash	concurrentqueue/concurrentqueue.h	/^		static inline std::uint64_t hash(std::uint64_t h)$/;"	f	struct:moodycamel::details::_hash_32_or_64	access:public	signature:(std::uint64_t h)
hash_32_or_64	concurrentqueue/concurrentqueue.h	/^	template<std::size_t size> struct hash_32_or_64 : public _hash_32_or_64<(size > 4)> {  };$/;"	s	namespace:moodycamel::details	inherits:_hash_32_or_64
hash_thread_id	concurrentqueue/concurrentqueue.h	/^	static inline size_t hash_thread_id(thread_id_t id)$/;"	f	namespace:moodycamel::details	signature:(thread_id_t id)
headIndex	concurrentqueue/concurrentqueue.h	/^		std::atomic<index_t> headIndex;		\/\/ Where to dequeue from next$/;"	m	struct:ConcurrentQueue::ProducerBase	access:protected
head_unsafe	concurrentqueue/concurrentqueue.h	/^		N* head_unsafe() const { return freeListHead.load(std::memory_order_relaxed); }$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:() const
iConfiguration	libusb/libusb.h	/^	uint8_t  iConfiguration;$/;"	m	struct:libusb_config_descriptor	access:public
iInterface	libusb/libusb.h	/^	uint8_t  iInterface;$/;"	m	struct:libusb_interface_descriptor	access:public
iManufacturer	libusb/libusb.h	/^	uint8_t  iManufacturer;$/;"	m	struct:libusb_device_descriptor	access:public
iProduct	libusb/libusb.h	/^	uint8_t  iProduct;$/;"	m	struct:libusb_device_descriptor	access:public
iSerialNumber	libusb/libusb.h	/^	uint8_t  iSerialNumber;$/;"	m	struct:libusb_device_descriptor	access:public
idProduct	libusb/libusb.h	/^	uint16_t idProduct;$/;"	m	struct:libusb_device_descriptor	access:public
idVendor	libusb/libusb.h	/^	uint16_t idVendor;$/;"	m	struct:libusb_device_descriptor	access:public
implicit_context	concurrentqueue/concurrentqueue.h	/^	enum InnerQueueContext { implicit_context = 0, explicit_context = 1 };$/;"	e	enum:ConcurrentQueue::InnerQueueContext
inactive	concurrentqueue/concurrentqueue.h	/^		std::atomic<bool> inactive;$/;"	m	struct:moodycamel::details::ConcurrentQueueProducerTypelessBase	access:public
increment	json/json.h	/^  void increment();$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:()
indent	json/json.h	/^  void indent();$/;"	p	class:Json::StyledStreamWriter	access:private	signature:()
indent	json/json.h	/^  void indent();$/;"	p	class:Json::StyledWriter	access:private	signature:()
indentSize_	json/json.h	/^  int indentSize_;$/;"	m	class:Json::StyledWriter	access:private
indentString_	json/json.h	/^  std::string indentString_;$/;"	m	class:Json::StyledStreamWriter	access:private
indentString_	json/json.h	/^  std::string indentString_;$/;"	m	class:Json::StyledWriter	access:private
indentation_	json/json.h	/^  std::string indentation_;$/;"	m	class:Json::StyledStreamWriter	access:private
index	json/json.h	/^    ArrayIndex index() const;$/;"	p	class:Json::Value::CZString	access:public	signature:() const
index	json/json.h	/^  UInt index() const;$/;"	p	class:Json::ValueIteratorBase	access:public	signature:() const
index_	json/json.h	/^      ArrayIndex index_;$/;"	m	union:Json::Value::CZString::__anon19	access:public
index_	json/json.h	/^  ArrayIndex index_;$/;"	m	class:Json::PathArgument	access:private
index_t	concurrentqueue/concurrentqueue.h	/^	typedef std::size_t index_t;$/;"	t	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
index_t	concurrentqueue/concurrentqueue.h	/^	typedef typename Traits::index_t index_t;$/;"	t	class:ConcurrentQueue	access:public
initBasic	json/json.h	/^  void initBasic(ValueType type, bool allocated = false);$/;"	p	class:Json::Value	access:private	signature:(ValueType type, bool allocated = false)
initialBlockPool	concurrentqueue/concurrentqueue.h	/^		initialBlockPool(other.initialBlockPool),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.initialBlockPool)
initialBlockPoolIndex	concurrentqueue/concurrentqueue.h	/^		initialBlockPoolIndex(other.initialBlockPoolIndex.load(std::memory_order_relaxed)),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.initialBlockPoolIndex.load(std::memory_order_relaxed))
initialBlockPoolSize	concurrentqueue/concurrentqueue.h	/^		initialBlockPoolSize(other.initialBlockPoolSize),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.initialBlockPoolSize)
initialOffset	concurrentqueue/concurrentqueue.h	/^	std::uint32_t initialOffset;$/;"	m	struct:ConsumerToken	access:private
inline	libusb/libusb.h	30;"	d
inner_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool inner_enqueue(U&& element)$/;"	f	class:ConcurrentQueue	access:private	signature:(U&& element)
inner_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool inner_enqueue(producer_token_t const& token, U&& element)$/;"	f	class:ConcurrentQueue	access:private	signature:(producer_token_t const& token, U&& element)
inner_enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	inline bool inner_enqueue_bulk(It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:private	signature:(It itemFirst, size_t count)
inner_enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	inline bool inner_enqueue_bulk(producer_token_t const& token, It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:private	signature:(producer_token_t const& token, It itemFirst, size_t count)
instance	concurrentqueue/concurrentqueue.h	/^		static inline ThreadExitNotifier& instance()$/;"	f	class:moodycamel::details::ThreadExitNotifier	access:private	signature:()
intValue	json/json.h	/^  intValue,      \/\/\/< signed integer value$/;"	e	enum:Json::ValueType
int_	json/json.h	/^    LargestInt int_;$/;"	m	union:Json::Value::ValueHolder	access:public
interface	libusb/libusb.h	/^	const struct libusb_interface *interface;$/;"	m	struct:libusb_config_descriptor	typeref:struct:libusb_config_descriptor::libusb_interface	access:public
interface	libusb/libusb.h	72;"	d
invalidPath	json/json.h	/^  void invalidPath(const std::string& path, int location);$/;"	p	class:Json::Path	access:private	signature:(const std::string& path, int location)
invalid_thread_id	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id  = 0;			\/\/ See http:\/\/blogs.msdn.com\/b\/oldnewthing\/archive\/2004\/02\/23\/78395.aspx$/;"	m	namespace:moodycamel::details
invalid_thread_id	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id  = 0;		\/\/ Address can't be nullptr$/;"	m	namespace:moodycamel::details
invalid_thread_id	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id  = 0xFFFFFFFFU;$/;"	m	namespace:moodycamel::details
invalid_thread_id2	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id2 = 0xFFFFFFFEU;$/;"	m	namespace:moodycamel::details
invalid_thread_id2	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id2 = 0xFFFFFFFFU;	\/\/ Not technically guaranteed to be invalid, but is never used in practice. Note that all Win32 thread IDs are presently multiples of 4.$/;"	m	namespace:moodycamel::details
invalid_thread_id2	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id2 = 1;		\/\/ Member accesses off a null pointer are also generally invalid. Plus it's not aligned.$/;"	m	namespace:moodycamel::details
isArray	json/json.h	/^  bool isArray() const;$/;"	p	class:Json::Value	access:public	signature:() const
isBool	json/json.h	/^  bool isBool() const;$/;"	p	class:Json::Value	access:public	signature:() const
isConvertibleTo	json/json.h	/^  bool isConvertibleTo(ValueType other) const;$/;"	p	class:Json::Value	access:public	signature:(ValueType other) const
isDouble	json/json.h	/^  bool isDouble() const;$/;"	p	class:Json::Value	access:public	signature:() const
isEqual	json/json.h	/^  bool isEqual(const SelfType& other) const;$/;"	p	class:Json::ValueIteratorBase	access:protected	signature:(const SelfType& other) const
isExplicit	concurrentqueue/concurrentqueue.h	/^		bool isExplicit;$/;"	m	struct:ConcurrentQueue::ProducerBase	access:public
isInt	json/json.h	/^  bool isInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
isInt64	json/json.h	/^  bool isInt64() const;$/;"	p	class:Json::Value	access:public	signature:() const
isIntegral	json/json.h	/^  bool isIntegral() const;$/;"	p	class:Json::Value	access:public	signature:() const
isMember	json/json.h	/^  bool isMember(const CppTL::ConstString& key) const;$/;"	p	class:Json::Value	access:public	signature:(const CppTL::ConstString& key) const
isMember	json/json.h	/^  bool isMember(const char* begin, const char* end) const;$/;"	p	class:Json::Value	access:public	signature:(const char* begin, const char* end) const
isMember	json/json.h	/^  bool isMember(const char* key) const;$/;"	p	class:Json::Value	access:public	signature:(const char* key) const
isMember	json/json.h	/^  bool isMember(const std::string& key) const;$/;"	p	class:Json::Value	access:public	signature:(const std::string& key) const
isMultineArray	json/json.h	/^  bool isMultineArray(const Value& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& value)
isMultineArray	json/json.h	/^  bool isMultineArray(const Value& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& value)
isNull	json/json.h	/^  bool isNull() const;$/;"	p	class:Json::Value	access:public	signature:() const
isNull_	json/json.h	/^  bool isNull_;$/;"	m	class:Json::ValueIteratorBase	access:private
isNumeric	json/json.h	/^  bool isNumeric() const;$/;"	p	class:Json::Value	access:public	signature:() const
isObject	json/json.h	/^  bool isObject() const;$/;"	p	class:Json::Value	access:public	signature:() const
isStaticString	json/json.h	/^    bool isStaticString() const;$/;"	p	class:Json::Value::CZString	access:public	signature:() const
isString	json/json.h	/^  bool isString() const;$/;"	p	class:Json::Value	access:public	signature:() const
isUInt	json/json.h	/^  bool isUInt() const;$/;"	p	class:Json::Value	access:public	signature:() const
isUInt64	json/json.h	/^  bool isUInt64() const;$/;"	p	class:Json::Value	access:public	signature:() const
isValidIndex	json/json.h	/^  bool isValidIndex(ArrayIndex index) const;$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex index) const
is_empty	concurrentqueue/concurrentqueue.h	/^		inline bool is_empty() const$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:() const
is_lock_free	concurrentqueue/concurrentqueue.h	/^	static bool is_lock_free()$/;"	f	class:ConcurrentQueue	access:public	signature:()
is_trivially_destructible	concurrentqueue/concurrentqueue.h	/^	template<typename T> struct is_trivially_destructible : std::has_trivial_destructor<T> { };$/;"	s	namespace:moodycamel::details	inherits:std::has_trivial_destructor
is_trivially_destructible	concurrentqueue/concurrentqueue.h	/^	template<typename T> struct is_trivially_destructible : std::is_trivially_destructible<T> { };$/;"	s	namespace:moodycamel::details	inherits:std::is_trivially_destructible
iso_packet_desc	libusb/libusb.h	/^	struct libusb_iso_packet_descriptor iso_packet_desc$/;"	m	struct:libusb_transfer	typeref:struct:libusb_transfer::libusb_iso_packet_descriptor	access:public
itemsConsumedFromCurrent	concurrentqueue/concurrentqueue.h	/^		: initialOffset(other.initialOffset), lastKnownGlobalOffset(other.lastKnownGlobalOffset), itemsConsumedFromCurrent(other.itemsConsumedFromCurrent), currentProducer(other.currentProducer), desiredProducer(other.desiredProducer)$/;"	p	struct:ConsumerToken	access:public	signature:(other.itemsConsumedFromCurrent)
itemsConsumedFromCurrent	concurrentqueue/concurrentqueue.h	/^	std::uint32_t itemsConsumedFromCurrent;$/;"	m	struct:ConsumerToken	access:private
iterator	json/json.h	/^  typedef ValueIterator iterator;$/;"	t	class:Json::Value	access:public
iterator_category	json/json.h	/^  typedef std::bidirectional_iterator_tag iterator_category;$/;"	t	class:Json::ValueIteratorBase	access:public
key	json/json.h	/^  Value key() const;$/;"	p	class:Json::ValueIteratorBase	access:public	signature:() const
key_	json/json.h	/^  std::string key_;$/;"	m	class:Json::PathArgument	access:private
kindIndex	json/json.h	/^    kindIndex,$/;"	e	enum:Json::PathArgument::Kind
kindKey	json/json.h	/^    kindKey$/;"	e	enum:Json::PathArgument::Kind
kindNone	json/json.h	/^    kindNone = 0,$/;"	e	enum:Json::PathArgument::Kind
kind_	json/json.h	/^  Kind kind_;$/;"	m	class:Json::PathArgument	access:private
lastKnownGlobalOffset	concurrentqueue/concurrentqueue.h	/^		: initialOffset(other.initialOffset), lastKnownGlobalOffset(other.lastKnownGlobalOffset), itemsConsumedFromCurrent(other.itemsConsumedFromCurrent), currentProducer(other.currentProducer), desiredProducer(other.desiredProducer)$/;"	p	struct:ConsumerToken	access:public	signature:(other.lastKnownGlobalOffset)
lastKnownGlobalOffset	concurrentqueue/concurrentqueue.h	/^	std::uint32_t lastKnownGlobalOffset;$/;"	m	struct:ConsumerToken	access:private
lastValueEnd_	json/json.h	/^  Location lastValueEnd_;$/;"	m	class:Json::Reader	access:private
lastValue_	json/json.h	/^  Value* lastValue_;$/;"	m	class:Json::Reader	access:private
length	json/json.h	/^    unsigned length() const;$/;"	p	class:Json::Value::CZString	access:public	signature:() const
length	libusb/libusb.h	/^	int length;$/;"	m	struct:libusb_transfer	access:public
length	libusb/libusb.h	/^	unsigned int length;$/;"	m	struct:libusb_iso_packet_descriptor	access:public
length_	json/json.h	/^      unsigned length_: 30; \/\/ 1GB max$/;"	m	struct:Json::Value::CZString::StringStorage	access:public
libusb_alloc_streams	libusb/libusb.h	/^int LIBUSB_CALL libusb_alloc_streams(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, uint32_t num_streams, unsigned char *endpoints, int num_endpoints)
libusb_alloc_transfer	libusb/libusb.h	/^struct libusb_transfer * LIBUSB_CALL libusb_alloc_transfer(int iso_packets);$/;"	p	signature:(int iso_packets)
libusb_attach_kernel_driver	libusb/libusb.h	/^int LIBUSB_CALL libusb_attach_kernel_driver(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, int interface_number)
libusb_bos_descriptor	libusb/libusb.h	/^struct libusb_bos_descriptor {$/;"	s
libusb_bos_descriptor::bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_bos_descriptor	access:public
libusb_bos_descriptor::bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_bos_descriptor	access:public
libusb_bos_descriptor::bNumDeviceCaps	libusb/libusb.h	/^	uint8_t  bNumDeviceCaps;$/;"	m	struct:libusb_bos_descriptor	access:public
libusb_bos_descriptor::dev_capability	libusb/libusb.h	/^	struct libusb_bos_dev_capability_descriptor *dev_capability$/;"	m	struct:libusb_bos_descriptor	typeref:struct:libusb_bos_descriptor::libusb_bos_dev_capability_descriptor	access:public
libusb_bos_descriptor::wTotalLength	libusb/libusb.h	/^	uint16_t wTotalLength;$/;"	m	struct:libusb_bos_descriptor	access:public
libusb_bos_dev_capability_descriptor	libusb/libusb.h	/^struct libusb_bos_dev_capability_descriptor {$/;"	s
libusb_bos_dev_capability_descriptor::bDescriptorType	libusb/libusb.h	/^	uint8_t bDescriptorType;$/;"	m	struct:libusb_bos_dev_capability_descriptor	access:public
libusb_bos_dev_capability_descriptor::bDevCapabilityType	libusb/libusb.h	/^	uint8_t bDevCapabilityType;$/;"	m	struct:libusb_bos_dev_capability_descriptor	access:public
libusb_bos_dev_capability_descriptor::bLength	libusb/libusb.h	/^	uint8_t bLength;$/;"	m	struct:libusb_bos_dev_capability_descriptor	access:public
libusb_bos_dev_capability_descriptor::dev_capability_data	libusb/libusb.h	/^	uint8_t dev_capability_data$/;"	m	struct:libusb_bos_dev_capability_descriptor	access:public
libusb_bos_type	libusb/libusb.h	/^enum libusb_bos_type {$/;"	g
libusb_bulk_transfer	libusb/libusb.h	/^int LIBUSB_CALL libusb_bulk_transfer(libusb_device_handle *dev_handle,$/;"	p	signature:(libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *actual_length, unsigned int timeout)
libusb_cancel_transfer	libusb/libusb.h	/^int LIBUSB_CALL libusb_cancel_transfer(struct libusb_transfer *transfer);$/;"	p	signature:(struct libusb_transfer *transfer)
libusb_capability	libusb/libusb.h	/^enum libusb_capability {$/;"	g
libusb_claim_interface	libusb/libusb.h	/^int LIBUSB_CALL libusb_claim_interface(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, int interface_number)
libusb_class_code	libusb/libusb.h	/^enum libusb_class_code {$/;"	g
libusb_clear_halt	libusb/libusb.h	/^int LIBUSB_CALL libusb_clear_halt(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, unsigned char endpoint)
libusb_close	libusb/libusb.h	/^void LIBUSB_CALL libusb_close(libusb_device_handle *dev_handle);$/;"	p	signature:(libusb_device_handle *dev_handle)
libusb_config_descriptor	libusb/libusb.h	/^struct libusb_config_descriptor {$/;"	s
libusb_config_descriptor::MaxPower	libusb/libusb.h	/^	uint8_t  MaxPower;$/;"	m	struct:libusb_config_descriptor	access:public
libusb_config_descriptor::bConfigurationValue	libusb/libusb.h	/^	uint8_t  bConfigurationValue;$/;"	m	struct:libusb_config_descriptor	access:public
libusb_config_descriptor::bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_config_descriptor	access:public
libusb_config_descriptor::bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_config_descriptor	access:public
libusb_config_descriptor::bNumInterfaces	libusb/libusb.h	/^	uint8_t  bNumInterfaces;$/;"	m	struct:libusb_config_descriptor	access:public
libusb_config_descriptor::bmAttributes	libusb/libusb.h	/^	uint8_t  bmAttributes;$/;"	m	struct:libusb_config_descriptor	access:public
libusb_config_descriptor::extra	libusb/libusb.h	/^	const unsigned char *extra;$/;"	m	struct:libusb_config_descriptor	access:public
libusb_config_descriptor::extra_length	libusb/libusb.h	/^	int extra_length;$/;"	m	struct:libusb_config_descriptor	access:public
libusb_config_descriptor::iConfiguration	libusb/libusb.h	/^	uint8_t  iConfiguration;$/;"	m	struct:libusb_config_descriptor	access:public
libusb_config_descriptor::interface	libusb/libusb.h	/^	const struct libusb_interface *interface;$/;"	m	struct:libusb_config_descriptor	typeref:struct:libusb_config_descriptor::libusb_interface	access:public
libusb_config_descriptor::wTotalLength	libusb/libusb.h	/^	uint16_t wTotalLength;$/;"	m	struct:libusb_config_descriptor	access:public
libusb_container_id_descriptor	libusb/libusb.h	/^struct libusb_container_id_descriptor {$/;"	s
libusb_container_id_descriptor::ContainerID	libusb/libusb.h	/^	uint8_t  ContainerID[16];$/;"	m	struct:libusb_container_id_descriptor	access:public
libusb_container_id_descriptor::bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_container_id_descriptor	access:public
libusb_container_id_descriptor::bDevCapabilityType	libusb/libusb.h	/^	uint8_t  bDevCapabilityType;$/;"	m	struct:libusb_container_id_descriptor	access:public
libusb_container_id_descriptor::bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_container_id_descriptor	access:public
libusb_container_id_descriptor::bReserved	libusb/libusb.h	/^	uint8_t bReserved;$/;"	m	struct:libusb_container_id_descriptor	access:public
libusb_context	libusb/libusb.h	/^typedef struct libusb_context libusb_context;$/;"	t	typeref:struct:libusb_context
libusb_control_setup	libusb/libusb.h	/^struct libusb_control_setup {$/;"	s
libusb_control_setup::bRequest	libusb/libusb.h	/^	uint8_t  bRequest;$/;"	m	struct:libusb_control_setup	access:public
libusb_control_setup::bmRequestType	libusb/libusb.h	/^	uint8_t  bmRequestType;$/;"	m	struct:libusb_control_setup	access:public
libusb_control_setup::wIndex	libusb/libusb.h	/^	uint16_t wIndex;$/;"	m	struct:libusb_control_setup	access:public
libusb_control_setup::wLength	libusb/libusb.h	/^	uint16_t wLength;$/;"	m	struct:libusb_control_setup	access:public
libusb_control_setup::wValue	libusb/libusb.h	/^	uint16_t wValue;$/;"	m	struct:libusb_control_setup	access:public
libusb_control_transfer	libusb/libusb.h	/^int LIBUSB_CALL libusb_control_transfer(libusb_device_handle *dev_handle,$/;"	p	signature:(libusb_device_handle *dev_handle, uint8_t request_type, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, unsigned char *data, uint16_t wLength, unsigned int timeout)
libusb_control_transfer_get_data	libusb/libusb.h	/^static inline unsigned char *libusb_control_transfer_get_data($/;"	f	signature:( struct libusb_transfer *transfer)
libusb_control_transfer_get_setup	libusb/libusb.h	/^static inline struct libusb_control_setup *libusb_control_transfer_get_setup($/;"	f	signature:( struct libusb_transfer *transfer)
libusb_cpu_to_le16	libusb/libusb.h	/^static inline uint16_t libusb_cpu_to_le16(const uint16_t x)$/;"	f	signature:(const uint16_t x)
libusb_descriptor_type	libusb/libusb.h	/^enum libusb_descriptor_type {$/;"	g
libusb_detach_kernel_driver	libusb/libusb.h	/^int LIBUSB_CALL libusb_detach_kernel_driver(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, int interface_number)
libusb_device	libusb/libusb.h	/^typedef struct libusb_device libusb_device;$/;"	t	typeref:struct:libusb_device
libusb_device_descriptor	libusb/libusb.h	/^struct libusb_device_descriptor {$/;"	s
libusb_device_descriptor::bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::bDeviceClass	libusb/libusb.h	/^	uint8_t  bDeviceClass;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::bDeviceProtocol	libusb/libusb.h	/^	uint8_t  bDeviceProtocol;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::bDeviceSubClass	libusb/libusb.h	/^	uint8_t  bDeviceSubClass;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::bMaxPacketSize0	libusb/libusb.h	/^	uint8_t  bMaxPacketSize0;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::bNumConfigurations	libusb/libusb.h	/^	uint8_t  bNumConfigurations;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::bcdDevice	libusb/libusb.h	/^	uint16_t bcdDevice;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::bcdUSB	libusb/libusb.h	/^	uint16_t bcdUSB;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::iManufacturer	libusb/libusb.h	/^	uint8_t  iManufacturer;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::iProduct	libusb/libusb.h	/^	uint8_t  iProduct;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::iSerialNumber	libusb/libusb.h	/^	uint8_t  iSerialNumber;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::idProduct	libusb/libusb.h	/^	uint16_t idProduct;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_descriptor::idVendor	libusb/libusb.h	/^	uint16_t idVendor;$/;"	m	struct:libusb_device_descriptor	access:public
libusb_device_handle	libusb/libusb.h	/^typedef struct libusb_device_handle libusb_device_handle;$/;"	t	typeref:struct:libusb_device_handle
libusb_endpoint_descriptor	libusb/libusb.h	/^struct libusb_endpoint_descriptor {$/;"	s
libusb_endpoint_descriptor::bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_endpoint_descriptor	access:public
libusb_endpoint_descriptor::bEndpointAddress	libusb/libusb.h	/^	uint8_t  bEndpointAddress;$/;"	m	struct:libusb_endpoint_descriptor	access:public
libusb_endpoint_descriptor::bInterval	libusb/libusb.h	/^	uint8_t  bInterval;$/;"	m	struct:libusb_endpoint_descriptor	access:public
libusb_endpoint_descriptor::bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_endpoint_descriptor	access:public
libusb_endpoint_descriptor::bRefresh	libusb/libusb.h	/^	uint8_t  bRefresh;$/;"	m	struct:libusb_endpoint_descriptor	access:public
libusb_endpoint_descriptor::bSynchAddress	libusb/libusb.h	/^	uint8_t  bSynchAddress;$/;"	m	struct:libusb_endpoint_descriptor	access:public
libusb_endpoint_descriptor::bmAttributes	libusb/libusb.h	/^	uint8_t  bmAttributes;$/;"	m	struct:libusb_endpoint_descriptor	access:public
libusb_endpoint_descriptor::extra	libusb/libusb.h	/^	const unsigned char *extra;$/;"	m	struct:libusb_endpoint_descriptor	access:public
libusb_endpoint_descriptor::extra_length	libusb/libusb.h	/^	int extra_length;$/;"	m	struct:libusb_endpoint_descriptor	access:public
libusb_endpoint_descriptor::wMaxPacketSize	libusb/libusb.h	/^	uint16_t wMaxPacketSize;$/;"	m	struct:libusb_endpoint_descriptor	access:public
libusb_endpoint_direction	libusb/libusb.h	/^enum libusb_endpoint_direction {$/;"	g
libusb_error	libusb/libusb.h	/^enum libusb_error {$/;"	g
libusb_error_name	libusb/libusb.h	/^const char * LIBUSB_CALL libusb_error_name(int errcode);$/;"	p	signature:(int errcode)
libusb_event_handler_active	libusb/libusb.h	/^int LIBUSB_CALL libusb_event_handler_active(libusb_context *ctx);$/;"	p	signature:(libusb_context *ctx)
libusb_event_handling_ok	libusb/libusb.h	/^int LIBUSB_CALL libusb_event_handling_ok(libusb_context *ctx);$/;"	p	signature:(libusb_context *ctx)
libusb_exit	libusb/libusb.h	/^void LIBUSB_CALL libusb_exit(libusb_context *ctx);$/;"	p	signature:(libusb_context *ctx)
libusb_fill_bulk_stream_transfer	libusb/libusb.h	/^static inline void libusb_fill_bulk_stream_transfer($/;"	f	signature:( struct libusb_transfer *transfer, libusb_device_handle *dev_handle, unsigned char endpoint, uint32_t stream_id, unsigned char *buffer, int length, libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)
libusb_fill_bulk_transfer	libusb/libusb.h	/^static inline void libusb_fill_bulk_transfer(struct libusb_transfer *transfer,$/;"	f	signature:(struct libusb_transfer *transfer, libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, int length, libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)
libusb_fill_control_setup	libusb/libusb.h	/^static inline void libusb_fill_control_setup(unsigned char *buffer,$/;"	f	signature:(unsigned char *buffer, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t wLength)
libusb_fill_control_transfer	libusb/libusb.h	/^static inline void libusb_fill_control_transfer($/;"	f	signature:( struct libusb_transfer *transfer, libusb_device_handle *dev_handle, unsigned char *buffer, libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)
libusb_fill_interrupt_transfer	libusb/libusb.h	/^static inline void libusb_fill_interrupt_transfer($/;"	f	signature:( struct libusb_transfer *transfer, libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, int length, libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)
libusb_fill_iso_transfer	libusb/libusb.h	/^static inline void libusb_fill_iso_transfer(struct libusb_transfer *transfer,$/;"	f	signature:(struct libusb_transfer *transfer, libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, int length, int num_iso_packets, libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)
libusb_free_bos_descriptor	libusb/libusb.h	/^void LIBUSB_CALL libusb_free_bos_descriptor(struct libusb_bos_descriptor *bos);$/;"	p	signature:(struct libusb_bos_descriptor *bos)
libusb_free_config_descriptor	libusb/libusb.h	/^void LIBUSB_CALL libusb_free_config_descriptor($/;"	p	signature:( struct libusb_config_descriptor *config)
libusb_free_container_id_descriptor	libusb/libusb.h	/^void LIBUSB_CALL libusb_free_container_id_descriptor($/;"	p	signature:( struct libusb_container_id_descriptor *container_id)
libusb_free_device_list	libusb/libusb.h	/^void LIBUSB_CALL libusb_free_device_list(libusb_device **list,$/;"	p	signature:(libusb_device **list, int unref_devices)
libusb_free_pollfds	libusb/libusb.h	/^void LIBUSB_CALL libusb_free_pollfds(const struct libusb_pollfd **pollfds);$/;"	p	signature:(const struct libusb_pollfd **pollfds)
libusb_free_ss_endpoint_companion_descriptor	libusb/libusb.h	/^void LIBUSB_CALL libusb_free_ss_endpoint_companion_descriptor($/;"	p	signature:( struct libusb_ss_endpoint_companion_descriptor *ep_comp)
libusb_free_ss_usb_device_capability_descriptor	libusb/libusb.h	/^void LIBUSB_CALL libusb_free_ss_usb_device_capability_descriptor($/;"	p	signature:( struct libusb_ss_usb_device_capability_descriptor *ss_usb_device_cap)
libusb_free_streams	libusb/libusb.h	/^int LIBUSB_CALL libusb_free_streams(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, unsigned char *endpoints, int num_endpoints)
libusb_free_transfer	libusb/libusb.h	/^void LIBUSB_CALL libusb_free_transfer(struct libusb_transfer *transfer);$/;"	p	signature:(struct libusb_transfer *transfer)
libusb_free_usb_2_0_extension_descriptor	libusb/libusb.h	/^void LIBUSB_CALL libusb_free_usb_2_0_extension_descriptor($/;"	p	signature:( struct libusb_usb_2_0_extension_descriptor *usb_2_0_extension)
libusb_get_active_config_descriptor	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_active_config_descriptor(libusb_device *dev,$/;"	p	signature:(libusb_device *dev, struct libusb_config_descriptor **config)
libusb_get_bos_descriptor	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_bos_descriptor(libusb_device_handle *handle,$/;"	p	signature:(libusb_device_handle *handle, struct libusb_bos_descriptor **bos)
libusb_get_bus_number	libusb/libusb.h	/^uint8_t LIBUSB_CALL libusb_get_bus_number(libusb_device *dev);$/;"	p	signature:(libusb_device *dev)
libusb_get_config_descriptor	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_config_descriptor(libusb_device *dev,$/;"	p	signature:(libusb_device *dev, uint8_t config_index, struct libusb_config_descriptor **config)
libusb_get_config_descriptor_by_value	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_config_descriptor_by_value(libusb_device *dev,$/;"	p	signature:(libusb_device *dev, uint8_t bConfigurationValue, struct libusb_config_descriptor **config)
libusb_get_configuration	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_configuration(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, int *config)
libusb_get_container_id_descriptor	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_container_id_descriptor(struct libusb_context *ctx,$/;"	p	signature:(struct libusb_context *ctx, struct libusb_bos_dev_capability_descriptor *dev_cap, struct libusb_container_id_descriptor **container_id)
libusb_get_descriptor	libusb/libusb.h	/^static inline int libusb_get_descriptor(libusb_device_handle *dev,$/;"	f	signature:(libusb_device_handle *dev, uint8_t desc_type, uint8_t desc_index, unsigned char *data, int length)
libusb_get_device	libusb/libusb.h	/^libusb_device * LIBUSB_CALL libusb_get_device(libusb_device_handle *dev_handle);$/;"	p	signature:(libusb_device_handle *dev_handle)
libusb_get_device_address	libusb/libusb.h	/^uint8_t LIBUSB_CALL libusb_get_device_address(libusb_device *dev);$/;"	p	signature:(libusb_device *dev)
libusb_get_device_descriptor	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_device_descriptor(libusb_device *dev,$/;"	p	signature:(libusb_device *dev, struct libusb_device_descriptor *desc)
libusb_get_device_list	libusb/libusb.h	/^ssize_t LIBUSB_CALL libusb_get_device_list(libusb_context *ctx,$/;"	p	signature:(libusb_context *ctx, libusb_device ***list)
libusb_get_device_speed	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_device_speed(libusb_device *dev);$/;"	p	signature:(libusb_device *dev)
libusb_get_iso_packet_buffer	libusb/libusb.h	/^static inline unsigned char *libusb_get_iso_packet_buffer($/;"	f	signature:( struct libusb_transfer *transfer, unsigned int packet)
libusb_get_iso_packet_buffer_simple	libusb/libusb.h	/^static inline unsigned char *libusb_get_iso_packet_buffer_simple($/;"	f	signature:( struct libusb_transfer *transfer, unsigned int packet)
libusb_get_max_iso_packet_size	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_max_iso_packet_size(libusb_device *dev,$/;"	p	signature:(libusb_device *dev, unsigned char endpoint)
libusb_get_max_packet_size	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_max_packet_size(libusb_device *dev,$/;"	p	signature:(libusb_device *dev, unsigned char endpoint)
libusb_get_next_timeout	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_next_timeout(libusb_context *ctx,$/;"	p	signature:(libusb_context *ctx, struct timeval *tv)
libusb_get_parent	libusb/libusb.h	/^libusb_device * LIBUSB_CALL libusb_get_parent(libusb_device *dev);$/;"	p	signature:(libusb_device *dev)
libusb_get_pollfds	libusb/libusb.h	/^const struct libusb_pollfd ** LIBUSB_CALL libusb_get_pollfds($/;"	p	signature:( libusb_context *ctx)
libusb_get_port_number	libusb/libusb.h	/^uint8_t LIBUSB_CALL libusb_get_port_number(libusb_device *dev);$/;"	p	signature:(libusb_device *dev)
libusb_get_port_numbers	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_port_numbers(libusb_device *dev, uint8_t* port_numbers, int port_numbers_len);$/;"	p	signature:(libusb_device *dev, uint8_t* port_numbers, int port_numbers_len)
libusb_get_port_path	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_port_path(libusb_context *ctx, libusb_device *dev, uint8_t* path, uint8_t path_length);$/;"	p	signature:(libusb_context *ctx, libusb_device *dev, uint8_t* path, uint8_t path_length)
libusb_get_ss_endpoint_companion_descriptor	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_ss_endpoint_companion_descriptor($/;"	p	signature:( struct libusb_context *ctx, const struct libusb_endpoint_descriptor *endpoint, struct libusb_ss_endpoint_companion_descriptor **ep_comp)
libusb_get_ss_usb_device_capability_descriptor	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_ss_usb_device_capability_descriptor($/;"	p	signature:( struct libusb_context *ctx, struct libusb_bos_dev_capability_descriptor *dev_cap, struct libusb_ss_usb_device_capability_descriptor **ss_usb_device_cap)
libusb_get_string_descriptor	libusb/libusb.h	/^static inline int libusb_get_string_descriptor(libusb_device_handle *dev,$/;"	f	signature:(libusb_device_handle *dev, uint8_t desc_index, uint16_t langid, unsigned char *data, int length)
libusb_get_string_descriptor_ascii	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_string_descriptor_ascii(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, uint8_t desc_index, unsigned char *data, int length)
libusb_get_usb_2_0_extension_descriptor	libusb/libusb.h	/^int LIBUSB_CALL libusb_get_usb_2_0_extension_descriptor($/;"	p	signature:( struct libusb_context *ctx, struct libusb_bos_dev_capability_descriptor *dev_cap, struct libusb_usb_2_0_extension_descriptor **usb_2_0_extension)
libusb_get_version	libusb/libusb.h	/^const struct libusb_version * LIBUSB_CALL libusb_get_version(void);$/;"	p	signature:(void)
libusb_handle_events	libusb/libusb.h	/^int LIBUSB_CALL libusb_handle_events(libusb_context *ctx);$/;"	p	signature:(libusb_context *ctx)
libusb_handle_events_completed	libusb/libusb.h	/^int LIBUSB_CALL libusb_handle_events_completed(libusb_context *ctx, int *completed);$/;"	p	signature:(libusb_context *ctx, int *completed)
libusb_handle_events_locked	libusb/libusb.h	/^int LIBUSB_CALL libusb_handle_events_locked(libusb_context *ctx,$/;"	p	signature:(libusb_context *ctx, struct timeval *tv)
libusb_handle_events_timeout	libusb/libusb.h	/^int LIBUSB_CALL libusb_handle_events_timeout(libusb_context *ctx,$/;"	p	signature:(libusb_context *ctx, struct timeval *tv)
libusb_handle_events_timeout_completed	libusb/libusb.h	/^int LIBUSB_CALL libusb_handle_events_timeout_completed(libusb_context *ctx,$/;"	p	signature:(libusb_context *ctx, struct timeval *tv, int *completed)
libusb_has_capability	libusb/libusb.h	/^int LIBUSB_CALL libusb_has_capability(uint32_t capability);$/;"	p	signature:(uint32_t capability)
libusb_hotplug_callback_fn	libusb/libusb.h	/^typedef int (LIBUSB_CALL *libusb_hotplug_callback_fn)(libusb_context *ctx,$/;"	t
libusb_hotplug_callback_handle	libusb/libusb.h	/^typedef int libusb_hotplug_callback_handle;$/;"	t
libusb_hotplug_deregister_callback	libusb/libusb.h	/^void LIBUSB_CALL libusb_hotplug_deregister_callback(libusb_context *ctx,$/;"	p	signature:(libusb_context *ctx, libusb_hotplug_callback_handle handle)
libusb_hotplug_event	libusb/libusb.h	/^} libusb_hotplug_event;$/;"	t	typeref:enum:__anon2
libusb_hotplug_flag	libusb/libusb.h	/^} libusb_hotplug_flag;$/;"	t	typeref:enum:__anon1
libusb_hotplug_register_callback	libusb/libusb.h	/^int LIBUSB_CALL libusb_hotplug_register_callback(libusb_context *ctx,$/;"	p	signature:(libusb_context *ctx, libusb_hotplug_event events, libusb_hotplug_flag flags, int vendor_id, int product_id, int dev_class, libusb_hotplug_callback_fn cb_fn, void *user_data, libusb_hotplug_callback_handle *handle)
libusb_init	libusb/libusb.h	/^int LIBUSB_CALL libusb_init(libusb_context **ctx);$/;"	p	signature:(libusb_context **ctx)
libusb_interface	libusb/libusb.h	/^struct libusb_interface {$/;"	s
libusb_interface::altsetting	libusb/libusb.h	/^	const struct libusb_interface_descriptor *altsetting;$/;"	m	struct:libusb_interface	typeref:struct:libusb_interface::libusb_interface_descriptor	access:public
libusb_interface::num_altsetting	libusb/libusb.h	/^	int num_altsetting;$/;"	m	struct:libusb_interface	access:public
libusb_interface_descriptor	libusb/libusb.h	/^struct libusb_interface_descriptor {$/;"	s
libusb_interface_descriptor::bAlternateSetting	libusb/libusb.h	/^	uint8_t  bAlternateSetting;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interface_descriptor::bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interface_descriptor::bInterfaceClass	libusb/libusb.h	/^	uint8_t  bInterfaceClass;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interface_descriptor::bInterfaceNumber	libusb/libusb.h	/^	uint8_t  bInterfaceNumber;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interface_descriptor::bInterfaceProtocol	libusb/libusb.h	/^	uint8_t  bInterfaceProtocol;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interface_descriptor::bInterfaceSubClass	libusb/libusb.h	/^	uint8_t  bInterfaceSubClass;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interface_descriptor::bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interface_descriptor::bNumEndpoints	libusb/libusb.h	/^	uint8_t  bNumEndpoints;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interface_descriptor::endpoint	libusb/libusb.h	/^	const struct libusb_endpoint_descriptor *endpoint;$/;"	m	struct:libusb_interface_descriptor	typeref:struct:libusb_interface_descriptor::libusb_endpoint_descriptor	access:public
libusb_interface_descriptor::extra	libusb/libusb.h	/^	const unsigned char *extra;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interface_descriptor::extra_length	libusb/libusb.h	/^	int extra_length;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interface_descriptor::iInterface	libusb/libusb.h	/^	uint8_t  iInterface;$/;"	m	struct:libusb_interface_descriptor	access:public
libusb_interrupt_transfer	libusb/libusb.h	/^int LIBUSB_CALL libusb_interrupt_transfer(libusb_device_handle *dev_handle,$/;"	p	signature:(libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *actual_length, unsigned int timeout)
libusb_iso_packet_descriptor	libusb/libusb.h	/^struct libusb_iso_packet_descriptor {$/;"	s
libusb_iso_packet_descriptor::actual_length	libusb/libusb.h	/^	unsigned int actual_length;$/;"	m	struct:libusb_iso_packet_descriptor	access:public
libusb_iso_packet_descriptor::length	libusb/libusb.h	/^	unsigned int length;$/;"	m	struct:libusb_iso_packet_descriptor	access:public
libusb_iso_packet_descriptor::status	libusb/libusb.h	/^	enum libusb_transfer_status status;$/;"	m	struct:libusb_iso_packet_descriptor	typeref:enum:libusb_iso_packet_descriptor::libusb_transfer_status	access:public
libusb_iso_sync_type	libusb/libusb.h	/^enum libusb_iso_sync_type {$/;"	g
libusb_iso_usage_type	libusb/libusb.h	/^enum libusb_iso_usage_type {$/;"	g
libusb_kernel_driver_active	libusb/libusb.h	/^int LIBUSB_CALL libusb_kernel_driver_active(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, int interface_number)
libusb_le16_to_cpu	libusb/libusb.h	180;"	d
libusb_lock_event_waiters	libusb/libusb.h	/^void LIBUSB_CALL libusb_lock_event_waiters(libusb_context *ctx);$/;"	p	signature:(libusb_context *ctx)
libusb_lock_events	libusb/libusb.h	/^void LIBUSB_CALL libusb_lock_events(libusb_context *ctx);$/;"	p	signature:(libusb_context *ctx)
libusb_log_level	libusb/libusb.h	/^enum libusb_log_level {$/;"	g
libusb_open	libusb/libusb.h	/^int LIBUSB_CALL libusb_open(libusb_device *dev, libusb_device_handle **handle);$/;"	p	signature:(libusb_device *dev, libusb_device_handle **handle)
libusb_open_device_with_vid_pid	libusb/libusb.h	/^libusb_device_handle * LIBUSB_CALL libusb_open_device_with_vid_pid($/;"	p	signature:( libusb_context *ctx, uint16_t vendor_id, uint16_t product_id)
libusb_pollfd	libusb/libusb.h	/^struct libusb_pollfd {$/;"	s
libusb_pollfd::events	libusb/libusb.h	/^	short events;$/;"	m	struct:libusb_pollfd	access:public
libusb_pollfd::fd	libusb/libusb.h	/^	int fd;$/;"	m	struct:libusb_pollfd	access:public
libusb_pollfd_added_cb	libusb/libusb.h	/^typedef void (LIBUSB_CALL *libusb_pollfd_added_cb)(int fd, short events,$/;"	t
libusb_pollfd_removed_cb	libusb/libusb.h	/^typedef void (LIBUSB_CALL *libusb_pollfd_removed_cb)(int fd, void *user_data);$/;"	t
libusb_pollfds_handle_timeouts	libusb/libusb.h	/^int LIBUSB_CALL libusb_pollfds_handle_timeouts(libusb_context *ctx);$/;"	p	signature:(libusb_context *ctx)
libusb_ref_device	libusb/libusb.h	/^libusb_device * LIBUSB_CALL libusb_ref_device(libusb_device *dev);$/;"	p	signature:(libusb_device *dev)
libusb_release_interface	libusb/libusb.h	/^int LIBUSB_CALL libusb_release_interface(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, int interface_number)
libusb_request_recipient	libusb/libusb.h	/^enum libusb_request_recipient {$/;"	g
libusb_request_type	libusb/libusb.h	/^enum libusb_request_type {$/;"	g
libusb_reset_device	libusb/libusb.h	/^int LIBUSB_CALL libusb_reset_device(libusb_device_handle *dev);$/;"	p	signature:(libusb_device_handle *dev)
libusb_set_auto_detach_kernel_driver	libusb/libusb.h	/^int LIBUSB_CALL libusb_set_auto_detach_kernel_driver($/;"	p	signature:( libusb_device_handle *dev, int enable)
libusb_set_configuration	libusb/libusb.h	/^int LIBUSB_CALL libusb_set_configuration(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, int configuration)
libusb_set_debug	libusb/libusb.h	/^void LIBUSB_CALL libusb_set_debug(libusb_context *ctx, int level);$/;"	p	signature:(libusb_context *ctx, int level)
libusb_set_interface_alt_setting	libusb/libusb.h	/^int LIBUSB_CALL libusb_set_interface_alt_setting(libusb_device_handle *dev,$/;"	p	signature:(libusb_device_handle *dev, int interface_number, int alternate_setting)
libusb_set_iso_packet_lengths	libusb/libusb.h	/^static inline void libusb_set_iso_packet_lengths($/;"	f	signature:( struct libusb_transfer *transfer, unsigned int length)
libusb_set_pollfd_notifiers	libusb/libusb.h	/^void LIBUSB_CALL libusb_set_pollfd_notifiers(libusb_context *ctx,$/;"	p	signature:(libusb_context *ctx, libusb_pollfd_added_cb added_cb, libusb_pollfd_removed_cb removed_cb, void *user_data)
libusb_setlocale	libusb/libusb.h	/^int LIBUSB_CALL libusb_setlocale(const char *locale);$/;"	p	signature:(const char *locale)
libusb_speed	libusb/libusb.h	/^enum libusb_speed {$/;"	g
libusb_ss_endpoint_companion_descriptor	libusb/libusb.h	/^struct libusb_ss_endpoint_companion_descriptor {$/;"	s
libusb_ss_endpoint_companion_descriptor::bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_ss_endpoint_companion_descriptor	access:public
libusb_ss_endpoint_companion_descriptor::bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_ss_endpoint_companion_descriptor	access:public
libusb_ss_endpoint_companion_descriptor::bMaxBurst	libusb/libusb.h	/^	uint8_t  bMaxBurst;$/;"	m	struct:libusb_ss_endpoint_companion_descriptor	access:public
libusb_ss_endpoint_companion_descriptor::bmAttributes	libusb/libusb.h	/^	uint8_t  bmAttributes;$/;"	m	struct:libusb_ss_endpoint_companion_descriptor	access:public
libusb_ss_endpoint_companion_descriptor::wBytesPerInterval	libusb/libusb.h	/^	uint16_t wBytesPerInterval;$/;"	m	struct:libusb_ss_endpoint_companion_descriptor	access:public
libusb_ss_usb_device_capability_attributes	libusb/libusb.h	/^enum libusb_ss_usb_device_capability_attributes {$/;"	g
libusb_ss_usb_device_capability_descriptor	libusb/libusb.h	/^struct libusb_ss_usb_device_capability_descriptor {$/;"	s
libusb_ss_usb_device_capability_descriptor::bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
libusb_ss_usb_device_capability_descriptor::bDevCapabilityType	libusb/libusb.h	/^	uint8_t  bDevCapabilityType;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
libusb_ss_usb_device_capability_descriptor::bFunctionalitySupport	libusb/libusb.h	/^	uint8_t  bFunctionalitySupport;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
libusb_ss_usb_device_capability_descriptor::bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
libusb_ss_usb_device_capability_descriptor::bU1DevExitLat	libusb/libusb.h	/^	uint8_t  bU1DevExitLat;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
libusb_ss_usb_device_capability_descriptor::bU2DevExitLat	libusb/libusb.h	/^	uint16_t bU2DevExitLat;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
libusb_ss_usb_device_capability_descriptor::bmAttributes	libusb/libusb.h	/^	uint8_t  bmAttributes;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
libusb_ss_usb_device_capability_descriptor::wSpeedSupported	libusb/libusb.h	/^	uint16_t wSpeedSupported;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
libusb_standard_request	libusb/libusb.h	/^enum libusb_standard_request {$/;"	g
libusb_strerror	libusb/libusb.h	/^const char * LIBUSB_CALL libusb_strerror(enum libusb_error errcode);$/;"	p	signature:(enum libusb_error errcode)
libusb_submit_transfer	libusb/libusb.h	/^int LIBUSB_CALL libusb_submit_transfer(struct libusb_transfer *transfer);$/;"	p	signature:(struct libusb_transfer *transfer)
libusb_supported_speed	libusb/libusb.h	/^enum libusb_supported_speed {$/;"	g
libusb_transfer	libusb/libusb.h	/^struct libusb_transfer {$/;"	s
libusb_transfer::actual_length	libusb/libusb.h	/^	int actual_length;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer::buffer	libusb/libusb.h	/^	unsigned char *buffer;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer::callback	libusb/libusb.h	/^	libusb_transfer_cb_fn callback;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer::dev_handle	libusb/libusb.h	/^	libusb_device_handle *dev_handle;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer::endpoint	libusb/libusb.h	/^	unsigned char endpoint;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer::flags	libusb/libusb.h	/^	uint8_t flags;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer::iso_packet_desc	libusb/libusb.h	/^	struct libusb_iso_packet_descriptor iso_packet_desc$/;"	m	struct:libusb_transfer	typeref:struct:libusb_transfer::libusb_iso_packet_descriptor	access:public
libusb_transfer::length	libusb/libusb.h	/^	int length;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer::num_iso_packets	libusb/libusb.h	/^	int num_iso_packets;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer::status	libusb/libusb.h	/^	enum libusb_transfer_status status;$/;"	m	struct:libusb_transfer	typeref:enum:libusb_transfer::libusb_transfer_status	access:public
libusb_transfer::timeout	libusb/libusb.h	/^	unsigned int timeout;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer::type	libusb/libusb.h	/^	unsigned char type;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer::user_data	libusb/libusb.h	/^	void *user_data;$/;"	m	struct:libusb_transfer	access:public
libusb_transfer_cb_fn	libusb/libusb.h	/^typedef void (LIBUSB_CALL *libusb_transfer_cb_fn)(struct libusb_transfer *transfer);$/;"	t
libusb_transfer_flags	libusb/libusb.h	/^enum libusb_transfer_flags {$/;"	g
libusb_transfer_get_stream_id	libusb/libusb.h	/^uint32_t LIBUSB_CALL libusb_transfer_get_stream_id($/;"	p	signature:( struct libusb_transfer *transfer)
libusb_transfer_set_stream_id	libusb/libusb.h	/^void LIBUSB_CALL libusb_transfer_set_stream_id($/;"	p	signature:( struct libusb_transfer *transfer, uint32_t stream_id)
libusb_transfer_status	libusb/libusb.h	/^enum libusb_transfer_status {$/;"	g
libusb_transfer_type	libusb/libusb.h	/^enum libusb_transfer_type {$/;"	g
libusb_try_lock_events	libusb/libusb.h	/^int LIBUSB_CALL libusb_try_lock_events(libusb_context *ctx);$/;"	p	signature:(libusb_context *ctx)
libusb_unlock_event_waiters	libusb/libusb.h	/^void LIBUSB_CALL libusb_unlock_event_waiters(libusb_context *ctx);$/;"	p	signature:(libusb_context *ctx)
libusb_unlock_events	libusb/libusb.h	/^void LIBUSB_CALL libusb_unlock_events(libusb_context *ctx);$/;"	p	signature:(libusb_context *ctx)
libusb_unref_device	libusb/libusb.h	/^void LIBUSB_CALL libusb_unref_device(libusb_device *dev);$/;"	p	signature:(libusb_device *dev)
libusb_usb_2_0_extension_attributes	libusb/libusb.h	/^enum libusb_usb_2_0_extension_attributes {$/;"	g
libusb_usb_2_0_extension_descriptor	libusb/libusb.h	/^struct libusb_usb_2_0_extension_descriptor {$/;"	s
libusb_usb_2_0_extension_descriptor::bDescriptorType	libusb/libusb.h	/^	uint8_t  bDescriptorType;$/;"	m	struct:libusb_usb_2_0_extension_descriptor	access:public
libusb_usb_2_0_extension_descriptor::bDevCapabilityType	libusb/libusb.h	/^	uint8_t  bDevCapabilityType;$/;"	m	struct:libusb_usb_2_0_extension_descriptor	access:public
libusb_usb_2_0_extension_descriptor::bLength	libusb/libusb.h	/^	uint8_t  bLength;$/;"	m	struct:libusb_usb_2_0_extension_descriptor	access:public
libusb_usb_2_0_extension_descriptor::bmAttributes	libusb/libusb.h	/^	uint32_t  bmAttributes;$/;"	m	struct:libusb_usb_2_0_extension_descriptor	access:public
libusb_version	libusb/libusb.h	/^struct libusb_version {$/;"	s
libusb_version::describe	libusb/libusb.h	/^	const char* describe;$/;"	m	struct:libusb_version	access:public
libusb_version::major	libusb/libusb.h	/^	const uint16_t major;$/;"	m	struct:libusb_version	access:public
libusb_version::micro	libusb/libusb.h	/^	const uint16_t micro;$/;"	m	struct:libusb_version	access:public
libusb_version::minor	libusb/libusb.h	/^	const uint16_t minor;$/;"	m	struct:libusb_version	access:public
libusb_version::nano	libusb/libusb.h	/^	const uint16_t nano;$/;"	m	struct:libusb_version	access:public
libusb_version::rc	libusb/libusb.h	/^	const char *rc;$/;"	m	struct:libusb_version	access:public
libusb_wait_for_event	libusb/libusb.h	/^int LIBUSB_CALL libusb_wait_for_event(libusb_context *ctx, struct timeval *tv);$/;"	p	signature:(libusb_context *ctx, struct timeval *tv)
likely	concurrentqueue/concurrentqueue.h	/^	inline bool likely(bool x) { return __builtin_expect((x), true); }$/;"	f	namespace:moodycamel::details	signature:(bool x)
limit_	json/json.h	/^  size_t limit_;$/;"	m	class:Json::Value	access:private
lower	device/event.h	/^	void lower();$/;"	p	class:tamgef::device::Event	access:public	signature:()
lower	device/event.h	/^void Event<T>::lower()$/;"	f	class:tamgef::device::Event	signature:()
mCurrentState	device/device.h	/^	StateT mCurrentState;$/;"	m	class:tamgef::device::GenericDevice	access:private
mEventList	device/device.h	/^	EventList mEventList;$/;"	m	class:tamgef::device::GenericDevice	access:private
mEventQueue	device/state_machine.h	/^	moodycamel::ConcurrentQueue<std::function<T>> mEventQueue;$/;"	m	class:tamgef::device::StateMachine	access:public
mEventThreadPool	device/state_machine.h	/^	std::vector<std::thread> mEventThreadPool;$/;"	m	class:tamgef::device::StateMachine	access:public
mException	queue/queue_poller.h	/^	std::exception_ptr mException;$/;"	m	class:tamgef::queue::QueuePoller	access:private
mExceptionMutex	queue/queue_poller.h	/^	std::mutex mExceptionMutex;$/;"	m	class:tamgef::queue::QueuePoller	access:private
mFinalStateName	device/state_machine.h	/^	std::string mFinalStateName;$/;"	m	class:tamgef::device::StateMachine	access:public
mFlag	device/event.h	/^	bool mFlag;$/;"	m	class:tamgef::device::Event	access:private
mHandler	queue/queue_poller.h	/^	std::function<void(T)> mHandler;$/;"	m	class:tamgef::queue::QueuePoller	access:private
mInitialStateName	device/state_machine.h	/^	std::string mInitialStateName;$/;"	m	class:tamgef::device::StateMachine	access:public
mInputConnection	device/device.h	/^	QueueReader<InputT> mInputConnection;$/;"	m	class:tamgef::device::GenericDevice	access:private
mInputDomain	device/device.h	/^	InputDomain mInputDomain;$/;"	m	class:tamgef::device::GenericDevice	access:private
mIsActive	device/state_machine.h	/^	std::atomic<bool> mIsActive;$/;"	m	class:tamgef::device::StateMachine	access:public
mObservable	queue/observer_queue_controller.h	/^	observer::Observable<T> mObservable;$/;"	m	class:tamgef::queue::ObserverQueueController	access:private
mObservers	observer/observable.h	/^	std::vector<std::weak_ptr<IObserver<T>>> mObservers;$/;"	m	class:tamgef::observer::Observable	access:private
mObserversMutex	observer/observable.h	/^	std::mutex mObserversMutex;$/;"	m	class:tamgef::observer::Observable	access:private
mOutputDomain	device/device.h	/^	OutputDomain mOutputDomain;$/;"	m	class:tamgef::device::GenericDevice	access:private
mPolling	queue/queue_poller.h	/^	std::atomic<bool> mPolling;$/;"	m	class:tamgef::queue::QueuePoller	access:private
mPredicate	device/domain.h	/^	std::function<bool(T)> mPredicate;$/;"	m	class:tamgef::device::Domain	access:private
mPresentStateName	device/state_machine.h	/^	std::string mPresentStateName;$/;"	m	class:tamgef::device::StateMachine	access:public
mQueue	queue/queue.h	/^	moodycamel::ConcurrentQueue<T> mQueue;$/;"	m	class:tamgef::queue::Queue	access:private
mQueuePoller	queue/observer_queue_controller.h	/^	QueuePoller<T> mQueuePoller;$/;"	m	class:tamgef::queue::ObserverQueueController	access:private
mQueueReader	queue/queue_poller.h	/^	QueueReader<T> mQueueReader;$/;"	m	class:tamgef::queue::QueuePoller	access:private
mResolutionFunction	device/device.h	/^	ResolutionFunction mResolutionFunction;$/;"	m	class:tamgef::device::GenericDevice	access:private
mStateFunction	device/device.h	/^	StateFunction mStateFunction;$/;"	m	class:tamgef::device::GenericDevice	access:private
mStateMap	device/state_machine.h	/^	std::map<std::string, std::function<T>> mStateMap;$/;"	m	class:tamgef::device::StateMachine	access:public
mThread	queue/queue_poller.h	/^	std::thread mThread;$/;"	m	class:tamgef::queue::QueuePoller	access:private
mTransitionMap	device/state_machine.h	/^		std::function<bool()>>> mTransitionMap;$/;"	m	class:tamgef::device::StateMachine	access:public
mType	device/event.h	/^	T mType;$/;"	m	class:tamgef::device::Event	access:private
major	libusb/libusb.h	/^	const uint16_t major;$/;"	m	struct:libusb_version	access:public
make	json/json.h	/^  Value& make(Value& root) const;$/;"	p	class:Json::Path	access:public	signature:(Value& root) const
makePath	json/json.h	/^  void makePath(const std::string& path, const InArgs& in);$/;"	p	class:Json::Path	access:private	signature:(const std::string& path, const InArgs& in)
malloc	concurrentqueue/concurrentqueue.h	/^	static inline void* malloc(size_t size) { return rl::rl_malloc(size, $); }$/;"	f	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public	signature:(size_t size)
malloc	concurrentqueue/concurrentqueue.h	/^	static inline void* malloc(size_t size) { return std::malloc(size); }$/;"	f	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public	signature:(size_t size)
malloc	concurrentqueue/concurrentqueue.h	53;"	d
map_	json/json.h	/^    ObjectValues* map_;$/;"	m	union:Json::Value::ValueHolder	access:public
match	json/json.h	/^  bool match(Location pattern, int patternLength);$/;"	p	class:Json::Reader	access:private	signature:(Location pattern, int patternLength)
maxInt	json/json.h	/^  static const Int maxInt;$/;"	m	class:Json::Value	access:public
maxInt64	json/json.h	/^  static const Int64 maxInt64;$/;"	m	class:Json::Value	access:public
maxLargestInt	json/json.h	/^  static const LargestInt maxLargestInt;$/;"	m	class:Json::Value	access:public
maxLargestUInt	json/json.h	/^  static const LargestUInt maxLargestUInt;$/;"	m	class:Json::Value	access:public
maxUInt	json/json.h	/^  static const UInt maxUInt;$/;"	m	class:Json::Value	access:public
maxUInt64	json/json.h	/^  static const UInt64 maxUInt64;$/;"	m	class:Json::Value	access:public
memberName	json/json.h	/^  char const* memberName() const;$/;"	p	class:Json::ValueIteratorBase	access:public	signature:() const
memberName	json/json.h	/^  char const* memberName(char const** end) const;$/;"	p	class:Json::ValueIteratorBase	access:public	signature:(char const** end) const
message	json/json.h	/^    std::string message;$/;"	m	struct:Json::Reader::StructuredError	access:public
message_	json/json.h	/^    std::string message_;$/;"	m	class:Json::Reader::ErrorInfo	access:public
micro	libusb/libusb.h	/^	const uint16_t micro;$/;"	m	struct:libusb_version	access:public
minInt	json/json.h	/^  static const Int minInt;$/;"	m	class:Json::Value	access:public
minInt64	json/json.h	/^  static const Int64 minInt64;$/;"	m	class:Json::Value	access:public
minLargestInt	json/json.h	/^  static const LargestInt minLargestInt;$/;"	m	class:Json::Value	access:public
minor	libusb/libusb.h	/^	const uint16_t minor;$/;"	m	struct:libusb_version	access:public
moodycamel	concurrentqueue/concurrentqueue.h	/^namespace moodycamel { namespace details {$/;"	n
moodycamel	concurrentqueue/concurrentqueue.h	/^namespace moodycamel {$/;"	n
moodycamel::ConcurrentQueueDefaultTraits	concurrentqueue/concurrentqueue.h	/^struct ConcurrentQueueDefaultTraits$/;"	s	namespace:moodycamel
moodycamel::ConcurrentQueueDefaultTraits::BLOCK_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t BLOCK_SIZE = 32;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
moodycamel::ConcurrentQueueDefaultTraits::EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD	concurrentqueue/concurrentqueue.h	/^	static const size_t EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD = 32;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
moodycamel::ConcurrentQueueDefaultTraits::EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE	concurrentqueue/concurrentqueue.h	/^	static const std::uint32_t EXPLICIT_CONSUMER_CONSUMPTION_QUOTA_BEFORE_ROTATE = 256;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
moodycamel::ConcurrentQueueDefaultTraits::EXPLICIT_INITIAL_INDEX_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t EXPLICIT_INITIAL_INDEX_SIZE = 32;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
moodycamel::ConcurrentQueueDefaultTraits::IMPLICIT_INITIAL_INDEX_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t IMPLICIT_INITIAL_INDEX_SIZE = 32;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
moodycamel::ConcurrentQueueDefaultTraits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t INITIAL_IMPLICIT_PRODUCER_HASH_SIZE = 32;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
moodycamel::ConcurrentQueueDefaultTraits::MAX_SUBQUEUE_SIZE	concurrentqueue/concurrentqueue.h	/^	static const size_t MAX_SUBQUEUE_SIZE = details::const_numeric_max<size_t>::value;$/;"	m	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
moodycamel::ConcurrentQueueDefaultTraits::free	concurrentqueue/concurrentqueue.h	/^	static inline void free(void* ptr) { return rl::rl_free(ptr, $); }$/;"	f	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public	signature:(void* ptr)
moodycamel::ConcurrentQueueDefaultTraits::free	concurrentqueue/concurrentqueue.h	/^	static inline void free(void* ptr) { return std::free(ptr); }$/;"	f	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public	signature:(void* ptr)
moodycamel::ConcurrentQueueDefaultTraits::index_t	concurrentqueue/concurrentqueue.h	/^	typedef std::size_t index_t;$/;"	t	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
moodycamel::ConcurrentQueueDefaultTraits::malloc	concurrentqueue/concurrentqueue.h	/^	static inline void* malloc(size_t size) { return rl::rl_malloc(size, $); }$/;"	f	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public	signature:(size_t size)
moodycamel::ConcurrentQueueDefaultTraits::malloc	concurrentqueue/concurrentqueue.h	/^	static inline void* malloc(size_t size) { return std::malloc(size); }$/;"	f	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public	signature:(size_t size)
moodycamel::ConcurrentQueueDefaultTraits::size_t	concurrentqueue/concurrentqueue.h	/^	typedef std::size_t size_t;$/;"	t	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
moodycamel::MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ProducerToken& operator=(ProducerToken const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	namespace:moodycamel
moodycamel::MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^	ProducerToken(ProducerToken const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	namespace:moodycamel
moodycamel::ProducerToken	concurrentqueue/concurrentqueue.h	/^struct ProducerToken$/;"	s	namespace:moodycamel
moodycamel::ProducerToken::MOODYCAMEL_NOEXCEPT	concurrentqueue/concurrentqueue.h	/^	explicit ProducerToken(ProducerToken&& other) MOODYCAMEL_NOEXCEPT$/;"	m	struct:moodycamel::ProducerToken	access:public
moodycamel::ProducerToken::ProducerToken	concurrentqueue/concurrentqueue.h	/^	explicit ProducerToken(BlockingConcurrentQueue<T, Traits>& queue);$/;"	p	struct:moodycamel::ProducerToken	access:public	signature:(BlockingConcurrentQueue<T, Traits>& queue)
moodycamel::ProducerToken::ProducerToken	concurrentqueue/concurrentqueue.h	/^	explicit ProducerToken(ConcurrentQueue<T, Traits>& queue);$/;"	p	struct:moodycamel::ProducerToken	access:public	signature:(ConcurrentQueue<T, Traits>& queue)
moodycamel::details	concurrentqueue/concurrentqueue.h	/^namespace details {$/;"	n	namespace:moodycamel
moodycamel::details	concurrentqueue/concurrentqueue.h	/^namespace details$/;"	n	namespace:moodycamel
moodycamel::details	concurrentqueue/concurrentqueue.h	/^namespace moodycamel { namespace details {$/;"	n	namespace:moodycamel
moodycamel::details::ConcurrentQueueProducerTypelessBase	concurrentqueue/concurrentqueue.h	/^	struct ConcurrentQueueProducerTypelessBase$/;"	s	namespace:moodycamel::details
moodycamel::details::ConcurrentQueueProducerTypelessBase::ConcurrentQueueProducerTypelessBase	concurrentqueue/concurrentqueue.h	/^		ConcurrentQueueProducerTypelessBase()$/;"	f	struct:moodycamel::details::ConcurrentQueueProducerTypelessBase	access:public	signature:()
moodycamel::details::ConcurrentQueueProducerTypelessBase::inactive	concurrentqueue/concurrentqueue.h	/^		std::atomic<bool> inactive;$/;"	m	struct:moodycamel::details::ConcurrentQueueProducerTypelessBase	access:public
moodycamel::details::ConcurrentQueueProducerTypelessBase::next	concurrentqueue/concurrentqueue.h	/^		ConcurrentQueueProducerTypelessBase* next;$/;"	m	struct:moodycamel::details::ConcurrentQueueProducerTypelessBase	access:public
moodycamel::details::ConcurrentQueueProducerTypelessBase::token	concurrentqueue/concurrentqueue.h	/^		ProducerToken* token;$/;"	m	struct:moodycamel::details::ConcurrentQueueProducerTypelessBase	access:public
moodycamel::details::ThreadExitListener	concurrentqueue/concurrentqueue.h	/^	struct ThreadExitListener$/;"	s	namespace:moodycamel::details
moodycamel::details::ThreadExitListener	concurrentqueue/concurrentqueue.h	/^	typedef RelacyThreadExitListener ThreadExitListener;$/;"	t	namespace:moodycamel::details
moodycamel::details::ThreadExitListener::callback	concurrentqueue/concurrentqueue.h	/^		callback_t callback;$/;"	m	struct:moodycamel::details::ThreadExitListener	access:public
moodycamel::details::ThreadExitListener::callback_t	concurrentqueue/concurrentqueue.h	/^		typedef void (*callback_t)(void*);$/;"	t	struct:moodycamel::details::ThreadExitListener	access:public
moodycamel::details::ThreadExitListener::next	concurrentqueue/concurrentqueue.h	/^		ThreadExitListener* next;		\/\/ reserved for use by the ThreadExitNotifier$/;"	m	struct:moodycamel::details::ThreadExitListener	access:public
moodycamel::details::ThreadExitListener::userData	concurrentqueue/concurrentqueue.h	/^		void* userData;$/;"	m	struct:moodycamel::details::ThreadExitListener	access:public
moodycamel::details::ThreadExitNotifier	concurrentqueue/concurrentqueue.h	/^	class ThreadExitNotifier$/;"	c	namespace:moodycamel::details
moodycamel::details::ThreadExitNotifier	concurrentqueue/concurrentqueue.h	/^	typedef RelacyThreadExitNotifier ThreadExitNotifier;$/;"	t	namespace:moodycamel::details
moodycamel::details::ThreadExitNotifier::MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^		ThreadExitNotifier& operator=(ThreadExitNotifier const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	class:moodycamel::details::ThreadExitNotifier	access:private
moodycamel::details::ThreadExitNotifier::MOODYCAMEL_DELETE_FUNCTION	concurrentqueue/concurrentqueue.h	/^		ThreadExitNotifier(ThreadExitNotifier const&) MOODYCAMEL_DELETE_FUNCTION;$/;"	m	class:moodycamel::details::ThreadExitNotifier	access:private
moodycamel::details::ThreadExitNotifier::ThreadExitNotifier	concurrentqueue/concurrentqueue.h	/^		ThreadExitNotifier() : tail(nullptr) { }$/;"	f	class:moodycamel::details::ThreadExitNotifier	access:private	signature:()
moodycamel::details::ThreadExitNotifier::instance	concurrentqueue/concurrentqueue.h	/^		static inline ThreadExitNotifier& instance()$/;"	f	class:moodycamel::details::ThreadExitNotifier	access:private	signature:()
moodycamel::details::ThreadExitNotifier::subscribe	concurrentqueue/concurrentqueue.h	/^		static void subscribe(ThreadExitListener* listener)$/;"	f	class:moodycamel::details::ThreadExitNotifier	access:public	signature:(ThreadExitListener* listener)
moodycamel::details::ThreadExitNotifier::tail	concurrentqueue/concurrentqueue.h	/^		ThreadExitListener* tail;$/;"	m	class:moodycamel::details::ThreadExitNotifier	access:private
moodycamel::details::ThreadExitNotifier::unsubscribe	concurrentqueue/concurrentqueue.h	/^		static void unsubscribe(ThreadExitListener* listener)$/;"	f	class:moodycamel::details::ThreadExitNotifier	access:public	signature:(ThreadExitListener* listener)
moodycamel::details::ThreadExitNotifier::~ThreadExitNotifier	concurrentqueue/concurrentqueue.h	/^		~ThreadExitNotifier()$/;"	f	class:moodycamel::details::ThreadExitNotifier	access:private	signature:()
moodycamel::details::_hash_32_or_64	concurrentqueue/concurrentqueue.h	/^	template<> struct _hash_32_or_64<1> {$/;"	s	namespace:moodycamel::details
moodycamel::details::_hash_32_or_64	concurrentqueue/concurrentqueue.h	/^	template<bool use32> struct _hash_32_or_64 {$/;"	s	namespace:moodycamel::details
moodycamel::details::_hash_32_or_64::hash	concurrentqueue/concurrentqueue.h	/^		static inline std::uint32_t hash(std::uint32_t h)$/;"	f	struct:moodycamel::details::_hash_32_or_64	access:public	signature:(std::uint32_t h)
moodycamel::details::_hash_32_or_64::hash	concurrentqueue/concurrentqueue.h	/^		static inline std::uint64_t hash(std::uint64_t h)$/;"	f	struct:moodycamel::details::_hash_32_or_64	access:public	signature:(std::uint64_t h)
moodycamel::details::align_for	concurrentqueue/concurrentqueue.h	/^	static inline char* align_for(char* ptr)$/;"	f	namespace:moodycamel::details	signature:(char* ptr)
moodycamel::details::ceil_to_pow_2	concurrentqueue/concurrentqueue.h	/^	static inline T ceil_to_pow_2(T x)$/;"	f	namespace:moodycamel::details	signature:(T x)
moodycamel::details::circular_less_than	concurrentqueue/concurrentqueue.h	/^	static inline bool circular_less_than(T a, T b)$/;"	f	namespace:moodycamel::details	signature:(T a, T b)
moodycamel::details::const_numeric_max	concurrentqueue/concurrentqueue.h	/^	struct const_numeric_max {$/;"	s	namespace:moodycamel::details
moodycamel::details::const_numeric_max::static_assert	concurrentqueue/concurrentqueue.h	/^		static_assert(std::is_integral<T>::value, "const_numeric_max can only be used with integers");$/;"	p	struct:moodycamel::details::const_numeric_max	access:public	signature:(std::is_integral<T>::value, Ó)
moodycamel::details::const_numeric_max::value	concurrentqueue/concurrentqueue.h	/^		static const T value = std::numeric_limits<T>::is_signed$/;"	m	struct:moodycamel::details::const_numeric_max	access:public
moodycamel::details::hash_32_or_64	concurrentqueue/concurrentqueue.h	/^	template<std::size_t size> struct hash_32_or_64 : public _hash_32_or_64<(size > 4)> {  };$/;"	s	namespace:moodycamel::details	inherits:_hash_32_or_64
moodycamel::details::hash_thread_id	concurrentqueue/concurrentqueue.h	/^	static inline size_t hash_thread_id(thread_id_t id)$/;"	f	namespace:moodycamel::details	signature:(thread_id_t id)
moodycamel::details::invalid_thread_id	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id  = 0;			\/\/ See http:\/\/blogs.msdn.com\/b\/oldnewthing\/archive\/2004\/02\/23\/78395.aspx$/;"	m	namespace:moodycamel::details
moodycamel::details::invalid_thread_id	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id  = 0;		\/\/ Address can't be nullptr$/;"	m	namespace:moodycamel::details
moodycamel::details::invalid_thread_id	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id  = 0xFFFFFFFFU;$/;"	m	namespace:moodycamel::details
moodycamel::details::invalid_thread_id2	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id2 = 0xFFFFFFFEU;$/;"	m	namespace:moodycamel::details
moodycamel::details::invalid_thread_id2	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id2 = 0xFFFFFFFFU;	\/\/ Not technically guaranteed to be invalid, but is never used in practice. Note that all Win32 thread IDs are presently multiples of 4.$/;"	m	namespace:moodycamel::details
moodycamel::details::invalid_thread_id2	concurrentqueue/concurrentqueue.h	/^	static const thread_id_t invalid_thread_id2 = 1;		\/\/ Member accesses off a null pointer are also generally invalid. Plus it's not aligned.$/;"	m	namespace:moodycamel::details
moodycamel::details::is_trivially_destructible	concurrentqueue/concurrentqueue.h	/^	template<typename T> struct is_trivially_destructible : std::has_trivial_destructor<T> { };$/;"	s	namespace:moodycamel::details	inherits:std::has_trivial_destructor
moodycamel::details::is_trivially_destructible	concurrentqueue/concurrentqueue.h	/^	template<typename T> struct is_trivially_destructible : std::is_trivially_destructible<T> { };$/;"	s	namespace:moodycamel::details	inherits:std::is_trivially_destructible
moodycamel::details::likely	concurrentqueue/concurrentqueue.h	/^	inline bool likely(bool x) { return __builtin_expect((x), true); }$/;"	f	namespace:moodycamel::details	signature:(bool x)
moodycamel::details::nomove	concurrentqueue/concurrentqueue.h	/^	static inline T const& nomove(T const& x)$/;"	f	namespace:moodycamel::details	signature:(T const& x)
moodycamel::details::nomove_if	concurrentqueue/concurrentqueue.h	/^	struct nomove_if$/;"	s	namespace:moodycamel::details
moodycamel::details::nomove_if	concurrentqueue/concurrentqueue.h	/^	struct nomove_if<false>$/;"	s	namespace:moodycamel::details
moodycamel::details::nomove_if::eval	concurrentqueue/concurrentqueue.h	/^		static inline T const& eval(T const& x)$/;"	f	struct:moodycamel::details::nomove_if	access:public	signature:(T const& x)
moodycamel::details::nomove_if::forward	concurrentqueue/concurrentqueue.h	/^			-> decltype(std::forward<U>(x))$/;"	f	struct:moodycamel::details::nomove_if	access:public	signature:(x)
moodycamel::details::sizeof	concurrentqueue/concurrentqueue.h	/^	static_assert(sizeof(unsigned long) == sizeof(std::uint32_t), "Expected size of unsigned long to be 32 bits on Windows");$/;"	m	namespace:moodycamel::details
moodycamel::details::static_is_lock_free	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free<bool> { enum { value = ATOMIC_BOOL_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
moodycamel::details::static_is_lock_free	concurrentqueue/concurrentqueue.h	/^	template<typename T> struct static_is_lock_free : static_is_lock_free_num<typename std::make_signed<T>::type> {  };$/;"	s	namespace:moodycamel::details	inherits:static_is_lock_free_num
moodycamel::details::static_is_lock_free	concurrentqueue/concurrentqueue.h	/^	template<typename U> struct static_is_lock_free<U*> { enum { value = ATOMIC_POINTER_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
moodycamel::details::static_is_lock_free::value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free<bool> { enum { value = ATOMIC_BOOL_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free::__anon17
moodycamel::details::static_is_lock_free::value	concurrentqueue/concurrentqueue.h	/^	template<typename U> struct static_is_lock_free<U*> { enum { value = ATOMIC_POINTER_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free::__anon18
moodycamel::details::static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<int> { enum { value = ATOMIC_INT_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
moodycamel::details::static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<long long> { enum { value = ATOMIC_LLONG_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
moodycamel::details::static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<long> { enum { value = ATOMIC_LONG_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
moodycamel::details::static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<short> { enum { value = ATOMIC_SHORT_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
moodycamel::details::static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<signed char> { enum { value = ATOMIC_CHAR_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
moodycamel::details::static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<typename T> struct static_is_lock_free_num { enum { value = 0 }; };$/;"	s	namespace:moodycamel::details
moodycamel::details::static_is_lock_free_num::value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<int> { enum { value = ATOMIC_INT_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon14
moodycamel::details::static_is_lock_free_num::value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<long long> { enum { value = ATOMIC_LLONG_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon16
moodycamel::details::static_is_lock_free_num::value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<long> { enum { value = ATOMIC_LONG_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon15
moodycamel::details::static_is_lock_free_num::value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<short> { enum { value = ATOMIC_SHORT_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon13
moodycamel::details::static_is_lock_free_num::value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<signed char> { enum { value = ATOMIC_CHAR_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon12
moodycamel::details::static_is_lock_free_num::value	concurrentqueue/concurrentqueue.h	/^	template<typename T> struct static_is_lock_free_num { enum { value = 0 }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon11
moodycamel::details::swap_relaxed	concurrentqueue/concurrentqueue.h	/^	static inline void swap_relaxed(std::atomic<T>& left, std::atomic<T>& right)$/;"	f	namespace:moodycamel::details	signature:(std::atomic<T>& left, std::atomic<T>& right)
moodycamel::details::thread_id	concurrentqueue/concurrentqueue.h	/^	static inline thread_id_t thread_id() { return rl::thread_index(); }$/;"	f	namespace:moodycamel::details	signature:()
moodycamel::details::thread_id	concurrentqueue/concurrentqueue.h	/^	static inline thread_id_t thread_id() { return static_cast<thread_id_t>(::GetCurrentThreadId()); }$/;"	f	namespace:moodycamel::details	signature:()
moodycamel::details::thread_id	concurrentqueue/concurrentqueue.h	/^	static inline thread_id_t thread_id() { static MOODYCAMEL_THREADLOCAL int x; return reinterpret_cast<thread_id_t>(&x); }$/;"	f	namespace:moodycamel::details	signature:()
moodycamel::details::thread_id_t	concurrentqueue/concurrentqueue.h	/^	typedef std::uint32_t thread_id_t;$/;"	t	namespace:moodycamel::details
moodycamel::details::thread_id_t	concurrentqueue/concurrentqueue.h	/^	typedef std::uintptr_t thread_id_t;$/;"	t	namespace:moodycamel::details
moodycamel::details::unlikely	concurrentqueue/concurrentqueue.h	/^	inline bool unlikely(bool x) { return __builtin_expect((x), false); }$/;"	f	namespace:moodycamel::details	signature:(bool x)
moodycamel::producer	concurrentqueue/concurrentqueue.h	/^	details::ConcurrentQueueProducerTypelessBase* producer;$/;"	m	namespace:moodycamel	access:protected
moodycamel::valid	concurrentqueue/concurrentqueue.h	/^	inline bool valid() const { return producer != nullptr; }$/;"	f	namespace:moodycamel	signature:() const
moodycamel::~ProducerToken	concurrentqueue/concurrentqueue.h	/^	~ProducerToken()$/;"	f	namespace:moodycamel	signature:()
msg_	json/json.h	/^  std::string const msg_;$/;"	m	class:Json::Exception::std	access:protected
mutex	concurrentqueue/concurrentqueue.h	/^		debug::DebugMutex mutex;$/;"	m	struct:ConcurrentQueue::FreeList	access:private
name	json/json.h	/^  std::string name() const;$/;"	p	class:Json::ValueIteratorBase	access:public	signature:() const
nano	libusb/libusb.h	/^	const uint16_t nano;$/;"	m	struct:libusb_version	access:public
new	concurrentqueue/concurrentqueue.h	51;"	d
newCharReader	json/json.h	/^    virtual CharReader* newCharReader() const = 0;$/;"	p	class:Json::CharReader::Factory	access:public	signature:() const
newCharReader	json/json.h	/^  virtual CharReader* newCharReader() const;$/;"	p	class:Json::CharReaderBuilder	access:public	signature:() const
newStreamWriter	json/json.h	/^    virtual StreamWriter* newStreamWriter() const = 0;$/;"	p	class:Json::StreamWriter::Factory	access:public	signature:() const
newStreamWriter	json/json.h	/^  virtual StreamWriter* newStreamWriter() const;$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:() const
new_block_index	concurrentqueue/concurrentqueue.h	/^		bool new_block_index(size_t numberOfFilledSlotsToExpose)$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:private	signature:(size_t numberOfFilledSlotsToExpose)
next	concurrentqueue/concurrentqueue.h	/^		Block* next;$/;"	m	struct:ConcurrentQueue::Block	access:public
next	concurrentqueue/concurrentqueue.h	/^		ConcurrentQueueProducerTypelessBase* next;$/;"	m	struct:moodycamel::details::ConcurrentQueueProducerTypelessBase	access:public
next	concurrentqueue/concurrentqueue.h	/^		ThreadExitListener* next;		\/\/ reserved for use by the ThreadExitNotifier$/;"	m	struct:moodycamel::details::ThreadExitListener	access:public
nextExplicitConsumerId	concurrentqueue/concurrentqueue.h	/^		nextExplicitConsumerId(other.nextExplicitConsumerId.load(std::memory_order_relaxed)),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.nextExplicitConsumerId.load(std::memory_order_relaxed))
nextExplicitProducer	concurrentqueue/concurrentqueue.h	/^		ExplicitProducer* nextExplicitProducer;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:public
next_prod	concurrentqueue/concurrentqueue.h	/^		inline ProducerBase* next_prod() const { return static_cast<ProducerBase*>(next); }$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:() const
noDuplication	json/json.h	/^      noDuplication = 0,$/;"	e	enum:Json::Value::CZString::DuplicationPolicy
nodes_	json/json.h	/^  Nodes nodes_;$/;"	m	class:Json::Reader	access:private
nomove	concurrentqueue/concurrentqueue.h	/^	static inline T const& nomove(T const& x)$/;"	f	namespace:moodycamel::details	signature:(T const& x)
nomove_if	concurrentqueue/concurrentqueue.h	/^	struct nomove_if$/;"	s	namespace:moodycamel::details
nomove_if	concurrentqueue/concurrentqueue.h	/^	struct nomove_if<false>$/;"	s	namespace:moodycamel::details
normalizeEOL	json/json.h	/^  static std::string normalizeEOL(const std::string& text);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const std::string& text)
normalizeEOL	json/json.h	/^  static std::string normalizeEOL(const std::string& text);$/;"	p	class:Json::StyledWriter	access:private	signature:(const std::string& text)
notifyObservers	observer/iobservable.h	/^	virtual void notifyObservers() = 0;$/;"	p	class:tamgef::observer::IObservable	access:public	signature:()
notifyObservers	observer/observable.h	/^void Observable<T>::notifyObservers(T const& message)$/;"	f	class:tamgef::observer::Observable	signature:(T const& message)
null	json/json.h	/^  static const Value& null;  \/\/\/< We regret this reference to a global instance; prefer the simpler Value().$/;"	m	class:Json::Value	access:public
nullRef	json/json.h	/^  static const Value& nullRef;  \/\/\/< just a kludge for binary-compatibility; same as null$/;"	m	class:Json::Value	access:public
nullValue	json/json.h	/^  nullValue = 0, \/\/\/< 'null' value$/;"	e	enum:Json::ValueType
num_altsetting	libusb/libusb.h	/^	int num_altsetting;$/;"	m	struct:libusb_interface	access:public
num_iso_packets	libusb/libusb.h	/^	int num_iso_packets;$/;"	m	struct:libusb_transfer	access:public
numberOfCommentPlacement	json/json.h	/^  numberOfCommentPlacement$/;"	e	enum:Json::CommentPlacement
objectValue	json/json.h	/^  objectValue    \/\/\/< object value (collection of name\/value pairs).$/;"	e	enum:Json::ValueType
observer	observer/iobservable.h	/^namespace observer {$/;"	n	namespace:tamgef
observer	observer/iobserver.h	/^namespace observer {$/;"	n	namespace:tamgef
observer	observer/observable.h	/^namespace observer {$/;"	n	namespace:tamgef
offset_limit	json/json.h	/^    size_t offset_limit;$/;"	m	struct:Json::Reader::StructuredError	access:public
offset_start	json/json.h	/^    size_t offset_start;$/;"	m	struct:Json::Reader::StructuredError	access:public
omitEndingLineFeed	json/json.h	/^  void omitEndingLineFeed();$/;"	p	class:Json::FastWriter	access:public	signature:()
omitEndingLineFeed_	json/json.h	/^  bool omitEndingLineFeed_;$/;"	m	class:Json::FastWriter	access:private
operator !	json/json.h	/^  bool operator!() const;$/;"	p	class:Json::Value	access:public	signature:() const
operator !=	json/json.h	/^  bool operator!=(const SelfType& other) const { return !isEqual(other); }$/;"	f	class:Json::ValueIteratorBase	access:public	signature:(const SelfType& other) const
operator !=	json/json.h	/^  bool operator!=(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
operator ()	device/domain.h	/^	bool operator()(T) const;$/;"	p	class:tamgef::device::Domain	access:public	signature:(T) const
operator ()	device/domain.h	/^bool Domain<T>::operator()(T element) const$/;"	f	class:tamgef::device::Domain	signature:(T element) const
operator *	device/domain.h	/^	Domain<T> operator*(Domain<T> const&) const;$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> const&) const
operator *	device/domain.h	/^Domain<T> Domain<T>::operator*(Domain<T> const& other) const$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> const& other) const
operator *	json/json.h	/^  reference operator*() const { return deref(); }$/;"	f	class:Json::ValueConstIterator	access:public	signature:() const
operator *	json/json.h	/^  reference operator*() const { return deref(); }$/;"	f	class:Json::ValueIterator	access:public	signature:() const
operator +	device/domain.h	/^	Domain<T> operator+(Domain<T> const&) const;$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> const&) const
operator +	device/domain.h	/^Domain<T> Domain<T>::operator+(Domain<T> const& other) const$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> const& other) const
operator ++	json/json.h	/^  SelfType operator++(int) {$/;"	f	class:Json::ValueConstIterator	access:public	signature:(int)
operator ++	json/json.h	/^  SelfType operator++(int) {$/;"	f	class:Json::ValueIterator	access:public	signature:(int)
operator ++	json/json.h	/^  SelfType& operator++() {$/;"	f	class:Json::ValueConstIterator	access:public	signature:()
operator ++	json/json.h	/^  SelfType& operator++() {$/;"	f	class:Json::ValueIterator	access:public	signature:()
operator -	json/json.h	/^  difference_type operator-(const SelfType& other) const {$/;"	f	class:Json::ValueIteratorBase	access:public	signature:(const SelfType& other) const
operator --	json/json.h	/^  SelfType operator--(int) {$/;"	f	class:Json::ValueConstIterator	access:public	signature:(int)
operator --	json/json.h	/^  SelfType operator--(int) {$/;"	f	class:Json::ValueIterator	access:public	signature:(int)
operator --	json/json.h	/^  SelfType& operator--() {$/;"	f	class:Json::ValueConstIterator	access:public	signature:()
operator --	json/json.h	/^  SelfType& operator--() {$/;"	f	class:Json::ValueIterator	access:public	signature:()
operator ->	json/json.h	/^  pointer operator->() const { return &deref(); }$/;"	f	class:Json::ValueConstIterator	access:public	signature:() const
operator ->	json/json.h	/^  pointer operator->() const { return &deref(); }$/;"	f	class:Json::ValueIterator	access:public	signature:() const
operator <	json/json.h	/^    bool operator<(CZString const& other) const;$/;"	p	class:Json::Value::CZString	access:public	signature:(CZString const& other) const
operator <	json/json.h	/^  bool operator<(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
operator <<	json/json.h	/^JSON_API std::ostream& operator<<(std::ostream&, const Value& root);$/;"	p	namespace:Json	signature:(std::ostream&, const Value& root)
operator <=	json/json.h	/^  bool operator<=(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
operator =	device/device.h	/^	GenericDevice<InputT, OutputT, StateT, EventT> & operator=($/;"	p	class:tamgef::device::GenericDevice	access:public	signature:( GenericDevice<InputT, OutputT, StateT, EventT>)
operator =	device/device.h	/^operator=(GenericDevice<InputT, OutputT, StateT, EventT> other)$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<InputT, OutputT, StateT, EventT> other)
operator =	device/domain.h	/^	Domain<T> operator=(Domain<T> &&);$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> &&)
operator =	device/domain.h	/^	Domain<T> operator=(Domain<T> const&);$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> const&)
operator =	device/domain.h	/^Domain<T> Domain<T>::operator=(Domain<T> && other)$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> && other)
operator =	device/domain.h	/^Domain<T> Domain<T>::operator=(Domain<T> const& other)$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> const& other)
operator =	device/event.h	/^	Event<T> & operator=(Event<T>);$/;"	p	class:tamgef::device::Event	access:public	signature:(Event<T>)
operator =	device/event.h	/^Event<T> & Event<T>::operator=(Event<T> other)$/;"	f	class:tamgef::device::Event	signature:(Event<T> other)
operator =	device/state_machine.h	/^	StateMachine& operator=(StateMachine const&);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(StateMachine const&)
operator =	device/state_machine.h	/^	StateMachine& operator=(StateMachine&&);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(StateMachine&&)
operator =	json/json.h	/^    CZString& operator=(CZString other);$/;"	p	class:Json::Value::CZString	access:public	signature:(CZString other)
operator =	json/json.h	/^  SelfType& operator=(const SelfType& other);$/;"	p	class:Json::ValueIterator	access:public	signature:(const SelfType& other)
operator =	json/json.h	/^  SelfType& operator=(const ValueIteratorBase& other);$/;"	p	class:Json::ValueConstIterator	access:public	signature:(const ValueIteratorBase& other)
operator =	json/json.h	/^  Value& operator=(Value other);$/;"	p	class:Json::Value	access:public	signature:(Value other)
operator =	queue/queue_reader.h	/^	QueueReader<T> & operator=(QueueReader<T>);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(QueueReader<T>)
operator =	queue/queue_reader.h	/^QueueReader<T> & QueueReader<T>::operator=(QueueReader<T> other)$/;"	f	class:tamgef::queue::QueueReader	signature:(QueueReader<T> other)
operator ==	json/json.h	/^    bool operator==(CZString const& other) const;$/;"	p	class:Json::Value::CZString	access:public	signature:(CZString const& other) const
operator ==	json/json.h	/^  bool operator==(const SelfType& other) const { return isEqual(other); }$/;"	f	class:Json::ValueIteratorBase	access:public	signature:(const SelfType& other) const
operator ==	json/json.h	/^  bool operator==(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
operator >	json/json.h	/^  bool operator>(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
operator >=	json/json.h	/^  bool operator>=(const Value& other) const;$/;"	p	class:Json::Value	access:public	signature:(const Value& other) const
operator >>	json/json.h	/^JSON_API std::istream& operator>>(std::istream&, Value&);$/;"	p	namespace:Json	signature:(std::istream&, Value&)
operator []	json/json.h	/^  Value& operator[](ArrayIndex index);$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex index)
operator []	json/json.h	/^  Value& operator[](const CppTL::ConstString& key);$/;"	p	class:Json::Value	access:public	signature:(const CppTL::ConstString& key)
operator []	json/json.h	/^  Value& operator[](const StaticString& key);$/;"	p	class:Json::Value	access:public	signature:(const StaticString& key)
operator []	json/json.h	/^  Value& operator[](const char* key);$/;"	p	class:Json::Value	access:public	signature:(const char* key)
operator []	json/json.h	/^  Value& operator[](const std::string& key);$/;"	p	class:Json::Value	access:public	signature:(const std::string& key)
operator []	json/json.h	/^  Value& operator[](int index);$/;"	p	class:Json::Value	access:public	signature:(int index)
operator []	json/json.h	/^  Value& operator[](std::string key);$/;"	p	class:Json::CharReaderBuilder	access:public	signature:(std::string key)
operator []	json/json.h	/^  Value& operator[](std::string key);$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:(std::string key)
operator []	json/json.h	/^  const Value& operator[](ArrayIndex index) const;$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex index) const
operator []	json/json.h	/^  const Value& operator[](const CppTL::ConstString& key) const;$/;"	p	class:Json::Value	access:public	signature:(const CppTL::ConstString& key) const
operator []	json/json.h	/^  const Value& operator[](const char* key) const;$/;"	p	class:Json::Value	access:public	signature:(const char* key) const
operator []	json/json.h	/^  const Value& operator[](const std::string& key) const;$/;"	p	class:Json::Value	access:public	signature:(const std::string& key) const
operator []	json/json.h	/^  const Value& operator[](int index) const;$/;"	p	class:Json::Value	access:public	signature:(int index) const
operator const char*	json/json.h	/^  operator const char*() const { return c_str_; }$/;"	f	class:Json::StaticString	access:public	signature:() const
override	observer/observable.h	/^			std::shared_ptr<IObserver<T>> observer) override;$/;"	m	class:tamgef::observer::Observable	access:public
override	observer/observable.h	/^	virtual void notifyObservers(T const&) override;$/;"	m	class:tamgef::observer::Observable	access:public
override	queue/queue.h	/^	bool dequeue(T& element) override;$/;"	m	class:tamgef::queue::Queue	access:public
override	queue/queue.h	/^	bool enqueue(T element) override;$/;"	m	class:tamgef::queue::Queue	access:public
override	queue/queue.h	/^	size_t size() const override;$/;"	m	class:tamgef::queue::Queue	access:public
owner	concurrentqueue/concurrentqueue.h	/^		void* owner;$/;"	m	struct:ConcurrentQueue::Block	access:public
pEventQueue	device/device.h	/^	std::shared_ptr<Queue<Event<EventT>>> pEventQueue;$/;"	m	class:tamgef::device::GenericDevice	access:private
pOutputQueue	device/device.h	/^	std::shared_ptr<Queue<OutputT>> pOutputQueue;$/;"	m	class:tamgef::device::GenericDevice	access:private
pQueue	queue/queue_reader.h	/^	std::weak_ptr<IQueue<T>> pQueue;$/;"	m	class:tamgef::queue::QueueReader	access:private
pStateHandlerThread	device/state_machine.h	/^	std::shared_ptr<std::thread> pStateHandlerThread;$/;"	m	class:tamgef::device::StateMachine	access:public
parent	concurrentqueue/concurrentqueue.h	/^		ConcurrentQueue* parent;$/;"	m	struct:ConcurrentQueue::ProducerBase	access:public
parse	json/json.h	/^  bool parse(const char* beginDoc,$/;"	p	class:Json::Reader	access:public	signature:(const char* beginDoc, const char* endDoc, Value& root, bool collectComments = true)
parse	json/json.h	/^  bool parse(std::istream& is, Value& root, bool collectComments = true);$/;"	p	class:Json::Reader	access:public	signature:(std::istream& is, Value& root, bool collectComments = true)
parse	json/json.h	/^  parse(const std::string& document, Value& root, bool collectComments = true);$/;"	p	class:Json::Reader	access:public	signature:(const std::string& document, Value& root, bool collectComments = true)
parse	json/json.h	/^  virtual bool parse($/;"	p	class:Json::CharReader	access:public	signature:( char const* beginDoc, char const* endDoc, Value* root, std::string* errs)
parseFromStream	json/json.h	/^bool JSON_API parseFromStream($/;"	p	namespace:Json	signature:( CharReader::Factory const&, std::istream&, Value* root, std::string* errs)
pointer	json/json.h	/^  typedef Value* pointer;$/;"	t	class:Json::ValueIterator	access:public
pointer	json/json.h	/^  typedef const Value* pointer;$/;"	t	class:Json::ValueConstIterator	access:public
policy_	json/json.h	/^      unsigned policy_: 2;$/;"	m	struct:Json::Value::CZString::StringStorage	access:public
poll	queue/queue_poller.h	/^	void poll();$/;"	p	class:tamgef::queue::QueuePoller	access:private	signature:()
poll	queue/queue_poller.h	/^void QueuePoller<T>::poll()$/;"	f	class:tamgef::queue::QueuePoller	signature:()
polling	queue/queue_poller.h	/^	bool polling();$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:()
polling	queue/queue_poller.h	/^bool QueuePoller<T>::polling()$/;"	f	class:tamgef::queue::QueuePoller	signature:()
pr_blockIndexEntries	concurrentqueue/concurrentqueue.h	/^		BlockIndexEntry* pr_blockIndexEntries;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
pr_blockIndexFront	concurrentqueue/concurrentqueue.h	/^		size_t pr_blockIndexFront;		\/\/ Next slot (not current)$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
pr_blockIndexRaw	concurrentqueue/concurrentqueue.h	/^		void* pr_blockIndexRaw;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
pr_blockIndexSize	concurrentqueue/concurrentqueue.h	/^		size_t pr_blockIndexSize;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
pr_blockIndexSlotsUsed	concurrentqueue/concurrentqueue.h	/^		size_t pr_blockIndexSlotsUsed;$/;"	m	struct:ConcurrentQueue::ExplicitProducer	access:private
prev	concurrentqueue/concurrentqueue.h	/^			void* prev;$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexHeader	access:public
producer	concurrentqueue/concurrentqueue.h	/^	details::ConcurrentQueueProducerTypelessBase* producer;$/;"	m	namespace:moodycamel	access:protected
producerCount	concurrentqueue/concurrentqueue.h	/^		producerCount(other.producerCount.load(std::memory_order_relaxed)),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.producerCount.load(std::memory_order_relaxed))
producerListTail	concurrentqueue/concurrentqueue.h	/^		: producerListTail(other.producerListTail.load(std::memory_order_relaxed)),$/;"	p	class:ConcurrentQueue	access:public	signature:(other.producerListTail.load(std::memory_order_relaxed))
producer_token_t	concurrentqueue/concurrentqueue.h	/^	typedef ::moodycamel::ProducerToken producer_token_t;$/;"	t	class:ConcurrentQueue	access:public
pushError	json/json.h	/^  bool pushError(const Value& value, const std::string& message);$/;"	p	class:Json::Reader	access:public	signature:(const Value& value, const std::string& message)
pushError	json/json.h	/^  bool pushError(const Value& value, const std::string& message, const Value& extra);$/;"	p	class:Json::Reader	access:public	signature:(const Value& value, const std::string& message, const Value& extra)
pushValue	json/json.h	/^  void pushValue(const std::string& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const std::string& value)
pushValue	json/json.h	/^  void pushValue(const std::string& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const std::string& value)
queue	queue/iqueue.h	/^namespace queue {$/;"	n	namespace:tamgef
queue	queue/observer_queue_controller.h	/^namespace queue {$/;"	n	namespace:tamgef
queue	queue/queue.h	/^namespace queue $/;"	n	namespace:tamgef
queue	queue/queue_poller.h	/^namespace queue {$/;"	n	namespace:tamgef
queue	queue/queue_reader.h	/^namespace queue {$/;"	n	namespace:tamgef
raise	device/event.h	/^	void raise();$/;"	p	class:tamgef::device::Event	access:public	signature:()
raise	device/event.h	/^void Event<T>::raise()$/;"	f	class:tamgef::device::Event	signature:()
rc	libusb/libusb.h	/^	const char *rc;$/;"	m	struct:libusb_version	access:public
read	device/device.h	/^	bool read();$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:()
read	device/device.h	/^	bool read(InputT);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(InputT)
read	device/device.h	/^read()$/;"	f	class:tamgef::device::GenericDevice	signature:()
read	device/device.h	/^read(InputT input)$/;"	f	class:tamgef::device::GenericDevice	signature:(InputT input)
readArray	json/json.h	/^  bool readArray(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
readCStyleComment	json/json.h	/^  bool readCStyleComment();$/;"	p	class:Json::Reader	access:private	signature:()
readComment	json/json.h	/^  bool readComment();$/;"	p	class:Json::Reader	access:private	signature:()
readCppStyleComment	json/json.h	/^  bool readCppStyleComment();$/;"	p	class:Json::Reader	access:private	signature:()
readNumber	json/json.h	/^  void readNumber();$/;"	p	class:Json::Reader	access:private	signature:()
readObject	json/json.h	/^  bool readObject(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
readString	json/json.h	/^  bool readString();$/;"	p	class:Json::Reader	access:private	signature:()
readToken	json/json.h	/^  bool readToken(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
readValue	json/json.h	/^  bool readValue();$/;"	p	class:Json::Reader	access:private	signature:()
realValue	json/json.h	/^  realValue,     \/\/\/< double value$/;"	e	enum:Json::ValueType
real_	json/json.h	/^    double real_;$/;"	m	union:Json::Value::ValueHolder	access:public
recoverFromError	json/json.h	/^  bool recoverFromError(TokenType skipUntilToken);$/;"	p	class:Json::Reader	access:private	signature:(TokenType skipUntilToken)
reference	json/json.h	/^  typedef Value& reference;$/;"	t	class:Json::ValueIterator	access:public
reference	json/json.h	/^  typedef const Value& reference;$/;"	t	class:Json::ValueConstIterator	access:public
registerType	device/event.h	/^	static void registerType(T const&);$/;"	p	class:tamgef::device::Event	access:public	signature:(T const&)
registerType	device/event.h	/^	static void registerType(std::initializer_list<T> const&);$/;"	p	class:tamgef::device::Event	access:public	signature:(std::initializer_list<T> const&)
registerType	device/event.h	/^void Event<T>::registerType(T const& type)$/;"	f	class:tamgef::device::Event	signature:(T const& type)
registerType	device/event.h	/^void Event<T>::registerType(std::initializer_list<T> const& types)$/;"	f	class:tamgef::device::Event	signature:(std::initializer_list<T> const& types)
registered	device/event.h	/^	static bool registered(T const&);$/;"	p	class:tamgef::device::Event	access:public	signature:(T const&)
registered	device/event.h	/^bool Event<T>::registered(T const& type)$/;"	f	class:tamgef::device::Event	signature:(T const& type)
registeredTypes	device/event.h	/^	static std::vector<T> registeredTypes();$/;"	p	class:tamgef::device::Event	access:public	signature:()
registeredTypes	device/event.h	/^std::vector<T> Event<T>::registeredTypes()$/;"	f	class:tamgef::device::Event	signature:()
removeIndex	json/json.h	/^  bool removeIndex(ArrayIndex i, Value* removed);$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex i, Value* removed)
removeMember	json/json.h	/^  Value removeMember(const char* key);$/;"	p	class:Json::Value	access:public	signature:(const char* key)
removeMember	json/json.h	/^  Value removeMember(const std::string& key);$/;"	p	class:Json::Value	access:public	signature:(const std::string& key)
removeMember	json/json.h	/^  bool removeMember(const char* begin, const char* end, Value* removed);$/;"	p	class:Json::Value	access:public	signature:(const char* begin, const char* end, Value* removed)
removeMember	json/json.h	/^  bool removeMember(const char* key, Value* removed);$/;"	p	class:Json::Value	access:public	signature:(const char* key, Value* removed)
removeMember	json/json.h	/^  bool removeMember(std::string const& key, Value* removed);$/;"	p	class:Json::Value	access:public	signature:(std::string const& key, Value* removed)
reset_empty	concurrentqueue/concurrentqueue.h	/^		inline void reset_empty()$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:()
resize	json/json.h	/^  void resize(ArrayIndex size);$/;"	p	class:Json::Value	access:public	signature:(ArrayIndex size)
resolve	json/json.h	/^  Value resolve(const Value& root, const Value& defaultValue) const;$/;"	p	class:Json::Path	access:public	signature:(const Value& root, const Value& defaultValue) const
resolve	json/json.h	/^  const Value& resolve(const Value& root) const;$/;"	p	class:Json::Path	access:public	signature:(const Value& root) const
resolveReference	json/json.h	/^  Value& resolveReference(const char* key);$/;"	p	class:Json::Value	access:private	signature:(const char* key)
resolveReference	json/json.h	/^  Value& resolveReference(const char* key, const char* end);$/;"	p	class:Json::Value	access:private	signature:(const char* key, const char* end)
rightMargin_	json/json.h	/^  int rightMargin_;$/;"	m	class:Json::StyledStreamWriter	access:private
rightMargin_	json/json.h	/^  int rightMargin_;$/;"	m	class:Json::StyledWriter	access:private
sRegisteredTypes	device/event.h	/^	static std::vector<T> sRegisteredTypes;$/;"	m	class:tamgef::device::Event	access:private
sRegisteredTypes	device/event.h	/^template<typename T> std::vector<T> Event<T>::sRegisteredTypes;$/;"	m	class:tamgef::device::Event
setComment	json/json.h	/^    void setComment(const char* text, size_t len);$/;"	p	struct:Json::Value::CommentInfo	access:public	signature:(const char* text, size_t len)
setComment	json/json.h	/^  void setComment(const char* comment, CommentPlacement placement);$/;"	p	class:Json::Value	access:public	signature:(const char* comment, CommentPlacement placement)
setComment	json/json.h	/^  void setComment(const char* comment, size_t len, CommentPlacement placement);$/;"	p	class:Json::Value	access:public	signature:(const char* comment, size_t len, CommentPlacement placement)
setComment	json/json.h	/^  void setComment(const std::string& comment, CommentPlacement placement);$/;"	p	class:Json::Value	access:public	signature:(const std::string& comment, CommentPlacement placement)
setDefaults	json/json.h	/^  static void setDefaults(Json::Value* settings);$/;"	p	class:Json::CharReaderBuilder	access:public	signature:(Json::Value* settings)
setDefaults	json/json.h	/^  static void setDefaults(Json::Value* settings);$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:(Json::Value* settings)
setFinalState	device/state_machine.h	/^	bool setFinalState(std::string const& stateName);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& stateName)
setFinalState	device/state_machine.h	/^bool StateMachine<T>::setFinalState(std::string const& stateName)$/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& stateName)
setInitialState	device/state_machine.h	/^	bool setInitialState(std::string const& stateName);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& stateName)
setInitialState	device/state_machine.h	/^bool StateMachine<T>::setInitialState(std::string const& stateName)$/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& stateName)
setOffsetLimit	json/json.h	/^  void setOffsetLimit(size_t limit);$/;"	p	class:Json::Value	access:public	signature:(size_t limit)
setOffsetStart	json/json.h	/^  void setOffsetStart(size_t start);$/;"	p	class:Json::Value	access:public	signature:(size_t start)
set_all_empty	concurrentqueue/concurrentqueue.h	/^		inline void set_all_empty()$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:()
set_empty	concurrentqueue/concurrentqueue.h	/^		inline bool set_empty(index_t i)$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:(index_t i)
set_many_empty	concurrentqueue/concurrentqueue.h	/^		inline bool set_many_empty(index_t i, size_t count)$/;"	f	struct:ConcurrentQueue::Block	access:public	signature:(index_t i, size_t count)
settings_	json/json.h	/^  Json::Value settings_;$/;"	m	class:Json::CharReaderBuilder	access:public
settings_	json/json.h	/^  Json::Value settings_;$/;"	m	class:Json::StreamWriterBuilder	access:public
shouldBeOnFreeList	concurrentqueue/concurrentqueue.h	/^		std::atomic<bool> shouldBeOnFreeList;$/;"	m	struct:ConcurrentQueue::Block	access:public
size	concurrentqueue/concurrentqueue.h	/^			size_t size;$/;"	m	struct:ConcurrentQueue::ExplicitProducer::BlockIndexHeader	access:public
size	json/json.h	/^  ArrayIndex size() const;$/;"	p	class:Json::Value	access:public	signature:() const
size	queue/iqueue.h	/^	virtual size_t size() const = 0;$/;"	p	class:tamgef::queue::IQueue	access:public	signature:() const
size	queue/queue.h	/^size_t Queue<T>::size() const$/;"	f	class:tamgef::queue::Queue	signature:() const
size	queue/queue_reader.h	/^	size_t size();$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
size	queue/queue_reader.h	/^size_t QueueReader<T>::size()$/;"	f	class:tamgef::queue::QueueReader	signature:()
size_approx	concurrentqueue/concurrentqueue.h	/^		inline size_t size_approx() const$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:() const
size_approx	concurrentqueue/concurrentqueue.h	/^	size_t size_approx() const$/;"	f	class:ConcurrentQueue	access:public	signature:() const
size_t	concurrentqueue/concurrentqueue.h	/^	typedef std::size_t size_t;$/;"	t	struct:moodycamel::ConcurrentQueueDefaultTraits	access:public
size_t	concurrentqueue/concurrentqueue.h	/^	typedef typename Traits::size_t size_t;$/;"	t	class:ConcurrentQueue	access:public
size_t	json/json.h	/^  typedef unsigned int size_t;$/;"	t	class:Json::ValueIterator	access:public
size_t	json/json.h	/^  typedef unsigned int size_t;$/;"	t	class:Json::ValueIteratorBase	access:public
sizeof	concurrentqueue/concurrentqueue.h	/^	static_assert(sizeof(index_t) >= sizeof(size_t), "Traits::index_t must be at least as wide as Traits::size_t");$/;"	p	class:ConcurrentQueue	access:public	signature:(index_t)
sizeof	concurrentqueue/concurrentqueue.h	/^	static_assert(sizeof(unsigned long) == sizeof(std::uint32_t), "Expected size of unsigned long to be 32 bits on Windows");$/;"	m	namespace:moodycamel::details
skipCommentTokens	json/json.h	/^  void skipCommentTokens(Token& token);$/;"	p	class:Json::Reader	access:private	signature:(Token& token)
skipSpaces	json/json.h	/^  void skipSpaces();$/;"	p	class:Json::Reader	access:private	signature:()
skipUntilSpace	json/json.h	/^  void skipUntilSpace();$/;"	p	class:Json::Reader	access:private	signature:()
sout_	json/json.h	/^  std::ostream* sout_;  \/\/ not owned; will not delete$/;"	m	class:Json::StreamWriter	access:protected
ssize_t	libusb/libusb.h	/^  typedef __int64 ssize_t;$/;"	t
ssize_t	libusb/libusb.h	/^  typedef int ssize_t;$/;"	t
ssize_t	libusb/libusb.h	35;"	d
start	device/state_machine.h	/^	bool start();$/;"	p	class:tamgef::device::StateMachine	access:public	signature:()
start	device/state_machine.h	/^	bool start(std::string const& initialStateName);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& initialStateName)
start	device/state_machine.h	/^bool StateMachine<T>::start()$/;"	f	class:tamgef::device::StateMachine	signature:()
start	device/state_machine.h	/^bool StateMachine<T>::start(std::string const& initialStateName)$/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& initialStateName)
start_	json/json.h	/^    Location start_;$/;"	m	class:Json::Reader::Token	access:public
start_	json/json.h	/^  size_t start_;$/;"	m	class:Json::Value	access:private
state	device/device.h	/^	StateT state();$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:()
state	device/device.h	/^state() $/;"	f	class:tamgef::device::GenericDevice	signature:()
stateHandler	device/state_machine.h	/^	void stateHandler();$/;"	p	class:tamgef::device::StateMachine	access:public	signature:()
stateHandler	device/state_machine.h	/^void StateMachine<T>::stateHandler()$/;"	f	class:tamgef::device::StateMachine	signature:()
static_assert	concurrentqueue/concurrentqueue.h	/^		static_assert(std::is_integral<T>::value, "const_numeric_max can only be used with integers");$/;"	p	struct:moodycamel::details::const_numeric_max	access:public	signature:(std::is_integral<T>::value, Ó)
static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert((BLOCK_SIZE > 1) && !(BLOCK_SIZE & (BLOCK_SIZE - 1)), "Traits::BLOCK_SIZE must be a power of 2 (and at least 2)");$/;"	p	class:ConcurrentQueue	access:public	signature:(BLOCK_SIZE > 1) && !(BLOCK_SIZE & (BLOCK_SIZE - 1)), Ó
static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert((EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD > 1) && !(EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD & (EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD - 1)), "Traits::EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD must be a power of 2 (and greater than 1)");$/;"	p	class:ConcurrentQueue	access:public	signature:(EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD > 1) && !(EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD & (EXPLICIT_BLOCK_EMPTY_COUNTER_THRESHOLD - 1)), Ó
static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert((EXPLICIT_INITIAL_INDEX_SIZE > 1) && !(EXPLICIT_INITIAL_INDEX_SIZE & (EXPLICIT_INITIAL_INDEX_SIZE - 1)), "Traits::EXPLICIT_INITIAL_INDEX_SIZE must be a power of 2 (and greater than 1)");$/;"	p	class:ConcurrentQueue	access:public	signature:(EXPLICIT_INITIAL_INDEX_SIZE > 1) && !(EXPLICIT_INITIAL_INDEX_SIZE & (EXPLICIT_INITIAL_INDEX_SIZE - 1)), Ó
static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert((IMPLICIT_INITIAL_INDEX_SIZE > 1) && !(IMPLICIT_INITIAL_INDEX_SIZE & (IMPLICIT_INITIAL_INDEX_SIZE - 1)), "Traits::IMPLICIT_INITIAL_INDEX_SIZE must be a power of 2 (and greater than 1)");$/;"	p	class:ConcurrentQueue	access:public	signature:(IMPLICIT_INITIAL_INDEX_SIZE > 1) && !(IMPLICIT_INITIAL_INDEX_SIZE & (IMPLICIT_INITIAL_INDEX_SIZE - 1)), Ó
static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert((INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) || !(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE & (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE - 1)), "Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE must be a power of 2");$/;"	p	class:ConcurrentQueue	access:public	signature:(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0) || !(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE & (INITIAL_IMPLICIT_PRODUCER_HASH_SIZE - 1)), Ó
static_assert	concurrentqueue/concurrentqueue.h	/^	static_assert(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0 || INITIAL_IMPLICIT_PRODUCER_HASH_SIZE >= 1, "Traits::INITIAL_IMPLICIT_PRODUCER_HASH_SIZE must be at least 1 (or 0 to disable implicit enqueueing)");$/;"	p	class:ConcurrentQueue	access:public	signature:(INITIAL_IMPLICIT_PRODUCER_HASH_SIZE == 0 || INITIAL_IMPLICIT_PRODUCER_HASH_SIZE >= 1, Ó)
static_is_lock_free	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free<bool> { enum { value = ATOMIC_BOOL_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
static_is_lock_free	concurrentqueue/concurrentqueue.h	/^	template<typename T> struct static_is_lock_free : static_is_lock_free_num<typename std::make_signed<T>::type> {  };$/;"	s	namespace:moodycamel::details	inherits:static_is_lock_free_num
static_is_lock_free	concurrentqueue/concurrentqueue.h	/^	template<typename U> struct static_is_lock_free<U*> { enum { value = ATOMIC_POINTER_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<int> { enum { value = ATOMIC_INT_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<long long> { enum { value = ATOMIC_LLONG_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<long> { enum { value = ATOMIC_LONG_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<short> { enum { value = ATOMIC_SHORT_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<signed char> { enum { value = ATOMIC_CHAR_LOCK_FREE }; };$/;"	s	namespace:moodycamel::details
static_is_lock_free_num	concurrentqueue/concurrentqueue.h	/^	template<typename T> struct static_is_lock_free_num { enum { value = 0 }; };$/;"	s	namespace:moodycamel::details
status	libusb/libusb.h	/^	enum libusb_transfer_status status;$/;"	m	struct:libusb_iso_packet_descriptor	typeref:enum:libusb_iso_packet_descriptor::libusb_transfer_status	access:public
status	libusb/libusb.h	/^	enum libusb_transfer_status status;$/;"	m	struct:libusb_transfer	typeref:enum:libusb_transfer::libusb_transfer_status	access:public
std	json/json.h	/^namespace std {$/;"	n
std::swap	json/json.h	/^inline void swap(Json::Value& a, Json::Value& b) { a.swap(b); }$/;"	f	namespace:std	signature:(Json::Value& a, Json::Value& b)
stop	device/state_machine.h	/^	bool stop();$/;"	p	class:tamgef::device::StateMachine	access:public	signature:()
stop	device/state_machine.h	/^bool StateMachine<T>::stop()$/;"	f	class:tamgef::device::StateMachine	signature:()
storage_	json/json.h	/^      StringStorage storage_;$/;"	m	union:Json::Value::CZString::__anon19	access:public
strictMode	json/json.h	/^  static Features strictMode();$/;"	p	class:Json::Features	access:public	signature:()
strictMode	json/json.h	/^  static void strictMode(Json::Value* settings);$/;"	p	class:Json::CharReaderBuilder	access:public	signature:(Json::Value* settings)
strictRoot_	json/json.h	/^  bool strictRoot_;$/;"	m	class:Json::Features	access:public
stringValue	json/json.h	/^  stringValue,   \/\/\/< UTF-8 string value$/;"	e	enum:Json::ValueType
string_	json/json.h	/^    char* string_;  \/\/ actually ptr to unsigned, followed by str, unless !allocated_$/;"	m	union:Json::Value::ValueHolder	access:public
subscribe	concurrentqueue/concurrentqueue.h	/^		static void subscribe(ThreadExitListener* listener)$/;"	f	class:moodycamel::details::ThreadExitNotifier	access:public	signature:(ThreadExitListener* listener)
swap	concurrentqueue/concurrentqueue.h	/^		void swap(FreeList& other) { details::swap_relaxed(freeListHead, other.freeListHead); }$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:(FreeList& other)
swap	device/device.h	/^	void swap(GenericDevice<InputT, OutputT, StateT, EventT> &);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(GenericDevice<InputT, OutputT, StateT, EventT> &)
swap	device/device.h	/^swap(GenericDevice<InputT, OutputT, StateT, EventT> & other)$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<InputT, OutputT, StateT, EventT> & other)
swap	device/event.h	/^	void swap(Event<T> &);$/;"	p	class:tamgef::device::Event	access:public	signature:(Event<T> &)
swap	device/event.h	/^void Event<T>::swap(Event<T> & other) throw()$/;"	f	class:tamgef::device::Event	signature:(Event<T> & other)
swap	json/json.h	/^    void swap(CZString& other);$/;"	p	class:Json::Value::CZString	access:private	signature:(CZString& other)
swap	json/json.h	/^  void swap(Value& other);$/;"	p	class:Json::Value	access:public	signature:(Value& other)
swap	json/json.h	/^inline void swap(Json::Value& a, Json::Value& b) { a.swap(b); }$/;"	f	namespace:std	signature:(Json::Value& a, Json::Value& b)
swap	observer/observable.h	/^	void swap(Observable<T> &);$/;"	p	class:tamgef::observer::Observable	access:public	signature:(Observable<T> &)
swap	queue/queue_poller.h	/^	void swap(QueuePoller<T> &);$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:(QueuePoller<T> &)
swap	queue/queue_reader.h	/^	void swap(QueueReader<T> &);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(QueueReader<T> &)
swap	queue/queue_reader.h	/^void QueueReader<T>::swap(QueueReader<T> & other)$/;"	f	class:tamgef::queue::QueueReader	signature:(QueueReader<T> & other)
swapPayload	json/json.h	/^  void swapPayload(Value& other);$/;"	p	class:Json::Value	access:public	signature:(Value& other)
swap_internal	concurrentqueue/concurrentqueue.h	/^	ConcurrentQueue& swap_internal(ConcurrentQueue& other)$/;"	f	class:ConcurrentQueue	access:private	signature:(ConcurrentQueue& other)
swap_relaxed	concurrentqueue/concurrentqueue.h	/^	static inline void swap_relaxed(std::atomic<T>& left, std::atomic<T>& right)$/;"	f	namespace:moodycamel::details	signature:(std::atomic<T>& left, std::atomic<T>& right)
tail	concurrentqueue/concurrentqueue.h	/^		ThreadExitListener* tail;$/;"	m	class:moodycamel::details::ThreadExitNotifier	access:private
tailBlock	concurrentqueue/concurrentqueue.h	/^		Block* tailBlock;$/;"	m	struct:ConcurrentQueue::ProducerBase	access:protected
tailIndex	concurrentqueue/concurrentqueue.h	/^		std::atomic<index_t> tailIndex;		\/\/ Where to enqueue to next$/;"	m	struct:ConcurrentQueue::ProducerBase	access:protected
tamgef	device/device.h	/^namespace tamgef {$/;"	n
tamgef	device/domain.h	/^namespace tamgef {$/;"	n
tamgef	device/event.h	/^namespace tamgef {$/;"	n
tamgef	device/state_machine.h	/^namespace tamgef {$/;"	n
tamgef	device/usb_writer.h	/^namespace tamgef {$/;"	n
tamgef	observer/iobservable.h	/^namespace tamgef {$/;"	n
tamgef	observer/iobserver.h	/^namespace tamgef {$/;"	n
tamgef	observer/observable.h	/^namespace tamgef {$/;"	n
tamgef	queue/iqueue.h	/^namespace tamgef {$/;"	n
tamgef	queue/observer_queue_controller.h	/^namespace tamgef {$/;"	n
tamgef	queue/queue.h	/^namespace tamgef$/;"	n
tamgef	queue/queue_poller.h	/^namespace tamgef {$/;"	n
tamgef	queue/queue_reader.h	/^namespace tamgef {$/;"	n
tamgef::device	device/device.h	/^namespace device {$/;"	n	namespace:tamgef
tamgef::device	device/domain.h	/^namespace device { $/;"	n	namespace:tamgef
tamgef::device	device/event.h	/^namespace device {$/;"	n	namespace:tamgef
tamgef::device	device/state_machine.h	/^namespace device {$/;"	n	namespace:tamgef
tamgef::device	device/usb_writer.h	/^namespace device {$/;"	n	namespace:tamgef
tamgef::device::Domain	device/domain.h	/^class Domain$/;"	c	namespace:tamgef::device
tamgef::device::Domain::Domain	device/domain.h	/^	Domain() = default;$/;"	p	class:tamgef::device::Domain	access:public	signature:()
tamgef::device::Domain::Domain	device/domain.h	/^	Domain(Domain<T> &&);$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> &&)
tamgef::device::Domain::Domain	device/domain.h	/^	Domain(Domain<T> const&);$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> const&)
tamgef::device::Domain::Domain	device/domain.h	/^	Domain(std::function<bool(T)>);$/;"	p	class:tamgef::device::Domain	access:public	signature:(std::function<bool(T)>)
tamgef::device::Domain::Domain	device/domain.h	/^Domain<T>::Domain(Domain<T> && other) :$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> && other)
tamgef::device::Domain::Domain	device/domain.h	/^Domain<T>::Domain(Domain<T> const& other) :$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> const& other)
tamgef::device::Domain::Domain	device/domain.h	/^Domain<T>::Domain(std::function<bool(T)> predicate) :$/;"	f	class:tamgef::device::Domain	signature:(std::function<bool(T)> predicate)
tamgef::device::Domain::mPredicate	device/domain.h	/^	std::function<bool(T)> mPredicate;$/;"	m	class:tamgef::device::Domain	access:private
tamgef::device::Domain::operator ()	device/domain.h	/^	bool operator()(T) const;$/;"	p	class:tamgef::device::Domain	access:public	signature:(T) const
tamgef::device::Domain::operator ()	device/domain.h	/^bool Domain<T>::operator()(T element) const$/;"	f	class:tamgef::device::Domain	signature:(T element) const
tamgef::device::Domain::operator *	device/domain.h	/^	Domain<T> operator*(Domain<T> const&) const;$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> const&) const
tamgef::device::Domain::operator *	device/domain.h	/^Domain<T> Domain<T>::operator*(Domain<T> const& other) const$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> const& other) const
tamgef::device::Domain::operator +	device/domain.h	/^	Domain<T> operator+(Domain<T> const&) const;$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> const&) const
tamgef::device::Domain::operator +	device/domain.h	/^Domain<T> Domain<T>::operator+(Domain<T> const& other) const$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> const& other) const
tamgef::device::Domain::operator =	device/domain.h	/^	Domain<T> operator=(Domain<T> &&);$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> &&)
tamgef::device::Domain::operator =	device/domain.h	/^	Domain<T> operator=(Domain<T> const&);$/;"	p	class:tamgef::device::Domain	access:public	signature:(Domain<T> const&)
tamgef::device::Domain::operator =	device/domain.h	/^Domain<T> Domain<T>::operator=(Domain<T> && other)$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> && other)
tamgef::device::Domain::operator =	device/domain.h	/^Domain<T> Domain<T>::operator=(Domain<T> const& other)$/;"	f	class:tamgef::device::Domain	signature:(Domain<T> const& other)
tamgef::device::Domain::~Domain	device/domain.h	/^	virtual ~Domain() = default;$/;"	p	class:tamgef::device::Domain	access:public	signature:()
tamgef::device::Event	device/event.h	/^class Event$/;"	c	namespace:tamgef::device
tamgef::device::Event::Event	device/event.h	/^	Event() = delete;$/;"	p	class:tamgef::device::Event	access:public	signature:()
tamgef::device::Event::Event	device/event.h	/^	Event(Event<T> &&);$/;"	p	class:tamgef::device::Event	access:public	signature:(Event<T> &&)
tamgef::device::Event::Event	device/event.h	/^	Event(Event<T> const&);$/;"	p	class:tamgef::device::Event	access:public	signature:(Event<T> const&)
tamgef::device::Event::Event	device/event.h	/^	Event(T const&);$/;"	p	class:tamgef::device::Event	access:public	signature:(T const&)
tamgef::device::Event::Event	device/event.h	/^Event<T>::Event(Event<T> && other) :$/;"	f	class:tamgef::device::Event	signature:(Event<T> && other)
tamgef::device::Event::Event	device/event.h	/^Event<T>::Event(Event<T> const& other) :$/;"	f	class:tamgef::device::Event	signature:(Event<T> const& other)
tamgef::device::Event::Event	device/event.h	/^Event<T>::Event(T const& type) :$/;"	f	class:tamgef::device::Event	signature:(T const& type)
tamgef::device::Event::lower	device/event.h	/^	void lower();$/;"	p	class:tamgef::device::Event	access:public	signature:()
tamgef::device::Event::lower	device/event.h	/^void Event<T>::lower()$/;"	f	class:tamgef::device::Event	signature:()
tamgef::device::Event::mFlag	device/event.h	/^	bool mFlag;$/;"	m	class:tamgef::device::Event	access:private
tamgef::device::Event::mType	device/event.h	/^	T mType;$/;"	m	class:tamgef::device::Event	access:private
tamgef::device::Event::operator =	device/event.h	/^	Event<T> & operator=(Event<T>);$/;"	p	class:tamgef::device::Event	access:public	signature:(Event<T>)
tamgef::device::Event::operator =	device/event.h	/^Event<T> & Event<T>::operator=(Event<T> other)$/;"	f	class:tamgef::device::Event	signature:(Event<T> other)
tamgef::device::Event::raise	device/event.h	/^	void raise();$/;"	p	class:tamgef::device::Event	access:public	signature:()
tamgef::device::Event::raise	device/event.h	/^void Event<T>::raise()$/;"	f	class:tamgef::device::Event	signature:()
tamgef::device::Event::registerType	device/event.h	/^	static void registerType(T const&);$/;"	p	class:tamgef::device::Event	access:public	signature:(T const&)
tamgef::device::Event::registerType	device/event.h	/^	static void registerType(std::initializer_list<T> const&);$/;"	p	class:tamgef::device::Event	access:public	signature:(std::initializer_list<T> const&)
tamgef::device::Event::registerType	device/event.h	/^void Event<T>::registerType(T const& type)$/;"	f	class:tamgef::device::Event	signature:(T const& type)
tamgef::device::Event::registerType	device/event.h	/^void Event<T>::registerType(std::initializer_list<T> const& types)$/;"	f	class:tamgef::device::Event	signature:(std::initializer_list<T> const& types)
tamgef::device::Event::registered	device/event.h	/^	static bool registered(T const&);$/;"	p	class:tamgef::device::Event	access:public	signature:(T const&)
tamgef::device::Event::registered	device/event.h	/^bool Event<T>::registered(T const& type)$/;"	f	class:tamgef::device::Event	signature:(T const& type)
tamgef::device::Event::registeredTypes	device/event.h	/^	static std::vector<T> registeredTypes();$/;"	p	class:tamgef::device::Event	access:public	signature:()
tamgef::device::Event::registeredTypes	device/event.h	/^std::vector<T> Event<T>::registeredTypes()$/;"	f	class:tamgef::device::Event	signature:()
tamgef::device::Event::sRegisteredTypes	device/event.h	/^	static std::vector<T> sRegisteredTypes;$/;"	m	class:tamgef::device::Event	access:private
tamgef::device::Event::sRegisteredTypes	device/event.h	/^template<typename T> std::vector<T> Event<T>::sRegisteredTypes;$/;"	m	class:tamgef::device::Event
tamgef::device::Event::swap	device/event.h	/^	void swap(Event<T> &);$/;"	p	class:tamgef::device::Event	access:public	signature:(Event<T> &)
tamgef::device::Event::swap	device/event.h	/^void Event<T>::swap(Event<T> & other) throw()$/;"	f	class:tamgef::device::Event	signature:(Event<T> & other)
tamgef::device::Event::type	device/event.h	/^	T type() const;$/;"	p	class:tamgef::device::Event	access:public	signature:() const
tamgef::device::Event::type	device/event.h	/^T Event<T>::type() const$/;"	f	class:tamgef::device::Event	signature:() const
tamgef::device::Event::~Event	device/event.h	/^	virtual ~Event() = default;$/;"	p	class:tamgef::device::Event	access:public	signature:()
tamgef::device::GenericDevice	device/device.h	/^class GenericDevice$/;"	c	namespace:tamgef::device
tamgef::device::GenericDevice::EventFunction	device/device.h	/^	typedef std::function<Event<EventT>(StateT)> EventFunction;$/;"	t	class:tamgef::device::GenericDevice	access:public
tamgef::device::GenericDevice::EventList	device/device.h	/^	typedef std::vector<EventFunction> EventList;$/;"	t	class:tamgef::device::GenericDevice	access:public
tamgef::device::GenericDevice::GenericDevice	device/device.h	/^	GenericDevice($/;"	p	class:tamgef::device::GenericDevice	access:public	signature:( GenericDevice<InputT, OutputT, StateT, EventT> const&)
tamgef::device::GenericDevice::GenericDevice	device/device.h	/^	GenericDevice($/;"	p	class:tamgef::device::GenericDevice	access:public	signature:( InputDomain, OutputDomain, ResolutionFunction, StateFunction, std::initializer_list<EventFunction> )
tamgef::device::GenericDevice::GenericDevice	device/device.h	/^	GenericDevice();$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:()
tamgef::device::GenericDevice::GenericDevice	device/device.h	/^	GenericDevice(GenericDevice<InputT, OutputT, StateT, EventT> &&);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(GenericDevice<InputT, OutputT, StateT, EventT> &&)
tamgef::device::GenericDevice::GenericDevice	device/device.h	/^GenericDevice($/;"	f	class:tamgef::device::GenericDevice	signature:( InputDomain inputDomain, OutputDomain outputDomain, ResolutionFunction resolutionFunction, StateFunction stateFunction, std::initializer_list<EventFunction> eventList)
tamgef::device::GenericDevice::GenericDevice	device/device.h	/^GenericDevice() :$/;"	f	class:tamgef::device::GenericDevice	signature:()
tamgef::device::GenericDevice::GenericDevice	device/device.h	/^GenericDevice(GenericDevice<InputT, OutputT, StateT, EventT> && other) :$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<InputT, OutputT, StateT, EventT> && other)
tamgef::device::GenericDevice::GenericDevice	device/device.h	/^GenericDevice(GenericDevice<InputT, OutputT, StateT, EventT> const& other) :$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<InputT, OutputT, StateT, EventT> const& other)
tamgef::device::GenericDevice::InputDomain	device/device.h	/^	typedef std::function<bool(InputT)> InputDomain;$/;"	t	class:tamgef::device::GenericDevice	access:public
tamgef::device::GenericDevice::OutputDomain	device/device.h	/^	typedef std::function<bool(OutputT)> OutputDomain;$/;"	t	class:tamgef::device::GenericDevice	access:public
tamgef::device::GenericDevice::ResolutionFunction	device/device.h	/^	typedef std::function<OutputT(InputT)> ResolutionFunction;$/;"	t	class:tamgef::device::GenericDevice	access:public
tamgef::device::GenericDevice::StateFunction	device/device.h	/^		StateFunction;$/;"	t	class:tamgef::device::GenericDevice	access:public
tamgef::device::GenericDevice::combine	device/device.h	/^	combine(GenericDevice<InputT, OutputT, StateT, EventT> const&);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(GenericDevice<InputT, OutputT, StateT, EventT> const&)
tamgef::device::GenericDevice::combine	device/device.h	/^combine(GenericDevice<InputT, OutputT, StateT, EventT> const& other)$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<InputT, OutputT, StateT, EventT> const& other)
tamgef::device::GenericDevice::connect	device/device.h	/^	void connect(GenericDevice<OtherInputT, InputT, OtherStateT, OtherEventT> const&);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(GenericDevice<OtherInputT, InputT, OtherStateT, OtherEventT> const&)
tamgef::device::GenericDevice::connect	device/device.h	/^	void connect(QueueReader<Event<EventT>> &);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(QueueReader<Event<EventT>> &)
tamgef::device::GenericDevice::connect	device/device.h	/^	void connect(QueueReader<InputT>);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(QueueReader<InputT>)
tamgef::device::GenericDevice::connect	device/device.h	/^	void connect(QueueReader<OutputT> &);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(QueueReader<OutputT> &)
tamgef::device::GenericDevice::connect	device/device.h	/^connect(GenericDevice<OtherInputT, InputT, OtherStateT, OtherEventT> const& other)$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<OtherInputT, InputT, OtherStateT, OtherEventT> const& other)
tamgef::device::GenericDevice::connect	device/device.h	/^connect(QueueReader<Event<EventT>> & eventReader)$/;"	f	class:tamgef::device::GenericDevice	signature:(QueueReader<Event<EventT>> & eventReader)
tamgef::device::GenericDevice::connect	device/device.h	/^connect(QueueReader<InputT> inputConnection)$/;"	f	class:tamgef::device::GenericDevice	signature:(QueueReader<InputT> inputConnection)
tamgef::device::GenericDevice::connect	device/device.h	/^connect(QueueReader<OutputT> & outputReader) $/;"	f	class:tamgef::device::GenericDevice	signature:(QueueReader<OutputT> & outputReader)
tamgef::device::GenericDevice::disconnect	device/device.h	/^	void disconnect();$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:()
tamgef::device::GenericDevice::disconnect	device/device.h	/^disconnect()$/;"	f	class:tamgef::device::GenericDevice	signature:()
tamgef::device::GenericDevice::mCurrentState	device/device.h	/^	StateT mCurrentState;$/;"	m	class:tamgef::device::GenericDevice	access:private
tamgef::device::GenericDevice::mEventList	device/device.h	/^	EventList mEventList;$/;"	m	class:tamgef::device::GenericDevice	access:private
tamgef::device::GenericDevice::mInputConnection	device/device.h	/^	QueueReader<InputT> mInputConnection;$/;"	m	class:tamgef::device::GenericDevice	access:private
tamgef::device::GenericDevice::mInputDomain	device/device.h	/^	InputDomain mInputDomain;$/;"	m	class:tamgef::device::GenericDevice	access:private
tamgef::device::GenericDevice::mOutputDomain	device/device.h	/^	OutputDomain mOutputDomain;$/;"	m	class:tamgef::device::GenericDevice	access:private
tamgef::device::GenericDevice::mResolutionFunction	device/device.h	/^	ResolutionFunction mResolutionFunction;$/;"	m	class:tamgef::device::GenericDevice	access:private
tamgef::device::GenericDevice::mStateFunction	device/device.h	/^	StateFunction mStateFunction;$/;"	m	class:tamgef::device::GenericDevice	access:private
tamgef::device::GenericDevice::operator =	device/device.h	/^	GenericDevice<InputT, OutputT, StateT, EventT> & operator=($/;"	p	class:tamgef::device::GenericDevice	access:public	signature:( GenericDevice<InputT, OutputT, StateT, EventT>)
tamgef::device::GenericDevice::operator =	device/device.h	/^operator=(GenericDevice<InputT, OutputT, StateT, EventT> other)$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<InputT, OutputT, StateT, EventT> other)
tamgef::device::GenericDevice::pEventQueue	device/device.h	/^	std::shared_ptr<Queue<Event<EventT>>> pEventQueue;$/;"	m	class:tamgef::device::GenericDevice	access:private
tamgef::device::GenericDevice::pOutputQueue	device/device.h	/^	std::shared_ptr<Queue<OutputT>> pOutputQueue;$/;"	m	class:tamgef::device::GenericDevice	access:private
tamgef::device::GenericDevice::read	device/device.h	/^	bool read();$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:()
tamgef::device::GenericDevice::read	device/device.h	/^	bool read(InputT);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(InputT)
tamgef::device::GenericDevice::read	device/device.h	/^read()$/;"	f	class:tamgef::device::GenericDevice	signature:()
tamgef::device::GenericDevice::read	device/device.h	/^read(InputT input)$/;"	f	class:tamgef::device::GenericDevice	signature:(InputT input)
tamgef::device::GenericDevice::state	device/device.h	/^	StateT state();$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:()
tamgef::device::GenericDevice::state	device/device.h	/^state() $/;"	f	class:tamgef::device::GenericDevice	signature:()
tamgef::device::GenericDevice::swap	device/device.h	/^	void swap(GenericDevice<InputT, OutputT, StateT, EventT> &);$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:(GenericDevice<InputT, OutputT, StateT, EventT> &)
tamgef::device::GenericDevice::swap	device/device.h	/^swap(GenericDevice<InputT, OutputT, StateT, EventT> & other)$/;"	f	class:tamgef::device::GenericDevice	signature:(GenericDevice<InputT, OutputT, StateT, EventT> & other)
tamgef::device::GenericDevice::~GenericDevice	device/device.h	/^	virtual ~GenericDevice() = default;$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:()
tamgef::device::StateMachine	device/state_machine.h	/^class StateMachine$/;"	c	namespace:tamgef::device
tamgef::device::StateMachine::StateMachine	device/state_machine.h	/^	StateMachine();$/;"	p	class:tamgef::device::StateMachine	access:public	signature:()
tamgef::device::StateMachine::StateMachine	device/state_machine.h	/^	StateMachine(StateMachine const&) = delete;$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(StateMachine const&)
tamgef::device::StateMachine::StateMachine	device/state_machine.h	/^	StateMachine(StateMachine&&);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(StateMachine&&)
tamgef::device::StateMachine::StateMachine	device/state_machine.h	/^StateMachine<T>::StateMachine() :$/;"	f	class:tamgef::device::StateMachine	signature:()
tamgef::device::StateMachine::addState	device/state_machine.h	/^	bool addState(std::string const& stateName);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& stateName)
tamgef::device::StateMachine::addState	device/state_machine.h	/^	bool addState(std::string const& stateName,$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& stateName, std::function<T> const& stateEvent)
tamgef::device::StateMachine::addState	device/state_machine.h	/^bool StateMachine<T>::addState(std::string const& stateName)$/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& stateName)
tamgef::device::StateMachine::addState	device/state_machine.h	/^bool StateMachine<T>::addState(std::string const& stateName, $/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& stateName, std::function<T> const& stateEvent)
tamgef::device::StateMachine::addTransition	device/state_machine.h	/^	bool addTransition(std::string const& fromStateName,$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& fromStateName, std::string const& toStateName)
tamgef::device::StateMachine::addTransition	device/state_machine.h	/^	bool addTransition(std::string const& fromStateName,$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& fromStateName, std::string const& toStateName, std::function<bool()> const& transitionPredicate)
tamgef::device::StateMachine::addTransition	device/state_machine.h	/^bool StateMachine<T>::addTransition(std::string const& fromState, $/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& fromState, std::string const& toState)
tamgef::device::StateMachine::addTransition	device/state_machine.h	/^bool StateMachine<T>::addTransition(std::string const& fromState, $/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& fromState, std::string const& toState, std::function<bool()> const& transitionPredicate)
tamgef::device::StateMachine::getPresentState	device/state_machine.h	/^	std::string getPresentState() const;$/;"	p	class:tamgef::device::StateMachine	access:public	signature:() const
tamgef::device::StateMachine::getPresentState	device/state_machine.h	/^std::string StateMachine<T>::getPresentState() const$/;"	f	class:tamgef::device::StateMachine	signature:() const
tamgef::device::StateMachine::mEventQueue	device/state_machine.h	/^	moodycamel::ConcurrentQueue<std::function<T>> mEventQueue;$/;"	m	class:tamgef::device::StateMachine	access:public
tamgef::device::StateMachine::mEventThreadPool	device/state_machine.h	/^	std::vector<std::thread> mEventThreadPool;$/;"	m	class:tamgef::device::StateMachine	access:public
tamgef::device::StateMachine::mFinalStateName	device/state_machine.h	/^	std::string mFinalStateName;$/;"	m	class:tamgef::device::StateMachine	access:public
tamgef::device::StateMachine::mInitialStateName	device/state_machine.h	/^	std::string mInitialStateName;$/;"	m	class:tamgef::device::StateMachine	access:public
tamgef::device::StateMachine::mIsActive	device/state_machine.h	/^	std::atomic<bool> mIsActive;$/;"	m	class:tamgef::device::StateMachine	access:public
tamgef::device::StateMachine::mPresentStateName	device/state_machine.h	/^	std::string mPresentStateName;$/;"	m	class:tamgef::device::StateMachine	access:public
tamgef::device::StateMachine::mStateMap	device/state_machine.h	/^	std::map<std::string, std::function<T>> mStateMap;$/;"	m	class:tamgef::device::StateMachine	access:public
tamgef::device::StateMachine::mTransitionMap	device/state_machine.h	/^		std::function<bool()>>> mTransitionMap;$/;"	m	class:tamgef::device::StateMachine	access:public
tamgef::device::StateMachine::operator =	device/state_machine.h	/^	StateMachine& operator=(StateMachine const&);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(StateMachine const&)
tamgef::device::StateMachine::operator =	device/state_machine.h	/^	StateMachine& operator=(StateMachine&&);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(StateMachine&&)
tamgef::device::StateMachine::pStateHandlerThread	device/state_machine.h	/^	std::shared_ptr<std::thread> pStateHandlerThread;$/;"	m	class:tamgef::device::StateMachine	access:public
tamgef::device::StateMachine::setFinalState	device/state_machine.h	/^	bool setFinalState(std::string const& stateName);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& stateName)
tamgef::device::StateMachine::setFinalState	device/state_machine.h	/^bool StateMachine<T>::setFinalState(std::string const& stateName)$/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& stateName)
tamgef::device::StateMachine::setInitialState	device/state_machine.h	/^	bool setInitialState(std::string const& stateName);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& stateName)
tamgef::device::StateMachine::setInitialState	device/state_machine.h	/^bool StateMachine<T>::setInitialState(std::string const& stateName)$/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& stateName)
tamgef::device::StateMachine::start	device/state_machine.h	/^	bool start();$/;"	p	class:tamgef::device::StateMachine	access:public	signature:()
tamgef::device::StateMachine::start	device/state_machine.h	/^	bool start(std::string const& initialStateName);$/;"	p	class:tamgef::device::StateMachine	access:public	signature:(std::string const& initialStateName)
tamgef::device::StateMachine::start	device/state_machine.h	/^bool StateMachine<T>::start()$/;"	f	class:tamgef::device::StateMachine	signature:()
tamgef::device::StateMachine::start	device/state_machine.h	/^bool StateMachine<T>::start(std::string const& initialStateName)$/;"	f	class:tamgef::device::StateMachine	signature:(std::string const& initialStateName)
tamgef::device::StateMachine::stateHandler	device/state_machine.h	/^	void stateHandler();$/;"	p	class:tamgef::device::StateMachine	access:public	signature:()
tamgef::device::StateMachine::stateHandler	device/state_machine.h	/^void StateMachine<T>::stateHandler()$/;"	f	class:tamgef::device::StateMachine	signature:()
tamgef::device::StateMachine::stop	device/state_machine.h	/^	bool stop();$/;"	p	class:tamgef::device::StateMachine	access:public	signature:()
tamgef::device::StateMachine::stop	device/state_machine.h	/^bool StateMachine<T>::stop()$/;"	f	class:tamgef::device::StateMachine	signature:()
tamgef::device::StateMachine::~StateMachine	device/state_machine.h	/^	~StateMachine();$/;"	p	class:tamgef::device::StateMachine	access:public	signature:()
tamgef::device::StateMachine::~StateMachine	device/state_machine.h	/^StateMachine<T>::~StateMachine()$/;"	f	class:tamgef::device::StateMachine	signature:()
tamgef::device::USBWriter	device/usb_writer.h	/^class USBWriter$/;"	c	namespace:tamgef::device
tamgef::observer	observer/iobservable.h	/^namespace observer {$/;"	n	namespace:tamgef
tamgef::observer	observer/iobserver.h	/^namespace observer {$/;"	n	namespace:tamgef
tamgef::observer	observer/observable.h	/^namespace observer {$/;"	n	namespace:tamgef
tamgef::observer::IObservable	observer/iobservable.h	/^template<typename T> class IObservable$/;"	c	namespace:tamgef::observer
tamgef::observer::IObservable::attachObserver	observer/iobservable.h	/^	virtual void attachObserver($/;"	p	class:tamgef::observer::IObservable	access:public	signature:( std::shared_ptr<IObserver<T>> observer)
tamgef::observer::IObservable::detachObserver	observer/iobservable.h	/^	virtual void detachObserver($/;"	p	class:tamgef::observer::IObservable	access:public	signature:( std::shared_ptr<IObserver<T>> observer)
tamgef::observer::IObservable::notifyObservers	observer/iobservable.h	/^	virtual void notifyObservers() = 0;$/;"	p	class:tamgef::observer::IObservable	access:public	signature:()
tamgef::observer::IObservable::~IObservable	observer/iobservable.h	/^	virtual ~IObservable() = default; $/;"	p	class:tamgef::observer::IObservable	access:public	signature:()
tamgef::observer::IObserver	observer/iobserver.h	/^class IObserver$/;"	c	namespace:tamgef::observer
tamgef::observer::IObserver::update	observer/iobserver.h	/^	virtual bool update(T message) = 0;$/;"	p	class:tamgef::observer::IObserver	access:public	signature:(T message)
tamgef::observer::IObserver::~IObserver	observer/iobserver.h	/^	virtual ~IObserver() = default;$/;"	p	class:tamgef::observer::IObserver	access:public	signature:()
tamgef::observer::Observable	observer/observable.h	/^class Observable : public IObservable<T>$/;"	c	namespace:tamgef::observer	inherits:IObservable
tamgef::observer::Observable::Observable	observer/observable.h	/^	Observable() = default;$/;"	p	class:tamgef::observer::Observable	access:public	signature:()
tamgef::observer::Observable::Observable	observer/observable.h	/^	Observable(Observable<T> &&);$/;"	p	class:tamgef::observer::Observable	access:public	signature:(Observable<T> &&)
tamgef::observer::Observable::Observable	observer/observable.h	/^	Observable(Observable<T> const&);$/;"	p	class:tamgef::observer::Observable	access:public	signature:(Observable<T> const&)
tamgef::observer::Observable::Observable	observer/observable.h	/^	Observable(std::initializer_list<std::shared_ptr<IObserver<T>>>);$/;"	p	class:tamgef::observer::Observable	access:public	signature:(std::initializer_list<std::shared_ptr<IObserver<T>>>)
tamgef::observer::Observable::Observable	observer/observable.h	/^Observable<T>::Observable(Observable<T> && other) :$/;"	f	class:tamgef::observer::Observable	signature:(Observable<T> && other)
tamgef::observer::Observable::Observable	observer/observable.h	/^Observable<T>::Observable(Observable<T> const& other) :$/;"	f	class:tamgef::observer::Observable	signature:(Observable<T> const& other)
tamgef::observer::Observable::Observable	observer/observable.h	/^Observable<T>::Observable(std::initializer_list<std::shared_ptr<IObserver<T>>> observers) :$/;"	f	class:tamgef::observer::Observable	signature:(std::initializer_list<std::shared_ptr<IObserver<T>>> observers)
tamgef::observer::Observable::attachObserver	observer/observable.h	/^	virtual void attachObserver(std::initializer_list<std::shared_ptr<IObserver<T>>>);$/;"	p	class:tamgef::observer::Observable	access:public	signature:(std::initializer_list<std::shared_ptr<IObserver<T>>>)
tamgef::observer::Observable::attachObserver	observer/observable.h	/^void Observable<T>::attachObserver($/;"	f	class:tamgef::observer::Observable	signature:( std::initializer_list<std::shared_ptr<IObserver<T>>> observers)
tamgef::observer::Observable::attachObserver	observer/observable.h	/^void Observable<T>::attachObserver($/;"	f	class:tamgef::observer::Observable	signature:( std::shared_ptr<IObserver<T>> observer)
tamgef::observer::Observable::detachObserver	observer/observable.h	/^void Observable<T>::detachObserver($/;"	f	class:tamgef::observer::Observable	signature:( std::shared_ptr<IObserver<T>> observer)
tamgef::observer::Observable::mObservers	observer/observable.h	/^	std::vector<std::weak_ptr<IObserver<T>>> mObservers;$/;"	m	class:tamgef::observer::Observable	access:private
tamgef::observer::Observable::mObserversMutex	observer/observable.h	/^	std::mutex mObserversMutex;$/;"	m	class:tamgef::observer::Observable	access:private
tamgef::observer::Observable::notifyObservers	observer/observable.h	/^void Observable<T>::notifyObservers(T const& message)$/;"	f	class:tamgef::observer::Observable	signature:(T const& message)
tamgef::observer::Observable::override	observer/observable.h	/^			std::shared_ptr<IObserver<T>> observer) override;$/;"	m	class:tamgef::observer::Observable	access:public
tamgef::observer::Observable::override	observer/observable.h	/^	virtual void notifyObservers(T const&) override;$/;"	m	class:tamgef::observer::Observable	access:public
tamgef::observer::Observable::swap	observer/observable.h	/^	void swap(Observable<T> &);$/;"	p	class:tamgef::observer::Observable	access:public	signature:(Observable<T> &)
tamgef::queue	queue/iqueue.h	/^namespace queue {$/;"	n	namespace:tamgef
tamgef::queue	queue/observer_queue_controller.h	/^namespace queue {$/;"	n	namespace:tamgef
tamgef::queue	queue/queue.h	/^namespace queue $/;"	n	namespace:tamgef
tamgef::queue	queue/queue_poller.h	/^namespace queue {$/;"	n	namespace:tamgef
tamgef::queue	queue/queue_reader.h	/^namespace queue {$/;"	n	namespace:tamgef
tamgef::queue::IQueue	queue/iqueue.h	/^class IQueue$/;"	c	namespace:tamgef::queue
tamgef::queue::IQueue::dequeue	queue/iqueue.h	/^	virtual bool dequeue(T & element) = 0;$/;"	p	class:tamgef::queue::IQueue	access:public	signature:(T & element)
tamgef::queue::IQueue::empty	queue/iqueue.h	/^	virtual bool empty() const$/;"	f	class:tamgef::queue::IQueue	access:public	signature:() const
tamgef::queue::IQueue::enqueue	queue/iqueue.h	/^	virtual bool enqueue(T element) = 0;$/;"	p	class:tamgef::queue::IQueue	access:public	signature:(T element)
tamgef::queue::IQueue::size	queue/iqueue.h	/^	virtual size_t size() const = 0;$/;"	p	class:tamgef::queue::IQueue	access:public	signature:() const
tamgef::queue::IQueue::~IQueue	queue/iqueue.h	/^	virtual ~IQueue() = default;$/;"	p	class:tamgef::queue::IQueue	access:public	signature:()
tamgef::queue::ObserverQueueController	queue/observer_queue_controller.h	/^class ObserverQueueController$/;"	c	namespace:tamgef::queue
tamgef::queue::ObserverQueueController::ObserverQueueController	queue/observer_queue_controller.h	/^	ObserverQueueController($/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:( ObserverQueueController<T> &&)
tamgef::queue::ObserverQueueController::ObserverQueueController	queue/observer_queue_controller.h	/^	ObserverQueueController($/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:( ObserverQueueController<T> const&)
tamgef::queue::ObserverQueueController::ObserverQueueController	queue/observer_queue_controller.h	/^	ObserverQueueController() = delete;$/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:()
tamgef::queue::ObserverQueueController::ObserverQueueController	queue/observer_queue_controller.h	/^	ObserverQueueController(QueueReader<T>, $/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:(QueueReader<T>, std::initializer_list<std::shared_ptr<observer::IObserver<T>>>)
tamgef::queue::ObserverQueueController::ObserverQueueController	queue/observer_queue_controller.h	/^ObserverQueueController<T>::ObserverQueueController(QueueReader<T> queueReader,$/;"	f	class:tamgef::queue::ObserverQueueController	signature:(QueueReader<T> queueReader, std::initializer_list<std::shared_ptr<observer::IObserver<T>>> observers)
tamgef::queue::ObserverQueueController::attachObserver	queue/observer_queue_controller.h	/^	void attachObserver(std::shared_ptr<observer::IObserver<T>>);$/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:(std::shared_ptr<observer::IObserver<T>>)
tamgef::queue::ObserverQueueController::attachObserver	queue/observer_queue_controller.h	/^void ObserverQueueController<T>::attachObserver($/;"	f	class:tamgef::queue::ObserverQueueController	signature:( std::shared_ptr<observer::IObserver<T>> observer_ptr)
tamgef::queue::ObserverQueueController::detachObserver	queue/observer_queue_controller.h	/^	void detachObserver(std::shared_ptr<observer::IObserver<T>>);$/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:(std::shared_ptr<observer::IObserver<T>>)
tamgef::queue::ObserverQueueController::detachObserver	queue/observer_queue_controller.h	/^void ObserverQueueController<T>::detachObserver($/;"	f	class:tamgef::queue::ObserverQueueController	signature:( std::shared_ptr<observer::IObserver<T>> observer_ptr)
tamgef::queue::ObserverQueueController::mObservable	queue/observer_queue_controller.h	/^	observer::Observable<T> mObservable;$/;"	m	class:tamgef::queue::ObserverQueueController	access:private
tamgef::queue::ObserverQueueController::mQueuePoller	queue/observer_queue_controller.h	/^	QueuePoller<T> mQueuePoller;$/;"	m	class:tamgef::queue::ObserverQueueController	access:private
tamgef::queue::ObserverQueueController::~ObserverQueueController	queue/observer_queue_controller.h	/^	virtual ~ObserverQueueController();$/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:()
tamgef::queue::Queue	queue/queue.h	/^class Queue : public IQueue<T>$/;"	c	namespace:tamgef::queue	inherits:IQueue
tamgef::queue::Queue::dequeue	queue/queue.h	/^bool Queue<T>::dequeue(T& element)$/;"	f	class:tamgef::queue::Queue	signature:(T& element)
tamgef::queue::Queue::enqueue	queue/queue.h	/^bool Queue<T>::enqueue(T element)$/;"	f	class:tamgef::queue::Queue	signature:(T element)
tamgef::queue::Queue::mQueue	queue/queue.h	/^	moodycamel::ConcurrentQueue<T> mQueue;$/;"	m	class:tamgef::queue::Queue	access:private
tamgef::queue::Queue::override	queue/queue.h	/^	bool dequeue(T& element) override;$/;"	m	class:tamgef::queue::Queue	access:public
tamgef::queue::Queue::override	queue/queue.h	/^	bool enqueue(T element) override;$/;"	m	class:tamgef::queue::Queue	access:public
tamgef::queue::Queue::override	queue/queue.h	/^	size_t size() const override;$/;"	m	class:tamgef::queue::Queue	access:public
tamgef::queue::Queue::size	queue/queue.h	/^size_t Queue<T>::size() const$/;"	f	class:tamgef::queue::Queue	signature:() const
tamgef::queue::QueuePoller	queue/queue_poller.h	/^class QueuePoller$/;"	c	namespace:tamgef::queue
tamgef::queue::QueuePoller::QueuePoller	queue/queue_poller.h	/^	QueuePoller(QueuePoller<T> &&);$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:(QueuePoller<T> &&)
tamgef::queue::QueuePoller::QueuePoller	queue/queue_poller.h	/^	QueuePoller(QueuePoller<T> const&);$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:(QueuePoller<T> const&)
tamgef::queue::QueuePoller::QueuePoller	queue/queue_poller.h	/^	QueuePoller(QueueReader<T> &);$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:(QueueReader<T> &)
tamgef::queue::QueuePoller::QueuePoller	queue/queue_poller.h	/^QueuePoller<T>::QueuePoller($/;"	f	class:tamgef::queue::QueuePoller	signature:( QueueReader<T> & queueReader, std::function<void(T) handler)
tamgef::queue::QueuePoller::QueuePoller	queue/queue_poller.h	/^QueuePoller<T>::QueuePoller(QueuePoller<T> && other) :$/;"	f	class:tamgef::queue::QueuePoller	signature:(QueuePoller<T> && other)
tamgef::queue::QueuePoller::QueuePoller	queue/queue_poller.h	/^QueuePoller<T>::QueuePoller(QueuePoller<T> const& other) :$/;"	f	class:tamgef::queue::QueuePoller	signature:(QueuePoller<T> const& other)
tamgef::queue::QueuePoller::error	queue/queue_poller.h	/^	std::exception_ptr error();$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:()
tamgef::queue::QueuePoller::error	queue/queue_poller.h	/^std::exception_ptr QueuePoller<T>::error()$/;"	f	class:tamgef::queue::QueuePoller	signature:()
tamgef::queue::QueuePoller::mException	queue/queue_poller.h	/^	std::exception_ptr mException;$/;"	m	class:tamgef::queue::QueuePoller	access:private
tamgef::queue::QueuePoller::mExceptionMutex	queue/queue_poller.h	/^	std::mutex mExceptionMutex;$/;"	m	class:tamgef::queue::QueuePoller	access:private
tamgef::queue::QueuePoller::mHandler	queue/queue_poller.h	/^	std::function<void(T)> mHandler;$/;"	m	class:tamgef::queue::QueuePoller	access:private
tamgef::queue::QueuePoller::mPolling	queue/queue_poller.h	/^	std::atomic<bool> mPolling;$/;"	m	class:tamgef::queue::QueuePoller	access:private
tamgef::queue::QueuePoller::mQueueReader	queue/queue_poller.h	/^	QueueReader<T> mQueueReader;$/;"	m	class:tamgef::queue::QueuePoller	access:private
tamgef::queue::QueuePoller::mThread	queue/queue_poller.h	/^	std::thread mThread;$/;"	m	class:tamgef::queue::QueuePoller	access:private
tamgef::queue::QueuePoller::poll	queue/queue_poller.h	/^	void poll();$/;"	p	class:tamgef::queue::QueuePoller	access:private	signature:()
tamgef::queue::QueuePoller::poll	queue/queue_poller.h	/^void QueuePoller<T>::poll()$/;"	f	class:tamgef::queue::QueuePoller	signature:()
tamgef::queue::QueuePoller::polling	queue/queue_poller.h	/^	bool polling();$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:()
tamgef::queue::QueuePoller::polling	queue/queue_poller.h	/^bool QueuePoller<T>::polling()$/;"	f	class:tamgef::queue::QueuePoller	signature:()
tamgef::queue::QueuePoller::swap	queue/queue_poller.h	/^	void swap(QueuePoller<T> &);$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:(QueuePoller<T> &)
tamgef::queue::QueuePoller::~QueuePoller	queue/queue_poller.h	/^	virtual ~QueuePoller();$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:()
tamgef::queue::QueuePoller::~QueuePoller	queue/queue_poller.h	/^QueuePoller<T>::~QueuePoller()$/;"	f	class:tamgef::queue::QueuePoller	signature:()
tamgef::queue::QueueReader	queue/queue_reader.h	/^class QueueReader$/;"	c	namespace:tamgef::queue
tamgef::queue::QueueReader::QueueReader	queue/queue_reader.h	/^	QueueReader() = default;$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
tamgef::queue::QueueReader::QueueReader	queue/queue_reader.h	/^	QueueReader(QueueReader<T> &&);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(QueueReader<T> &&)
tamgef::queue::QueueReader::QueueReader	queue/queue_reader.h	/^	QueueReader(QueueReader<T> const&);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(QueueReader<T> const&)
tamgef::queue::QueueReader::QueueReader	queue/queue_reader.h	/^	QueueReader(std::shared_ptr<IQueue<T>>);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(std::shared_ptr<IQueue<T>>)
tamgef::queue::QueueReader::QueueReader	queue/queue_reader.h	/^QueueReader<T>::QueueReader(QueueReader<T> && other)$/;"	f	class:tamgef::queue::QueueReader	signature:(QueueReader<T> && other)
tamgef::queue::QueueReader::QueueReader	queue/queue_reader.h	/^QueueReader<T>::QueueReader(QueueReader<T> const& other) :$/;"	f	class:tamgef::queue::QueueReader	signature:(QueueReader<T> const& other)
tamgef::queue::QueueReader::QueueReader	queue/queue_reader.h	/^QueueReader<T>::QueueReader(std::shared_ptr<IQueue<T>> queue) :$/;"	f	class:tamgef::queue::QueueReader	signature:(std::shared_ptr<IQueue<T>> queue)
tamgef::queue::QueueReader::connect	queue/queue_reader.h	/^	void connect(std::shared_ptr<IQueue<T>>);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(std::shared_ptr<IQueue<T>>)
tamgef::queue::QueueReader::connect	queue/queue_reader.h	/^void QueueReader<T>::connect(std::shared_ptr<IQueue<T>> queue)$/;"	f	class:tamgef::queue::QueueReader	signature:(std::shared_ptr<IQueue<T>> queue)
tamgef::queue::QueueReader::dequeue	queue/queue_reader.h	/^	bool dequeue(T &);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(T &)
tamgef::queue::QueueReader::dequeue	queue/queue_reader.h	/^bool QueueReader<T>::dequeue(T & item)$/;"	f	class:tamgef::queue::QueueReader	signature:(T & item)
tamgef::queue::QueueReader::disconnect	queue/queue_reader.h	/^	void disconnect();$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
tamgef::queue::QueueReader::disconnect	queue/queue_reader.h	/^void QueueReader<T>::disconnect()$/;"	f	class:tamgef::queue::QueueReader	signature:()
tamgef::queue::QueueReader::empty	queue/queue_reader.h	/^	bool empty();$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
tamgef::queue::QueueReader::empty	queue/queue_reader.h	/^bool QueueReader<T>::empty()$/;"	f	class:tamgef::queue::QueueReader	signature:()
tamgef::queue::QueueReader::expired	queue/queue_reader.h	/^	bool expired();$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
tamgef::queue::QueueReader::expired	queue/queue_reader.h	/^bool QueueReader<T>::expired()$/;"	f	class:tamgef::queue::QueueReader	signature:()
tamgef::queue::QueueReader::operator =	queue/queue_reader.h	/^	QueueReader<T> & operator=(QueueReader<T>);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(QueueReader<T>)
tamgef::queue::QueueReader::operator =	queue/queue_reader.h	/^QueueReader<T> & QueueReader<T>::operator=(QueueReader<T> other)$/;"	f	class:tamgef::queue::QueueReader	signature:(QueueReader<T> other)
tamgef::queue::QueueReader::pQueue	queue/queue_reader.h	/^	std::weak_ptr<IQueue<T>> pQueue;$/;"	m	class:tamgef::queue::QueueReader	access:private
tamgef::queue::QueueReader::size	queue/queue_reader.h	/^	size_t size();$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
tamgef::queue::QueueReader::size	queue/queue_reader.h	/^size_t QueueReader<T>::size()$/;"	f	class:tamgef::queue::QueueReader	signature:()
tamgef::queue::QueueReader::swap	queue/queue_reader.h	/^	void swap(QueueReader<T> &);$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:(QueueReader<T> &)
tamgef::queue::QueueReader::swap	queue/queue_reader.h	/^void QueueReader<T>::swap(QueueReader<T> & other)$/;"	f	class:tamgef::queue::QueueReader	signature:(QueueReader<T> & other)
tamgef::queue::QueueReader::~QueueReader	queue/queue_reader.h	/^	virtual ~QueueReader() = default;$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
thread_id	concurrentqueue/concurrentqueue.h	/^	static inline thread_id_t thread_id() { return rl::thread_index(); }$/;"	f	namespace:moodycamel::details	signature:()
thread_id	concurrentqueue/concurrentqueue.h	/^	static inline thread_id_t thread_id() { return static_cast<thread_id_t>(::GetCurrentThreadId()); }$/;"	f	namespace:moodycamel::details	signature:()
thread_id	concurrentqueue/concurrentqueue.h	/^	static inline thread_id_t thread_id() { static MOODYCAMEL_THREADLOCAL int x; return reinterpret_cast<thread_id_t>(&x); }$/;"	f	namespace:moodycamel::details	signature:()
thread_id_t	concurrentqueue/concurrentqueue.h	/^	typedef std::uint32_t thread_id_t;$/;"	t	namespace:moodycamel::details
thread_id_t	concurrentqueue/concurrentqueue.h	/^	typedef std::uintptr_t thread_id_t;$/;"	t	namespace:moodycamel::details
throwLogicError	json/json.h	/^void throwLogicError(std::string const& msg);$/;"	p	namespace:Json	signature:(std::string const& msg)
throwRuntimeError	json/json.h	/^void throwRuntimeError(std::string const& msg);$/;"	p	namespace:Json	signature:(std::string const& msg)
timeout	libusb/libusb.h	/^	unsigned int timeout;$/;"	m	struct:libusb_transfer	access:public
toStyledString	json/json.h	/^  std::string toStyledString() const;$/;"	p	class:Json::Value	access:public	signature:() const
token	concurrentqueue/concurrentqueue.h	/^		ProducerToken* token;$/;"	m	struct:moodycamel::details::ConcurrentQueueProducerTypelessBase	access:public
tokenArrayBegin	json/json.h	/^    tokenArrayBegin,$/;"	e	enum:Json::Reader::TokenType
tokenArrayEnd	json/json.h	/^    tokenArrayEnd,$/;"	e	enum:Json::Reader::TokenType
tokenArraySeparator	json/json.h	/^    tokenArraySeparator,$/;"	e	enum:Json::Reader::TokenType
tokenComment	json/json.h	/^    tokenComment,$/;"	e	enum:Json::Reader::TokenType
tokenEndOfStream	json/json.h	/^    tokenEndOfStream = 0,$/;"	e	enum:Json::Reader::TokenType
tokenError	json/json.h	/^    tokenError$/;"	e	enum:Json::Reader::TokenType
tokenFalse	json/json.h	/^    tokenFalse,$/;"	e	enum:Json::Reader::TokenType
tokenMemberSeparator	json/json.h	/^    tokenMemberSeparator,$/;"	e	enum:Json::Reader::TokenType
tokenNull	json/json.h	/^    tokenNull,$/;"	e	enum:Json::Reader::TokenType
tokenNumber	json/json.h	/^    tokenNumber,$/;"	e	enum:Json::Reader::TokenType
tokenObjectBegin	json/json.h	/^    tokenObjectBegin,$/;"	e	enum:Json::Reader::TokenType
tokenObjectEnd	json/json.h	/^    tokenObjectEnd,$/;"	e	enum:Json::Reader::TokenType
tokenString	json/json.h	/^    tokenString,$/;"	e	enum:Json::Reader::TokenType
tokenTrue	json/json.h	/^    tokenTrue,$/;"	e	enum:Json::Reader::TokenType
token_	json/json.h	/^    Token token_;$/;"	m	class:Json::Reader::ErrorInfo	access:public
try_dequeue	concurrentqueue/concurrentqueue.h	/^	bool try_dequeue(U& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(U& item)
try_dequeue	concurrentqueue/concurrentqueue.h	/^	bool try_dequeue(consumer_token_t& token, U& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(consumer_token_t& token, U& item)
try_dequeue_bulk	concurrentqueue/concurrentqueue.h	/^	size_t try_dequeue_bulk(It itemFirst, size_t max)$/;"	f	class:ConcurrentQueue	access:public	signature:(It itemFirst, size_t max)
try_dequeue_bulk	concurrentqueue/concurrentqueue.h	/^	size_t try_dequeue_bulk(consumer_token_t& token, It itemFirst, size_t max)$/;"	f	class:ConcurrentQueue	access:public	signature:(consumer_token_t& token, It itemFirst, size_t max)
try_dequeue_bulk_from_producer	concurrentqueue/concurrentqueue.h	/^	inline size_t try_dequeue_bulk_from_producer(producer_token_t const& producer, It itemFirst, size_t max)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& producer, It itemFirst, size_t max)
try_dequeue_from_producer	concurrentqueue/concurrentqueue.h	/^	inline bool try_dequeue_from_producer(producer_token_t const& producer, U& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& producer, U& item)
try_dequeue_non_interleaved	concurrentqueue/concurrentqueue.h	/^	bool try_dequeue_non_interleaved(U& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(U& item)
try_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool try_enqueue(T const& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(T const& item)
try_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool try_enqueue(T&& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(T&& item)
try_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool try_enqueue(producer_token_t const& token, T const& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, T const& item)
try_enqueue	concurrentqueue/concurrentqueue.h	/^	inline bool try_enqueue(producer_token_t const& token, T&& item)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, T&& item)
try_enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	bool try_enqueue_bulk(It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:public	signature:(It itemFirst, size_t count)
try_enqueue_bulk	concurrentqueue/concurrentqueue.h	/^	bool try_enqueue_bulk(producer_token_t const& token, It itemFirst, size_t count)$/;"	f	class:ConcurrentQueue	access:public	signature:(producer_token_t const& token, It itemFirst, size_t count)
try_get	concurrentqueue/concurrentqueue.h	/^		inline N* try_get()$/;"	f	struct:ConcurrentQueue::FreeList	access:public	signature:()
type	device/event.h	/^	T type() const;$/;"	p	class:tamgef::device::Event	access:public	signature:() const
type	device/event.h	/^T Event<T>::type() const$/;"	f	class:tamgef::device::Event	signature:() const
type	json/json.h	/^  ValueType type() const;$/;"	p	class:Json::Value	access:public	signature:() const
type	libusb/libusb.h	/^	unsigned char type;$/;"	m	struct:libusb_transfer	access:public
type_	json/json.h	/^    TokenType type_;$/;"	m	class:Json::Reader::Token	access:public
uint16_t	libusb/libusb.h	/^typedef unsigned __int16  uint16_t;$/;"	t
uint32_t	libusb/libusb.h	/^typedef unsigned __int32  uint32_t;$/;"	t
uint8_t	libusb/libusb.h	/^typedef unsigned __int8   uint8_t;$/;"	t
uintValue	json/json.h	/^  uintValue,     \/\/\/< unsigned integer value$/;"	e	enum:Json::ValueType
uint_	json/json.h	/^    LargestUInt uint_;$/;"	m	union:Json::Value::ValueHolder	access:public
unindent	json/json.h	/^  void unindent();$/;"	p	class:Json::StyledStreamWriter	access:private	signature:()
unindent	json/json.h	/^  void unindent();$/;"	p	class:Json::StyledWriter	access:private	signature:()
unlikely	concurrentqueue/concurrentqueue.h	/^	inline bool unlikely(bool x) { return __builtin_expect((x), false); }$/;"	f	namespace:moodycamel::details	signature:(bool x)
unsubscribe	concurrentqueue/concurrentqueue.h	/^		static void unsubscribe(ThreadExitListener* listener)$/;"	f	class:moodycamel::details::ThreadExitNotifier	access:public	signature:(ThreadExitListener* listener)
update	observer/iobserver.h	/^	virtual bool update(T message) = 0;$/;"	p	class:tamgef::observer::IObserver	access:public	signature:(T message)
update_current_producer_after_rotation	concurrentqueue/concurrentqueue.h	/^	inline bool update_current_producer_after_rotation(consumer_token_t& token)$/;"	f	class:ConcurrentQueue	access:private	signature:(consumer_token_t& token)
userData	concurrentqueue/concurrentqueue.h	/^		void* userData;$/;"	m	struct:moodycamel::details::ThreadExitListener	access:public
user_data	libusb/libusb.h	/^	void *user_data;$/;"	m	struct:libusb_transfer	access:public
valid	concurrentqueue/concurrentqueue.h	/^	inline bool valid() const { return producer != nullptr; }$/;"	f	namespace:moodycamel	signature:() const
validate	json/json.h	/^  bool validate(Json::Value* invalid) const;$/;"	p	class:Json::CharReaderBuilder	access:public	signature:(Json::Value* invalid) const
validate	json/json.h	/^  bool validate(Json::Value* invalid) const;$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:(Json::Value* invalid) const
value	concurrentqueue/concurrentqueue.h	/^		static const T value = std::numeric_limits<T>::is_signed$/;"	m	struct:moodycamel::details::const_numeric_max	access:public
value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free<bool> { enum { value = ATOMIC_BOOL_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free::__anon17
value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<int> { enum { value = ATOMIC_INT_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon14
value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<long long> { enum { value = ATOMIC_LLONG_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon16
value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<long> { enum { value = ATOMIC_LONG_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon15
value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<short> { enum { value = ATOMIC_SHORT_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon13
value	concurrentqueue/concurrentqueue.h	/^	template<> struct static_is_lock_free_num<signed char> { enum { value = ATOMIC_CHAR_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon12
value	concurrentqueue/concurrentqueue.h	/^	template<typename T> struct static_is_lock_free_num { enum { value = 0 }; };$/;"	e	enum:moodycamel::details::static_is_lock_free_num::__anon11
value	concurrentqueue/concurrentqueue.h	/^	template<typename U> struct static_is_lock_free<U*> { enum { value = ATOMIC_POINTER_LOCK_FREE }; };$/;"	e	enum:moodycamel::details::static_is_lock_free::__anon18
valueToQuotedString	json/json.h	/^std::string JSON_API valueToQuotedString(const char* value);$/;"	p	namespace:Json	signature:(const char* value)
valueToString	json/json.h	/^std::string JSON_API valueToString(Int value);$/;"	p	namespace:Json	signature:(Int value)
valueToString	json/json.h	/^std::string JSON_API valueToString(LargestInt value);$/;"	p	namespace:Json	signature:(LargestInt value)
valueToString	json/json.h	/^std::string JSON_API valueToString(LargestUInt value);$/;"	p	namespace:Json	signature:(LargestUInt value)
valueToString	json/json.h	/^std::string JSON_API valueToString(UInt value);$/;"	p	namespace:Json	signature:(UInt value)
valueToString	json/json.h	/^std::string JSON_API valueToString(bool value);$/;"	p	namespace:Json	signature:(bool value)
valueToString	json/json.h	/^std::string JSON_API valueToString(double value);$/;"	p	namespace:Json	signature:(double value)
value_	json/json.h	/^  } value_;$/;"	m	class:Json::Value	typeref:union:Json::Value::ValueHolder	access:private
value_type	json/json.h	/^  typedef Value value_type;$/;"	t	class:Json::ValueIterator	access:public
value_type	json/json.h	/^  typedef const Value value_type;$/;"	t	class:Json::ValueConstIterator	access:public
wBytesPerInterval	libusb/libusb.h	/^	uint16_t wBytesPerInterval;$/;"	m	struct:libusb_ss_endpoint_companion_descriptor	access:public
wIndex	libusb/libusb.h	/^	uint16_t wIndex;$/;"	m	struct:libusb_control_setup	access:public
wLength	libusb/libusb.h	/^	uint16_t wLength;$/;"	m	struct:libusb_control_setup	access:public
wMaxPacketSize	libusb/libusb.h	/^	uint16_t wMaxPacketSize;$/;"	m	struct:libusb_endpoint_descriptor	access:public
wSpeedSupported	libusb/libusb.h	/^	uint16_t wSpeedSupported;$/;"	m	struct:libusb_ss_usb_device_capability_descriptor	access:public
wTotalLength	libusb/libusb.h	/^	uint16_t wTotalLength;$/;"	m	struct:libusb_bos_descriptor	access:public
wTotalLength	libusb/libusb.h	/^	uint16_t wTotalLength;$/;"	m	struct:libusb_config_descriptor	access:public
wValue	libusb/libusb.h	/^	uint16_t wValue;$/;"	m	struct:libusb_control_setup	access:public
what	json/json.h	/^  virtual char const* what() const throw();$/;"	p	class:Json::Exception	access:public	signature:() const
write	json/json.h	/^  virtual int write(Value const& root, std::ostream* sout) = 0;$/;"	p	class:Json::StreamWriter	access:public	signature:(Value const& root, std::ostream* sout)
write	json/json.h	/^  virtual std::string write(const Value& root) = 0;$/;"	p	class:Json::Writer	access:public	signature:(const Value& root)
write	json/json.h	/^  virtual std::string write(const Value& root);$/;"	p	class:Json::FastWriter	access:public	signature:(const Value& root)
write	json/json.h	/^  virtual std::string write(const Value& root);$/;"	p	class:Json::StyledWriter	access:public	signature:(const Value& root)
write	json/json.h	/^  void write(std::ostream& out, const Value& root);$/;"	p	class:Json::StyledStreamWriter	access:public	signature:(std::ostream& out, const Value& root)
writeArrayValue	json/json.h	/^  void writeArrayValue(const Value& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& value)
writeArrayValue	json/json.h	/^  void writeArrayValue(const Value& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& value)
writeCommentAfterValueOnSameLine	json/json.h	/^  void writeCommentAfterValueOnSameLine(const Value& root);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& root)
writeCommentAfterValueOnSameLine	json/json.h	/^  void writeCommentAfterValueOnSameLine(const Value& root);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& root)
writeCommentBeforeValue	json/json.h	/^  void writeCommentBeforeValue(const Value& root);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& root)
writeCommentBeforeValue	json/json.h	/^  void writeCommentBeforeValue(const Value& root);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& root)
writeIndent	json/json.h	/^  void writeIndent();$/;"	p	class:Json::StyledStreamWriter	access:private	signature:()
writeIndent	json/json.h	/^  void writeIndent();$/;"	p	class:Json::StyledWriter	access:private	signature:()
writeString	json/json.h	/^std::string JSON_API writeString(StreamWriter::Factory const& factory, Value const& root);$/;"	p	namespace:Json	signature:(StreamWriter::Factory const& factory, Value const& root)
writeValue	json/json.h	/^  void writeValue(const Value& value);$/;"	p	class:Json::FastWriter	access:private	signature:(const Value& value)
writeValue	json/json.h	/^  void writeValue(const Value& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const Value& value)
writeValue	json/json.h	/^  void writeValue(const Value& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const Value& value)
writeWithIndent	json/json.h	/^  void writeWithIndent(const std::string& value);$/;"	p	class:Json::StyledStreamWriter	access:private	signature:(const std::string& value)
writeWithIndent	json/json.h	/^  void writeWithIndent(const std::string& value);$/;"	p	class:Json::StyledWriter	access:private	signature:(const std::string& value)
yamlCompatiblityEnabled_	json/json.h	/^  bool yamlCompatiblityEnabled_;$/;"	m	class:Json::FastWriter	access:private
~CZString	json/json.h	/^    ~CZString();$/;"	p	class:Json::Value::CZString	access:public	signature:()
~CharReader	json/json.h	/^  virtual ~CharReader() {}$/;"	f	class:Json::CharReader	access:public	signature:()
~CharReaderBuilder	json/json.h	/^  virtual ~CharReaderBuilder();$/;"	p	class:Json::CharReaderBuilder	access:public	signature:()
~CommentInfo	json/json.h	/^    ~CommentInfo();$/;"	p	struct:Json::Value::CommentInfo	access:public	signature:()
~ConcurrentQueue	concurrentqueue/concurrentqueue.h	/^	~ConcurrentQueue()$/;"	f	class:ConcurrentQueue	access:public	signature:()
~Domain	device/domain.h	/^	virtual ~Domain() = default;$/;"	p	class:tamgef::device::Domain	access:public	signature:()
~Event	device/event.h	/^	virtual ~Event() = default;$/;"	p	class:tamgef::device::Event	access:public	signature:()
~Exception	json/json.h	/^  virtual ~Exception() throw();$/;"	p	class:Json::Exception	access:public	signature:()
~ExplicitProducer	concurrentqueue/concurrentqueue.h	/^		~ExplicitProducer()$/;"	f	struct:ConcurrentQueue::ExplicitProducer	access:public	signature:()
~Factory	json/json.h	/^    virtual ~Factory() {}$/;"	f	class:Json::CharReader::Factory	access:public	signature:()
~Factory	json/json.h	/^    virtual ~Factory();$/;"	p	class:Json::StreamWriter::Factory	access:public	signature:()
~FastWriter	json/json.h	/^  virtual ~FastWriter() {}$/;"	f	class:Json::FastWriter	access:public	signature:()
~GenericDevice	device/device.h	/^	virtual ~GenericDevice() = default;$/;"	p	class:tamgef::device::GenericDevice	access:public	signature:()
~IObservable	observer/iobservable.h	/^	virtual ~IObservable() = default; $/;"	p	class:tamgef::observer::IObservable	access:public	signature:()
~IObserver	observer/iobserver.h	/^	virtual ~IObserver() = default;$/;"	p	class:tamgef::observer::IObserver	access:public	signature:()
~IQueue	queue/iqueue.h	/^	virtual ~IQueue() = default;$/;"	p	class:tamgef::queue::IQueue	access:public	signature:()
~ImplicitProducer	concurrentqueue/concurrentqueue.h	/^		~ImplicitProducer()$/;"	f	struct:ConcurrentQueue::ImplicitProducer	access:public	signature:()
~ObserverQueueController	queue/observer_queue_controller.h	/^	virtual ~ObserverQueueController();$/;"	p	class:tamgef::queue::ObserverQueueController	access:public	signature:()
~ProducerBase	concurrentqueue/concurrentqueue.h	/^		virtual ~ProducerBase() { };$/;"	f	struct:ConcurrentQueue::ProducerBase	access:public	signature:()
~ProducerToken	concurrentqueue/concurrentqueue.h	/^	~ProducerToken()$/;"	f	namespace:moodycamel	signature:()
~QueuePoller	queue/queue_poller.h	/^	virtual ~QueuePoller();$/;"	p	class:tamgef::queue::QueuePoller	access:public	signature:()
~QueuePoller	queue/queue_poller.h	/^QueuePoller<T>::~QueuePoller()$/;"	f	class:tamgef::queue::QueuePoller	signature:()
~QueueReader	queue/queue_reader.h	/^	virtual ~QueueReader() = default;$/;"	p	class:tamgef::queue::QueueReader	access:public	signature:()
~StateMachine	device/state_machine.h	/^	~StateMachine();$/;"	p	class:tamgef::device::StateMachine	access:public	signature:()
~StateMachine	device/state_machine.h	/^StateMachine<T>::~StateMachine()$/;"	f	class:tamgef::device::StateMachine	signature:()
~StreamWriter	json/json.h	/^  virtual ~StreamWriter();$/;"	p	class:Json::StreamWriter	access:public	signature:()
~StreamWriterBuilder	json/json.h	/^  virtual ~StreamWriterBuilder();$/;"	p	class:Json::StreamWriterBuilder	access:public	signature:()
~StyledStreamWriter	json/json.h	/^  ~StyledStreamWriter() {}$/;"	f	class:Json::StyledStreamWriter	access:public	signature:()
~StyledWriter	json/json.h	/^  virtual ~StyledWriter() {}$/;"	f	class:Json::StyledWriter	access:public	signature:()
~ThreadExitNotifier	concurrentqueue/concurrentqueue.h	/^		~ThreadExitNotifier()$/;"	f	class:moodycamel::details::ThreadExitNotifier	access:private	signature:()
~Value	json/json.h	/^  ~Value();$/;"	p	class:Json::Value	access:public	signature:()
~Writer	json/json.h	/^  virtual ~Writer();$/;"	p	class:Json::Writer	access:public	signature:()
